<!--
==================================== 80 ========================================
==================================== 72 ================================
 -->
<!--
     Check for lines containing the string "CEP".
     Also for lines containing the string "JPD" (John Dowdell 20140827)
  -->


# Overview

The Ad hoc On-Demand Distance Vector Version 2 (AODVv2) protocol enables
dynamic, self-starting, multihop routing between participating mobile
nodes wishing to establish and maintain an ad hoc network. The
basic operations of the AODVv2 protocol are route discovery and
route maintenance.  AODVv2 does not require nodes to maintain routes
to destinations that are not in active communication.  AODVv2 allows
mobile nodes to respond to link breakages and changes in network
topology in a timely manner.  The operation of AODVv2 is loop-free,
and by avoiding the Bellman-Ford "counting to infinity" problem
offers quick convergence when the ad hoc network topology changes
(typically, when a node moves in the network).  When links break,
AODVv2 causes the affected set of nodes to be notified so that they
are able to invalidate the routes using the lost link.

One distinguishing feature of AODVv2 is its use of a destination
sequence number for each route entry.  The destination sequence
number is created by the destination to be included along with any
route information it sends to requesting nodes.  Using destination
sequence numbers ensures loop freedom and is simple to program.
Given the choice between two routes to a destination, a requesting
node is required to select the one with the greatest sequence number.

Compared to AODV [](#RFC3561), AODVv2 makes some features optional,
notably intermediate route replies, expanding ring search, and
precursor lists.  Hello messages and local repair have been removed.
AODVv2 provides a mechanism for the use of multiple metric types.
Message formats have been updated and made compliant with [](#RFC5444).
AODVv2 control messages are defined as sets of data, which are mapped
to message elements using the Generalized MANET Packet/Message Format
defined in [](#RFC5444) and sent using the parameters in [](#RFC5498).
Verification of link bidirectionality has been substantially improved, and
additional refinements made for route timeouts and state management.

Although AODVv2 is closely related to AODV [](#RFC3561), and shares some features of DSR [](#RFC4728), AODVv2 is not
interoperable with either of those protocols. Compared to AODV, AODVv2 makes some features optional, notably
intermediate route replies, expanding ring search, and precursor lists. Hello messages and local repair have been removed.
AODVv2 provides a mechanism for the use of multiple metric types. Message formats have been updated and made compliant
with [](#RFC5444).

AODVv2 control messages are defined as sets of data, which are mapped to messages using the Generalized MANET
Packet/Message Format defined in [](#RFC5444) and sent using the parameters in [](#RFC5498).

The basic operations of the AODVv2 protocol are route discovery and route maintenance.

An AODVv2 router is configured to perform route discovery on behalf of a configured set of IP addresses known as Router Clients.
Route discovery is performed when an AODVv2 router needs to forward an IP packet from one of its Router Clients, but does not have
a valid route to the packet's destination. AODVv2 routers use Route Request (RREQ) and Route Reply (RREP) messages to carry route
information between the originator of the route discovery and the router responsible for the target, establishing a route to
both endpoints on all intermediate routers. A metric value is included to represent the cost of the route contained within
the message. AODVv2 uses sequence numbers to identify stale routing information, and compares route metric values to determine
if advertised routes could form loops.

Route maintenance includes confirming bidirectionality of links to next hop AODVv2 routers, issuing Route Error (RERR) messages, reacting to received Route Error messages,
and extending and enforcing route timeouts.

The on-demand nature of AODVv2 requires signals to be exchanged between AODVv2 and the forwarding plane. These signals
indicate when: a packet is to be forwarded, in order to initiate route discovery; packet forwarding fails, in order to
initiate route error reporting; a packet is successfully forwarded, for route maintenance.

Security for authentication of AODVv2 routers and encryption of control messages is accomplished using the TIMESTAMP
and ICV TLVs defined in [](#RFC7182).


# Terminology
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as described in [](#RFC2119). In addition, this document
uses terminology from [](#RFC5444), and defines the following terms:

AddressList
:   <vspace/>A list of IP addresses as used in AODVv2 messages.
AckReq
:   <vspace/>Used in a Route Reply message to indicate the IP address of the router from which a Route Reply Acknowledgement
    is expected.
AdvRte
:   <vspace/>A route advertised in an incoming route message.
AODVv2 Router
:   <vspace/>An IP addressable device in the ad hoc network that performs the AODVv2 protocol operations specified in this document.
CurrentTime
:   <vspace/>The current time as maintained by the AODVv2 router.
<!-- [JPD] Need to have a discussion of time somewhere in the text. If no security, only need locally scoped time. Add security, and you
     need globally scoped time to support SSL etc -->
<!-- CEP: It would be wrong to require NTP for ad hoc networks -->
<!-- JPD: Completely agree, but to maintain security should we say that some method of acquiring time either locally (eg from GPS) or remotely
     (eg NTP or tlsdate) is necessary? I think it would be wrong to mandate a particular method but I believe we need to say something -->
ENAR (External Network Access Router)
:   <vspace/>An AODVv2 router with an interface to an external, non-AODVv2 network.
Invalid route
:   <vspace/>A route that cannot be used for forwarding but still contains useful sequence number information.
LocalRoute
:   <vspace/>An entry in the Local Route Set.
MANET
:   <vspace/>A Mobile Ad Hoc Network as defined in [](#RFC2501).
MetricType
:   <vspace/>The metric type for a metric value included in a message.
MetricTypeList
:   <vspace/>A list of metric types associated with the addresses in the AddressList of a Route Error message.
Neighbor
:   <vspace/>An AODVv2 router from which an RREQ or RREP message has been received. Neighbors exchange routing information and verify bidirectionality of the
    link to a neighbor before installing a route via that neighbor into the Local Route Set.
OrigAddr
:   <vspace/>The source IP address of the IP packet triggering route discovery.
OrigMetric
:   <vspace/>The metric value associated with the route to OrigAddr (and any other addresses included in the given prefix length).
OrigPrefixLen
:   <vspace/>The prefix length, in bits, configured in the Router Client entry which includes OrigAddr.
OrigSeqNum
:   <vspace/>The sequence number of the AODVv2 router which originated the Route Request on behalf of OrigAddr.
PktSource
:   <vspace/>The source address of the IP packet which triggered a Route Error message.
PrefixLengthList
:   <vspace/>A list of routing prefix lengths associated with the addresses in the AddressList of a message.
Reactive
:   <vspace/>Performed only in reaction to specific events. In AODVv2, routes are requested only when data packets need to be forwarded. In
    this document, "reactive" is synonymous with "on-demand".
RERR (Route Error)
:   <vspace/>The AODVv2 message type used to indicate that an AODVv2 router does not have a valid LocalRoute toward one or more particular destinations.
RERR_Gen (RERR Generating Router)
:   <vspace/>The AODVv2 router generating a Route Error message.
Routable Unicast IP Address
:   <vspace/>A routable unicast IP address is a unicast IP address that is scoped sufficiently to be forwarded by a router.  Globally-scoped unicast
    IP addresses and Unique Local Addresses (ULAs) [](#RFC4193) are examples of routable unicast IP addresses.
    <!-- [JPD] ULAs are NOT globally routable -->
    <!-- [CEP] That is true, but they *are* routable unicast addresses -->
    <!-- [CEP] Can it be determined if an address is multihop-capable? -->
Router Client
:   <vspace/>An address or address range configured on an AODVv2 router, on behalf of which that router will initiate and respond to route discoveries. These addresses may be used by the
    AODVv2 router itself or by non-routing devices that are reachable without traversing another AODVv2 router.
RREP (Route Reply)
:   <vspace/>The AODVv2 message type used to reply to a Route Request message.
RREP_Gen (RREP Generating Router)
:   <vspace/>The AODVv2 router that generates the Route Reply message, i.e., the router configured with TargAddr as a Router Client.
RREQ (Route Request)
:   <vspace/>The AODVv2 message type used to discover a route to TargAddr and distribute information about a route to OrigAddr.
RREQ_Gen (RREQ Generating Router)
:   <vspace/>The AODVv2 router that generates the Route Request message, i.e., the router configured with OrigAddr as a Router Client.
RteMsg (Route Message)
:   <vspace/>A Route Request (RREQ) or Route Reply (RREP) message.
SeqNum
:   <vspace/>The sequence number maintained by an AODVv2 router to indicate freshness of route information.
SeqNumList
:   <vspace/>A list of sequence numbers associated with the addresses in the AddressList of a message.
TargAddr
:   <vspace/>The target address of a route request, i.e., the destination address of the IP packet triggering route discovery.
TargMetric
:   <vspace/>The metric value associated with the route to TargAddr (and any other addresses included in the given prefix length).
TargPrefixLen
:   <vspace/>The prefix length, in bits, configured in the Router Client entry which includes TargAddr.
TargSeqNum
:   <vspace/>The sequence number of the AODVv2 router which originated the Route Reply on behalf of TargAddr.
Valid route
:   <vspace/>A route that can be used for forwarding, which has been confirmed as having a bidirectional link to the next hop, and has
    not timed out or been made invalid by a route error.
Unreachable Address
:   <vspace/>An address reported in a Route Error message, either the address on a LocalRoute which became Invalid, or the destination address of an IP
    packet that could not be forwarded because a valid LocalRoute to the destination is not known, and will not be requested.
Upstream
:   <vspace/>In the direction from destination to source (from TargAddr to OrigAddr).
ValidityTime
:   <vspace/>The length of time the route described by the message is offered.

This document uses the notational conventions in [](#conventions) to simplify the text.

Notation                               Meaning
-------                                ------
Route[Address]                         A route toward Address
Route[Address].Field                   A field in a route toward Address
RteMsg.Field                           A field in either RREQ or RREP

^[conventions:: Notational Conventions]

# Applicability Statement  {#apply}
  <!-- The nets do not have to be mobile, and AODVv2 may be applicable in low power lossy sensor networks. -->

The AODVv2 routing protocol is a reactive routing protocol. A reactive protocol only sends messages to discover a route when there is data to send on that route. Therefore, a reactive routing protocol requires certain interactions with the forwarding plane (for example, to indicate when a packet is to be forwarded,
in order to initiate route discovery). The set of signals exchanged between AODVv2 and the forwarding
plane are discussed in [](#fwdplane).

AODVv2 is designed for stub or disconnected mobile ad hoc networks, i.e., non-transit
networks or those not connected to the internet. AODVv2 can, however, be configured to perform gateway functions when attached to external
networks, as discussed in [](#gateway).

AODVv2 handles a wide variety of mobility and traffic patterns by determining routes on-demand. In networks with a large number of routers,
AODVv2 is best suited for relatively sparse traffic scenarios where each router forwards IP packets to a small percentage of other AODVv2
routers in the network. In this case fewer routes are needed, and therefore less control traffic is produced.

<!-- AODVv2 is well suited to reactive scenarios such as emergency and disaster relief, where the ability to communicate might be more important than being assured of
secure operations.  For other ad hoc networking applications, in which insecure operation could negate the value of establishing communication paths, it is
important for neighboring AODVv2 routers to establish security associations with one another. -->

AODVv2 provides for message integrity and security against replay attacks
by using integrity check values, timestamps and sequence numbers, as described in [](#Security). If security associations can be established,
encryption can be used for AODVv2 messages to ensure that only trusted routers participate in routing operations.

Since the route discovery process aims for a route to be established in both directions along the same path, uni-directional links
are not suitable. AODVv2 will detect and exclude those links from route discovery. The route discovered is optimised for the requesting router,
and the return path may not be the optimal route. <!-- Route costs learned by routers other than the requesting router may not reflect the true route
cost. -->
<!-- and the TargAddr end wouldnt request a better route if it already has a route -->

<!-- Issue #22 -->
AODVv2 is applicable to memory constrained devices, since only a little routing state is maintained in each AODVv2 router. AODVv2 routes that are not needed for forwarding data
do not need to be maintained. On routers unable to store persistent AODVv2 state, recovery can impose a performance penalty (e.g., in case of AODVv2
router reboot), since if a router loses its sequence number, there is a delay before the router can resume full operations. This is described in [](#boot).

AODVv2 supports routers with multiple interfaces and multiple IP addresses per interface. A router may also use the same IP address on multiple interfaces.
AODVv2 requires only that each interface configured for AODVv2 has at least one unicast IP address. Address assignment procedures are out of scope for AODVv2.

AODVv2 supports Router Clients with multiple interfaces, as long as each interface is configured with its own unicast IP address. Multi-homing of a Router
Client IP address is not supported by AODVv2, and therefore an IP address SHOULD NOT be configured as a Router Client on more than one AODVv2 router at any
one time.

<!-- CEP : this can be deleted -->
The routing algorithm in AODVv2 MAY be operated at layers other than the network layer, using layer-appropriate addresses.




# Data Structures

## Interface List {#interfaceslist}
If multiple interfaces of the AODVv2 router are configured for use by AODVv2, a list of the interfaces
MUST be configured in the AODVv2_INTERFACES list.


## Router Client Table {#clients}
An AODVv2 router provides route discovery services for its own local applications and for other non-routing devices that are reachable
without traversing another AODVv2 router. The addresses used by these devices, and the AODVv2 router itself, are configured in the
Router Client Table. An AODVv2 router will only originate Route Request and Route Reply messages on behalf of configured Router Client addresses.

Router Client Table entries MUST contain:

RouterClient.IPAddress
:   <vspace/>An IP address or the start of an address range that requires route discovery services from the AODVv2 router.
<!-- A client node with multiple IP addresses MAY cause the AODVv2 router to be configured with multiple Router Client entries. -->
RouterClient.PrefixLength
:   <vspace/>The length, in bits, of the routing prefix associated with the RouterClient.IPAddress. If a prefix length is
    included, the AODVv2 router MUST provide connectivity for all addresses within that prefix.
RouterClient.Cost
:   <vspace/>The cost associated with reaching this address or address range.

A Router Client address MUST NOT be served by more than one AODVv2 router at any one time. To shift responsibility for a Router Client to
a different AODVv2 router, correct AODVv2 routing behavior MUST be observed; The AODVv2 router adding the Router Client MUST wait for any
existing routing information about this Router Client to be purged from the network, i.e., at least MAX_SEQNUM_LIFETIME since the last SeqNum
update on the router which is removing this Router Client.


## Neighbor Table  {#nbrlist}

A Neighbor Table MUST be maintained with information about neighboring AODVv2 routers. Neighbor Table entries are stored when AODVv2 messages
are received. If the Neighbor is chosen as a next hop on an installed route, the link to the Neighbor MUST be tested for bidirectionality and
the result stored in this table. A route will only be considered valid when the link is confirmed to be bidirectional.

Neighbor Table entries MUST contain:

Neighbor.IPAddress
:   <vspace/>An IP address of the neighboring router, learned from the source IP address of a received route message.
Neighbor.State
:   <vspace/>Indicates whether the link to the neighbor is bidirectional. There are three possible states: Confirmed, Unknown,
    and Blacklisted. Unknown is the initial state. Confirmed indicates that the link to the neighbor has been confirmed as
    bidirectional. Blacklisted indicates that the link to the neighbor is uni-directional. [](#nexthopmonitoring) discusses
    how to monitor link bidirectionality.
Neighbor.ResetTime
:   <vspace/>When the value of Neighbor.State is Blacklisted, this indicates the time at which the value of Neighbor.State
    will revert to Unknown. By default this value is calculated at the time the router is blacklisted and is equal to CurrentTime +
    MAX_BLACKLIST_TIME. When the value of Neighbor.State is not Blacklisted, this time is set to INFINITY_TIME.



## Sequence Numbers  {#seqnum}

Sequence numbers enable AODVv2 routers to determine the temporal order of route discovery
messages, identifying stale routing information so that it can be discarded. The sequence
number fulfills the same roles as the "Destination Sequence Number" of DSDV [](#Perkins94),
and the AODV Sequence Number in [](#RFC3561).

<!-- If the router has multiple AODVv2 interfaces or IP addresses, it MAY maintain different sequence
numbers for each interface or IP address, but the router MUST NOT use multiple sequence numbers
for any one IP address.  All route messages created on behalf of Router
Clients on a particular interface MUST include the sequence number associated with that Router Client. -->

Each AODVv2 router in the network MUST maintain its own sequence number. All RREQ and RREP messages created by
an AODVv2 router include the router's sequence number, reported as a 16-bit unsigned integer. Each AODVv2 router
MUST ensure that its sequence number is strictly increasing, and that it is incremented by one (1) whenever an RREQ or
RREP is created, except when the sequence number is 65,535 (the maximum value of a 16-bit unsigned integer), in
which case it MUST be reset to one (1). The value zero (0) is reserved to indicate that the sequence
number is unknown.

An AODVv2 router MUST only attach its own sequence number to information about a route to one of its configured Router
Clients, all route messages regenerated by other routers retain the originator's sequence number. Tod determine staleness, the previously stored sequence number associated with the originator, is subtracted
from the incoming sequence number. The result of the subtraction is to be interpreted as a signed 16-bit integer, and if
less than zero, the information in the new AODVv2 message is stale and MUST be discarded.
<!-- subtraction is unsigned values, actual calculation is incoming + twos complement of current. then interpret result as a signed twos complement value -->

This, along with the processes in [](#test), ensures loop freedom.

An AODVv2 router SHOULD maintain its sequence number in persistent storage. If the
sequence number is lost, the router MUST follow the procedure in [](#boot) to safely resume
routing operations with a new sequence number.


## Local Route Set  {#rte}

All AODVv2 routers MUST maintain a Local Route Set, containing information about routes learned from AODVv2 route messages. The Local Route Set is
stored separately from the Routing Information Base, and the Routing Information Base is updated using information from the Local Route Set.
Alternatively, implementations MAY choose to modify the Routing Information Base directly.

Routes learned from AODVv2 route messages are referred to in this document as LocalRoutes, and MUST contain the following information:

LocalRoute.Address
:   <vspace/>An address, which, when combined with LocalRoute.PrefixLength, describes the set of destination addresses this
    route includes.
LocalRoute.PrefixLength
:   <vspace/>The prefix length, in bits, associated with LocalRoute.Address.
LocalRoute.SeqNum
:   <vspace/>The sequence number associated with LocalRoute.Address, obtained from the last route message that successfully
    updated this entry.
LocalRoute.NextHop
:   <vspace/>The source IP address of the IP packet containing the AODVv2 message advertising the route to LocalRoute.Address, i.e. an
    IP address of the AODVv2 router used for the next hop on the path toward LocalRoute.Address.
LocalRoute.NextHopInterface
:   <vspace/>The interface used to send IP packets toward LocalRoute.Address.
LocalRoute.LastUsed
:   <vspace/>If this route is installed in the Routing Information Base, the time it was last used to forward an IP packet.
LocalRoute.LastSeqNumUpdate
:   <vspace/>The time LocalRoute.SeqNum was last updated.
LocalRoute.ExpirationTime
:   <vspace/>The time at which this LocalRoute MUST be marked as Invalid. An AODVv2 router MAY be offered a route for a limited time. In
    this case, the route is referred to as a timed route. If a route is not timed, LocalRoute.ExpirationTime is INFINITY_TIME.
LocalRoute.MetricType
:   <vspace/>The type of metric associated with this route.
LocalRoute.Metric
:   <vspace/>The cost of the route toward LocalRoute.Address expressed in units consistent with LocalRoute.MetricType.
LocalRoute.State
:   <vspace/>The last known state (Unconfirmed, Idle, Active, or Invalid) of the route.
LocalRoute.Precursors (optional feature)
:   <vspace/>A list of upstream neighbors using the route (see [](#precursor)).

There are four possible states for a LocalRoute:

Unconfirmed
:   <vspace/>A route learned from a Route Request message, which has not yet been confirmed as bidirectional. It MUST NOT
    be used for forwarding IP packets, and therefore it is not referred to as a valid route.
Idle
:   <vspace/>A route which has been learned from a route message, and has also been confirmed, but has not been used in
    the last ACTIVE_INTERVAL. It is able to be used for forwarding IP packets, and therefore it is referred to as a valid
    route.
Active
:   <vspace/>A route which has been learned from a route message, and has also been confirmed, and has been used in the
    last ACTIVE_INTERVAL. It is able to be used for forwarding IP packets, and therefore it is referred to as a valid
    route.
Invalid
:   <vspace/>A route which has expired or been lost. It MUST NOT be used for forwarding IP packets, and therefore it
    is not referred to as a valid route. Invalid routes contain sequence number information which allows
    incoming information to be assessed for freshness.

When the Local Route Set is stored separately from the Routing Information Base, routes are added to the Routing Information Base
when LocalRoute.State is valid (set to Active or Idle), and removed from the Routing Information Base when LocalRoute.State becomes Invalid.

Changes to LocalRoute state are detailed in [](#routestatechanges).

<!--
An AODVv2 router MAY offer a route for a limited time. In this case, the route is referred to as a timed route. The length
of time for which the route is valid is referred to as validity time, and is included in messages which advertise the route.
The shortened validity time is reflected in LocalRoute.ExpirationTime. If a route is not timed, LocalRoute.ExpirationTime
is INFINITY_TIME. -->

Note that multiple entries for the same address, prefix length and metric type may exist in the Local Route Set, but only
one will be a valid entry. Any others will be Unconfirmed, but may offer improvement to the existing valid route, if they can
be confirmed as valid routes (see [](#nexthopmonitoring)).

Multiple valid routes for the same address and prefix length but for different metric types may exist in the Local Route Set, but
the decision of which of these routes to install in the Routing Information Base to use for forwarding is outside the scope of AODVv2.

<!-- JPD: Is this a security vulnerability if a faulty or malicious router sets a short validity time?
     CEP: I don't think it affects authenticity, but it could be a form of denial of service.  In that
     case, it's no worse than if the malicious router simply refuses to route the packets it has agreed
     to route. -->


## Multicast Route Message Table  {#rtemsgtable}

A route message (RteMsg) is either a Route Request or Route Reply message. RREQ messages are multicast by default and regenerated
multiple times, and RREP messages may be multicast when the link to the next router is not known to be bidirectional. Multiple similar
route messages might be received by any one router during one route discovery attempt. The AODVv2 router does not need to regenerate or respond to every
one of these messages.

The Multicast Route Message Table is a conceptual table which contains information about previously received multicast route messages, so that
incoming route messages can be compared with previously received messages to determine if the incoming information is redundant or stale, and the router can
avoid sending redundant control traffic.

Multicast Route Message Table entries MUST contain the following information:

RteMsg.MessageType
:   <vspace/>Either RREQ or RREP.
RteMsg.OrigAddr
:   <vspace/>The source address of the IP packet triggering the route request.
RteMsg.OrigPrefixLen
:   <vspace/>The prefix length associated with RteMsg.OrigAddr, originally from the Router Client entry on RREQ_Gen which includes RteMsg.OrigAddr.
RteMsg.TargAddr
:   <vspace/>The destination address of the IP packet triggering the route request.
RteMsg.TargPrefixLen
:   <vspace/>The prefix length associated with RteMsg.TargAddr, originally from the Router Client entry on RREP_Gen which includes RteMsg.TargAddr. If RteMsg is a RREQ, RteMsg.TargPrefixLen SHOULD equal address length.
RteMsg.OrigSeqNum
:   <vspace/>The sequence number associated with the route to OrigAddr, if RteMsg is an RREQ.
RteMsg.TargSeqNum
:   <vspace/>The sequence number associated with the route to TargAddr, if present in the RteMsg.
RteMsg.MetricType
:   <vspace/>The metric type of the route requested.
RteMsg.Metric
:   <vspace/>The metric value received in the RteMsg.
RteMsg.Timestamp
:   <vspace/>The last time this Multicast Route Message Table entry was updated.
RteMsg.RemoveTime
:   <vspace/>The time at which this entry MUST be removed from the Multicast Route Message Table. This is set
    to CurrentTime + MAX_SEQNUM_LIFETIME, whenever the sequence number of this entry (RteMsg.OrigSeqNum for an
    RREQ, or RteMsg.TargSeqNum for an RREP) is updated.

The Multicast Route Message Table is maintained so that no two entries have the same MessageType, OrigAddr,
TargAddr, and MetricType. See [](#suppress) for details about updating this table.


# Metrics  {#metrics}

Metrics measure a cost or quality associated with a route or a link, e.g., latency, delay, financial cost, energy, etc. Metric
values are reported in Route Request and Route Reply messages.

In Route Request messages, the metric describes the cost of the route from OrigAddr (and any other addresses included in the prefix
length of RREQ_Gen's Router Client entry for OrigAddr) to the router sending the Route Request. For RREQ_Gen, this is the cost
associated with the Router Client entry which includes OrigAddr. For routers which regenerate the RREQ, this is the cost from
OrigAddr to the regenerating router, combining the metric value from the received RREQ message with knowledge of the link cost from the
sender to the receiver, i.e., the incoming link cost. This updated route cost is included when regenerating the Route Request message,
and used to install a route back toward OrigAddr.

Similarly, in Route Reply messages, the metric reflects the cost of the route from TargAddr (and any other addresses included in the
prefix length of RREP_Gen's Router Client entry for TargAddr) to the router sending the Route Reply. For RREP_Gen, this is the cost
associated with the Router Client entry which includes TargAddr. For routers which regenerate the RREP, this is the cost from
TargAddr to the regenerating router, combining the metric value from the received RREP message with knowledge of the link cost from the
sender to the receiver, i.e., the incoming link cost. This updated route cost is included when regenerating the Route Reply message,
and used to install a route back toward TargAddr.

Assuming link metrics are symmetric, the cost of the routes installed in the Local Route Set at each router will be correct. The route
discovered is optimised for the requesting router, and the return path may not be the optimal route.

<!-- if not symmetric...could be stored with MAX_METRIC..then if forwarding data from a Router Client on a route with MAX_METRIC maybe this could indicate that a route should be requested, to learn the best cost from us to them, rather than them to us which is what we would have installed.  -->
<!-- Similarly cost on route to TargAddr is currently stored with metric from targ->current. The existing route to TargAddr is probably a good one, because it was found on a prev RREQ in that direction - its just that we dont know the accurate metric. OR, we could be adding up outgoing link costs back toward targaddr in a rrep, and also transporting the orig->targ metric unchanged, add up outgoing metrics to get correct cost for targaddr -->

AODVv2 enables the use of multiple metric types. Each route discovery attempt indicates the metric type which is requested for
the route. Only one metric type MUST be used in each route discovery attempt. However, routes to a single destination might be
requested and created in the Local Route Set for multiple metric types. The decision of which of these routes to install in the
Routing Information Base to use for forwarding is outside the scope of AODVv2.

For each MetricType, AODVv2 requires:

* A MetricType number, to indicate the metric type of a route. MetricType numbers allocated are detailed in [](#metric-type).
* A maximum value, denoted MAX_METRIC[MetricType]. This MUST always be the maximum expressible metric value of type MetricType.
  Field lengths associated with metric values are found in [](#metric-type). If the cost of a route exceeds MAX_METRIC[MetricType], the route is ignored.
* A function for incoming link cost, denoted Cost(L). Using incoming link costs means that the route learned has a path optimized
  for the direction from OrigAddr to TargAddr.
* A function for route cost, denoted Cost(R).
* A function to analyze routes for potential loops based on metric information, denoted LoopFree(R1, R2). LoopFree verifies that a route R2 is not a sub-section
  of another route R1. An AODVv2 router invokes LoopFree() as part of the process in [](#test), when an advertised route (R1) and an
  existing LocalRoute (R2) have the same destination address, metric type, and sequence number. LoopFree returns FALSE to indicate
  that an advertised route is not to be used to update a stored LocalRoute, as it may cause a routing loop. In the case where the
  existing LocalRoute is Invalid, it is possible that the advertised route includes the existing LocalRoute and came from a router
  which did not yet receive notification of the route becoming Invalid, so the advertised route should not be used to update the Local
  Route Set, in case it forms a loop to a broken route.

AODVv2 currently supports cost metrics where Cost(R) is strictly increasing, by defining:

* Cost(R) := Sum of Cost(L) of each link in the route
* LoopFree(R1, R2) := ( Cost(R1) \<= Cost(R2) )

Implementers MAY consider other metric types, but the definitions of Cost and LoopFree functions for such types are undefined, and
interoperability issues need to be considered.



# AODVv2 Protocol Operations  {#aodv_ops}

The AODVv2 protocol's operations include managing sequence numbers, monitoring next hop AODVv2 routers on discovered routes and updating the Neighbor Table,
performing route discovery and dealing with requests from other routers, processing incoming route information and updating the Local
Route Set, updating the Multicast Route Message Table and suppressing redundant messages, and reporting broken routes. These processes
are discussed in detail in the following sections.

## Initialization {#boot}

During initialization where an AODVv2 router does not have information about its previous sequence number, or if its sequence number
is lost at any point, the router resets its sequence number to one (1). However, other AODVv2 routers may still hold sequence number
information that this router previously issued. Since sequence number information is removed if there has been no update to the sequence
number in MAX_SEQNUM_LIFETIME, the initializing router MUST wait for MAX_SEQNUM_LIFETIME before it creates any messages containing its
new sequence number. It can then be sure that the information it sends will not be considered stale.

During this wait period, the router is permitted to do the following:

* Process information in a received RREQ or RREP message to learn a route to the originator or target of that route discovery
* Regenerate a received RREQ or RREP
* Send an RREP_Ack
* Maintain valid routes in the Local Route Set
<!-- and therefore in the Routing Information Base, in order that the forwarding process can forward IP packets to Router Clients and to other routers -->
* Create, process and regenerate RERR messages


## Next Hop Monitoring  {#nexthopmonitoring}

To ensure AODVv2 routers Routers do not establish routes over uni-directional links, AODVv2 routers MUST verify that the link to the next hop router is bidirectional before marking a route as valid in the Local Route Set.

AODVv2 provides a mechanism for testing bidirectional connectivity during route discovery, and blacklisting routers where bidirectional
connectivity is not available. If a route discovery is retried by RREQ_Gen, the blacklisted routers can be excluded from the process, and
a different route can be discovered. Further, a route is not to be used for forwarding until the bidirectionality of the link to the next
hop is confirmed. AODVv2 routers do not need to monitor bidirectionality for links to neighboring routers which are not used as next hops
on routes in the Local Route Set.

*  For the next hop router on the route toward OrigAddr, the approach for testing bidirectional connectivity is to request acknowledgement of
   Route Reply messages. Receipt of an acknowledgement proves that bidirectional connectivity exists. All AODVv2 routers MUST support this
   process, which is explained in [](#RREP_msgs) and [](#rrep_ack_msgs). A link to a neighbor is determined to be unidirectional if a
   requested acknowledgement is not received within RREP_Ack_SENT_TIMEOUT, or bidirectional if the acknowledgement is received within the timeout.
*  For the next hop router on the route toward TargAddr, receipt of the Route Reply message containing the route to TargAddr is confirmation
   of bidirectionality, since a Route Reply message is a reply to a Route Request message which previously crossed the link in the opposite
   direction.

To assist with next hop monitoring, a Neighbor Table ([](#nbrlist)) is maintained. When an RREQ or RREP is received from an IP address which
does not already have an entry in the Neighbor Table, a new entry is created as described in [](#nbrupdate). While the value of Neighbor.State is Unknown,
acknowledgement of RREP messages sent to that neighbor MUST be requested. If an acknowledgement is not received within the timeout period, the neighbor
MUST have Neighbor.State set to Blacklisted. If an acknowledgement is received within the timeout period, Neighbor.State is set to Confirmed.
While the value of Neighbor.State is Confirmed, the request for an acknowledgement of any other RREP message is unnecessary.
<!-- While Neighbor.State is Blacklisted, RREQs received from that router MUST be disregarded.-->
<!-- if a previously confirmed link goes uni-directional...we think it still works... if route was established and route goes unidirectional, do we
get a notification? i.e. would route break, send RERR etc? if we establish other routes over this link (but it no longer unidirectional) this is baaad....-->

When routers perform other operations such as those from the list below, these MAY be used as additional indications of connectivity:

* NHDP HELLO Messages [](#RFC6130)
* Route timeout
* Lower layer triggers, e.g. message reception or link status notifications
* TCP timeouts
* Promiscuous listening
* Other monitoring mechanisms or heuristics

If such an external process signals that the link to a neighbor is
bidirectional, the AODVv2 router MAY update the matching Neighbor
Table entry by changing the value of Neighbor.State to Confirmed, e.g. receipt of a Neighborhood Discovery
Protocol HELLO message with the receiving router listed as a neighbor.  If
an external process signals that a link is not bidirectional, the the
value of Neighbor.State MAY be changed to Blacklisted, e.g. notification of a TCP timeout.



## Neighbor Table Update {#nbrupdate}

On receipt of an RREQ or RREP message, the Neighbor Table MUST be checked for an entry with Neighbor.IPAddress which matches the source IP address
of packet containing the AODVv2 message. If no matching entry is found, a new entry is created.

A new Neighbor Table entry is created as follows:

* Neighbor.IPAddress := Source IP address of the received route message
* Neighbor.State := Unknown
* Neighbor.ResetTime := INFINITY_TIME

If the message is an RREP which answers a recently sent RREQ, or an RREP_Ack which answers a recently sent RREP, the link to the
neighbor is bidirectional and the Neighbor Table entry is updated as follows:

* Neighbor.State := Confirmed <!-- could set reset time when set state to confirmed, to re-test after certain time -->
* Neighbor.ResetTime := INFINITY_TIME

If an RREP_Ack is not received within RREP_Ack_SENT_TIMEOUT, the link is considered to be uni-directional and the Neighbor Table entry is updated as follows:

* Neighbor.State := Blacklisted
* Neighbor.ResetTime := CurrentTime + MAX_BLACKLIST_TIME

When the Neighbor.ResetTime is reached, the Neighbor Table entry is updated as follows:

* Neighbor.State := Unknown

When a link to a neighbor is determined to be broken, the Neighbor Table entry SHOULD be removed.

Route requests from neighbors with Neighbor.State set to Blacklisted are ignored to avoid persistent IP packet
loss or protocol failures. However, Neighbor.ResetTime allows the neighbor to again be allowed to participate in
route discoveries after MAX_BLACKLIST_TIME, in case the link between the routers has become bidirectional.


## Interaction with the Forwarding Plane {#fwdplane}

The signals descried in the following are conceptual signals, and can be implemented in various ways.
Conformant implementations of AODVv2 are not mandated
to implement the forwarding plane separately from the control plane or data plane; these signals and interactions are
identified simply as assistance for implementers who may find them useful.

AODVv2 requires signals from the forwarding plane:

*   A packet cannot be forwarded because a route is unavailable: AODVv2 needs to know the source and destination IP addresses of the packet.
    If the source of the packet is configured as a Router Client, the router should initiate route discovery to the destination. If it is not
    a Router Client, the router should create a Route Error message.
*   A packet is to be forwarded: AODVv2 needs to check the state of the route to ensure it is still valid.
*   Packet forwarding succeeds: AODVv2 needs to update the record of when a route was last used to forward a packet.
*   Packet forwarding failure occurs: AODVv2 needs to create a Route Error message.

AODVv2 needs to send signals to the forwarding plane:

*   A route discovery is in progress: buffering might be configured for packets requiring a route, while route discovery is attempted.
*   A route discovery failed: any buffered packets requiring that route should be discarded, and the source of the packet
    should be notified that the destination is unreachable (using an ICMP Destination Unreachable message). Route discovery fails
    if an RREQ cannot be generated because the control message generation limit has been reached, or if an RREP is not received
    within the expected time.
*   A route discovery is not permitted: any buffered packets requiring that route should be discarded. A route discovery will
    not be attempted if the source address of the packet needing a route is not configured as a Router Client.
*   A route discovery succeeded: install a corresponding route into the Routing Information Base and begin transmitting any buffered packets.
*   A route has been made invalid: remove the corresponding route from the Routing Information Base.
*   A route has been updated: update the corresponding route in the Routing Information Base.

## Message Transmission  {#MsgXmit}

AODVv2 sends [](#RFC5444) formatted messages using the parameters for port number and IP protocol specified in [](#RFC5498).
Mapping of AODVv2 data to [](#RFC5444) messages is detailed in [](#represent). AODVv2 multicast
messages are sent to the link-local multicast address LL-MANET-Routers [](#RFC5498). All AODVv2 routers MUST subscribe to
LL-MANET-Routers on all AODVv2 interfaces [](#RFC5498) to receive AODVv2 messages. Note that multicast messages MAY be sent via unicast. For example,
this may occur for certain link-types (non-broadcast media), for manually configured router adjacencies, or in order to
improve robustness.

When multiple interfaces are available, an AODVv2 router transmitting a multicast message to LL-MANET-Routers MUST send the
message on all interfaces that have been configured for AODVv2 operation, as given in the AODVv2_INTERFACES list ([](#interfaceslist)).

<!-- Implementations MAY choose to employ techniques to reduce the number of multicast messages sent. Use of [](#RFC6621) in deployments
is recommended. Employing [](#RFC6621) in a subset of the operational AODVv2 routers in a network, or configuring different algorithms
on different routers, will not cause interoperability issues, but will reduce the effectiveness of the multicast reduction scheme. -->

To avoid congestion, each AODVv2 router's rate of message generation SHOULD be limited (CONTROL_TRAFFIC_LIMIT) and administratively
configurable. To prioritize transmission of AODVv2 control messages in order to respect the CONTROL_TRAFFIC_LIMIT:

* Highest priority SHOULD be given to RREP_Ack messages. This allows links between routers to be confirmed as bidirectional and
  avoids undesirable blacklisting of next hop routers.
* Second priority SHOULD be given to RERR messages for undeliverable IP packets, so that broken routes that are still in use by other
  AODVv2 routers can be reported to those routers, to avoid IP data packets being repeatedly forwarded to AODVv2 routers which cannot
  forward them to their destination.
* Third priority SHOULD be given to RREP messages in order that RREQs do not time out.
* RREQ messages SHOULD be given priority over RERR messages for newly invalidated routes, since the invalidated routes may not still be
  in use, and if there is an attempt to use the route, a new RERR message will be generated.
* Lowest priority SHOULD be given to RERR messages generated in response to RREP messages which cannot be regenerated. In this case the
  route request will be retried at a later point.

<!-- Messages may travel a maximum of MAX_HOPCOUNT hops. -->

<!-- IP packets containing AODVv2 protocol messages SHOULD be given priority queuing and channel
access. -->

## Route Discovery, Retries and Buffering  {#route_discovery}

AODVv2's RREQ and RREP messages are used for route discovery. RREQ messages are multicast to solicit an RREP, whereas
RREP are unicast where possible. The constants used in this section are defined in [](#param).

When an AODVv2 router needs to forward an IP packet (with source address OrigAddr and destination address TargAddr) from
one of its Router Clients, it needs a route to TargAddr in its Routing Information Base. If no route exists,
the AODVv2 router generates (RREQ_Gen) and multicasts a Route Request message (RREQ), on all configured interfaces, containing OrigAddr and TargAddr. The procedure for this
is described in [](#RREQ_gen). Each generated RREQ results in an increment to the router's sequence number. The AODVv2 router generating an
RREQ is referred to as RREQ_Gen.

<!-- CEP: Issue # to be generated for moving DestOnly to the irrep draft...
    Optionally, RREQ_Gen MAY specify that only the router serving
    TargAddr is allowed to generate an RREP message, by including
    the DestOnly Data Element (see <xref target="RREQ_gen" />).
  -->

Buffering might be configured for IP packets awaiting a route for forwarding by RREQ_Gen, if sufficient memory is available. Buffering
of IP packets might have both positive and negative effects. Real-time traffic, voice, and scheduled delivery may suffer if packets are
buffered and subjected to delays, but TCP connection establishment will benefit if packets are queued while route discovery is performed [](#Koodli01).
If packets are not queued, no notification should be sent to the source. Determining which packets to discard first when the buffer is
full is a matter of policy at each AODVv2 router.

RREQ_Gen awaits reception of a Route Reply message (RREP) containing a route toward TargAddr. If a valid route to TargAddr is not learned
within RREQ_WAIT_TIME, RREQ_Gen will retry the route discovery. To reduce congestion in a network, repeated attempts at route discovery for
a particular target address utilize a binary exponential backoff: for each additional attempt, the time to wait for receipt of the RREP is
multiplied by 2. If the requested route is not learned within the wait period, another RREQ is sent, up to a total of DISCOVERY_ATTEMPTS_MAX.
This is the same technique used in AODV [](#RFC3561).

The RREQ is received by neighboring AODVv2 routers, and processed and regenerated as described in [](#RREQ_msgs). Routers
learn a potential route to OrigAddr (and other addresses as indicated by OrigPrefixLen) from the RREQ and store it in the Local Route Set.
The router responsible for TargAddr responds by generating a Route Reply message (RREP) and sends it back toward RREQ_Gen via the next hop
on the potential route to OrigAddr. Each intermediate router learns the route to TargAddr (and other addresses as indicated by TargPrefixLen),
regenerates the RREP and sends toward OrigAddr.

Through the use of bidirectional link monitoring and blacklists (see [](#nexthopmonitoring)) uni-directional links on initial selected route will be ignored on subsequent route discovery attempts.

Route discovery is considered to have failed after DISCOVERY_ATTEMPTS_MAX and the corresponding wait time for an RREP response to
the final RREQ. After the attempted route discovery has failed, RREQ_Gen waits at least RREQ_HOLDDOWN_TIME before attempting another route
discovery to the same destination, in order to avoid repeatedly generating control traffic that is unlikely to discover a route. Any IP
packets buffered for TargAddr are also dropped and a Destination Unreachable ICMP message (Type 3) with a code of 1 (Host Unreachable Error)
is delivered to the source of the packet, so that the application knows about the failure.

If RREQ_Gen does receive a route message containing a route to TargAddr within the timeout, it processes the message according to
[](#aodv_msgs). When a valid LocalRoute entry is created in the Local Route Set, the route is also installed in the Routing Information Base, and
the router will begin sending the buffered IP packets. Any retry timers for the corresponding RREQ are then cancelled.

During route discovery, all routers on the path learn a route to both OrigAddr and TargAddr, so that routes are constructed in both directions.
The route is optimized for the forward route.

<!-- For RREQ, use incoming cost from previous hop, so that the return path will be the optimal for Orig->Targ. -->
<!-- Targ rtr doesnt learn the optimal path to OrigAddr, in fact learns wrong metric too -->

<!--
Routes to OrigAddr learned from an RREQ will reflect the route cost in the direction from OrigAddr toward
TargAddr, calculated at each receiving router. This might not be the correct cost for their route to OrigAddr.
The corresponding RREP contains this accumulated metric value. It is not changed at intermediate routers, so
RREQ_Gen and all intermediate routers install a route to TargAddr using this metric. At intermediate routers
this route does not correctly reflect the cost of their route to TargAddr.
-->

## Processing Received Route Information {#processingrte}

All AODVv2 route messages contain a route. A Route Request (RREQ) contains a route toward OrigAddr (and other addresses as indicated by OrigPrefixLen),
and a Route Reply (RREP) contains a route toward TargAddr (and other addresses as indicated by TargPrefixLen). All AODVv2 routers that receive a route
message are able to store the route contained within it in their Local Route Set. Incoming information is first checked to verify that it is both safe
to use and offers an improvement to existing information, as explained in [](#test). The Local Route Set MUST then be updated according to [](#update_rte).

In the processes below, RteMsg is used to denote the route message, AdvRte is used to denote the route contained within it, and LocalRoute
denotes an existing entry in the Local Route Set which matches AdvRte on address, prefix length, and metric type.

AdvRte has the following properties:

* AdvRte.Address := network address given by combining RteMsg.OrigAddr and RteMsg.OrigPrefixLen (in RREQ)
  or RteMsg.TargAddr and RteMsg.TargPrefixLen (in RREP)
* AdvRte.PrefixLength := RteMsg.OrigPrefixLen (in RREQ) or RteMsg.TargPrefixLen (in RREP). If no prefix length was
  included in RteMsg, prefix length is the address length, in bits, of RteMsg.OrigAddr (in RREQ) or RteMsg.TargAddr (in RREP)
* AdvRte.SeqNum := RteMsg.OrigSeqNum (in RREQ) or RteMsg.TargSeqNum (in RREP)
* AdvRte.NextHop := RteMsg.IPSourceAddress (an address of the sending interface of the router from which the RteMsg was received)
* AdvRte.MetricType := RteMsg.MetricType
* AdvRte.Metric := RteMsg.Metric
* AdvRte.Cost := Cost(R) using the cost function associated with the route's metric type,
  i.e. Cost(R) = AdvRte.Metric + Cost(L), as described in [](#metrics), where L is the link from the
  advertising router
* AdvRte.ValidityTime := RteMsg.ValidityTime, if included



### Evaluating Route Information  {#test}

An incoming advertised route (AdvRte) is compared to existing LocalRoutes to determine whether the advertised route is to be used to
update the AODVv2 Local Route Set. The incoming route information MUST be processed as follows:

1.  Search for LocalRoutes in the Local Route Set matching AdvRte's address, prefix length and metric type
    *   If no matching LocalRoute exists, AdvRte MUST be used to update the Local Route Set.
    *   If matching LocalRoutes are found, continue to Step 2.

1.  Compare sequence numbers using the technique described in [](#seqnum)
    *   If AdvRte is more recent than all matching LocalRoutes, AdvRte MUST be used to update the Local Route Set.
    *   If AdvRte is stale, AdvRte MUST NOT be used to update the Local Route Set.
    *   If the sequence numbers are equal, continue to Step 3.

1.  Check that AdvRte is safe against routing loops compared to all matching LocalRoutes (see [](#metrics))
    *   If LoopFree(AdvRte, LocalRoute) returns FALSE, AdvRte MUST NOT be used to update the Local Route Set
        because using the incoming information might cause a routing loop.
    *   If LoopFree(AdvRte, LocalRoute) returns TRUE, continue to Step 4.

1.  Compare route costs
    *   If AdvRte is better than all matching LocalRoutes, it SHOULD be used to update the Local Route Set because it offers improvement. If it
        is not used to update the Local Route Set, the existing non-optimal LocalRoute will continue to be used, causing
        data traffic to use a non-optimal route.
    *   If AdvRte is equal in cost and LocalRoute is valid, AdvRte SHOULD NOT be used to update the Local Route Set because it will offer no improvement.
    *   If AdvRte is worse and LocalRoute is valid, AdvRte MUST NOT be used to update the Local Route Set because it does not offer any improvement.
    *   If AdvRte is not better (i.e., it is worse or equal) but LocalRoute is Invalid, AdvRte SHOULD be used to update the Local Route Set because
        it can safely repair the existing Invalid LocalRoute.

If the advertised route is to be used to update the Local Route Set, the procedure in [](#update_rte) MUST be
followed. If not, non-optimal routes will remain in the Local Route Set.


### Applying Route Updates  {#update_rte}

After determining that AdvRte is to be used to update the Local Route Set (as described in [](#test)), the following procedure applies.

If AdvRte is learned from an RREQ message, the link to the next hop neighbor may not be confirmed as bidirectional (see [](#nbrlist)). The route will
offer improvement to the Local Route Set if the neighbor can be confirmed. If there is no existing matching route, AdvRte allows
a corresponding RREP to be sent. If a matching entry already exists, AdvRte offers potential improvement.

The route update is applied as follows:

1.  If no existing entry in the Local Route Set matches AdvRte's address, prefix length and metric type, continue to
    Step 4 and create a new entry in the Local Route Set.

1.  If two matching LocalRoutes exist in the Local Route Set, one is a valid route, and one is an Unconfirmed route. AdvRte may offer further
    improvement to the Unconfirmed route, or may offer an update to the valid route.

    * If AdvRte.NextHop's Neighbor.State is Unknown, the advertised route may offer improvement to the existing valid route, if the link to the
      next hop can be confirmed as bidirectional. Continue processing from Step 5 to update the existing Unconfirmed LocalRoute.
    * If AdvRte.NextHop's Neighbor.State is Confirmed, the advertised route offers an update or improvement to the existing valid route. Continue
      processing from Step 5 to update the existing valid LocalRoute.

1.  If only one matching LocalRoute exists in the Local Route Set:

    * If AdvRte.NextHop's Neighbor.State is Confirmed, continue processing from Step 5 to update the existing LocalRoute.
    * If AdvRte.NextHop's Neighbor.State is Unknown, AdvRte may offer improvement the existing LocalRoute, if the link to
      AdvRte.NextHop can be confirmed as bidirectional.
    * If LocalRoute.State is Unconfirmed, AdvRte is an improvement to an existing Unconfirmed route. Continue processing
      from Step 5 to update the existing LocalRoute.
    * If LocalRoute.State is Invalid, AdvRte can replace the existing LocalRoute. Continue processing from Step 5 to update
      the existing LocalRoute.
    * If LocalRoute.State is Active or Idle, AdvRte SHOULD be stored as an additional entry in the Local Route Set, with
      LocalRoute.State set to Unconfirmed. Continue processing from Step 4 to create a new LocalRoute.

1.  Create an entry in the Local Route Set and initialize as follows:

    *  LocalRoute.Address := AdvRte.Address
    *  LocalRoute.PrefixLength := AdvRte.PrefixLength
    *  LocalRoute.MetricType := AdvRte.MetricType

1.  Update the LocalRoute as follows:

    *  LocalRoute.SeqNum := AdvRte.SeqNum
    *  LocalRoute.NextHop := AdvRte.NextHop
    *  LocalRoute.NextHopInterface := interface on which RteMsg was received
    *  LocalRoute.Metric := AdvRte.Cost
    *  LocalRoute.LastUsed := CurrentTime
    *  LocalRoute.LastSeqNumUpdate := CurrentTime
    *  LocalRoute.ExpirationTime := CurrentTime + AdvRte.ValidityTime if a validity time exists, otherwise INFINITY_TIME

1.  If a new LocalRoute was created, or if the existing LocalRoute.State is Invalid or Unconfirmed, update LocalRoute
    as follows:

    *  LocalRoute.State := Unconfirmed (if the next hop's Neighbor.State is Unknown)
    *  LocalRoute.State := Idle (if the next hop's Neighbor.State is Confirmed)

1.  If an existing LocalRoute.State changed from Invalid or Unconfirmed to become Idle, any matching Unconfirmed LocalRoute
    with worse metric value SHOULD be expunged.

1.  If an existing LocalRoute was updated with a better metric value, any matching Unconfirmed LocalRoute with worse metric
    value SHOULD be expunged.

1.  If this update results in LocalRoute.State of Active or Idle, which matches a route request which is still in progress,
    the associated route request retry timers SHOULD be cancelled.

If this update to the Local Route Set results in two LocalRoutes to the same address, the best LocalRoute will be
Unconfirmed. In order to improve the route used for forwarding, the router SHOULD try to determine if the link to the
next hop of that LocalRoute is bidirectional, by using that LocalRoute to forward future RREPs and request acknowledgements
(see [](#RREP_gen)).


## Suppressing Redundant Messages Using the Multicast Route Message Table  {#suppress}

When route messages are flooded in a MANET, an AODVv2 router may receive multiple similar
messages. Regenerating every one of these gives little additional benefit, and generates
unnecessary signaling traffic and might generate unnecessary interference.

Each AODVv2 router stores information about recently received route messages in the AODVv2
Multicast Route Message Table ([](#rtemsgtable)).

Multicast Route Message Table Entries consist of:

* RteMsg.MessageType := RREQ or RREP
* RteMsg.OrigAddr := OrigAddr from the message
* RteMsg.OrigPrefixLen := the prefix length associated with OrigAddr
* RteMsg.TargAddr := TargAddr from the message
* RteMsg.TargPrefixLen := the prefix length associated with TargAddr
* RteMsg.OrigSeqNum := the sequence number associated with OrigAddr, if present in the message
* RteMsg.TargSeqNum := the sequence number associated with TargAddr, if present in the message
* RteMsg.MetricType := the metric type of the route requested
* RteMsg.Metric := the metric value associated with OrigAddr in an RREQ or TargAddr in an RREP
* RteMsg.Timestamp := CurrentTime
* RteMsg.RemoveTime := CurrentTime + MAX_SEQNUM_LIFETIME

Entries in the Multicast Route Message Table SHOULD be maintained for at least RteMsg_ENTRY_TIME after
the last Timestamp update in order to account for long-lived RREQs traversing the network. An entry MUST
be deleted when the sequence number is no longer valid, i.e., after MAX_SEQNUM_LIFETIME. Memory-constrained
devices MAY remove the entry before this time.

Received route messages are tested against previously received route messages, and if determined to be
redundant, regeneration or response can be avoided.

To determine if a received message is redundant:

1.  Search for an entry in the Multicast Route Message Table with the same MessageType, OrigAddr, TargAddr, and
    MetricType
    *   If there is no entry, the message is not redundant.
    *   If there is an entry, continue to Step 2.
2.  Compare sequence numbers using the technique described in [](#seqnum)
    *   For RREQ messages, use OrigSeqNum of the entry for comparison. For RREP messages, use TargSeqNum of
        the entry for comparison.
    *   If the entry has an older sequence number than the received message, the message is not redundant.
    *   If the entry has a newer sequence number than the received message, the message is redundant.
    *   If the entry has the same sequence number, continue to Step 3.
3.  Compare the metric values
    *   If the entry has a Metric value that is worse than or equal to the metric in the received message,
        the message is redundant.
    *   If the entry has a Metric value that is better than the metric in the received message, the message
        is not redundant.

If the message is redundant, update the Timestamp and RemoveTime on the entry, since matching route messages are still
traversing the network and this entry should be maintained. This message MUST NOT be regenerated or
responded to.

If the message is not redundant, create an entry or update the existing entry.

To update a Multicast Route Message Table entry, set:

* RteMsg.OrigSeqNum := the sequence number associated with OrigAddr, if present in the received message
* RteMsg.TargSeqNum := the sequence number associated with TargAddr, if present in the received message
* RteMsg.Metric := the metric value associated with OrigAddr in a received RREQ or TargAddr in a received RREP
* RteMsg.Timestamp := CurrentTime
* RteMsg.RemoveTime := CurrentTime + MAX_SEQNUM_LIFETIME

Where the message is determined not redundant before Step 3, it MUST be regenerated or responded to. When a message is determined to be not redundant in Step 3, it MAY be suppressed to avoid extra control traffic. However, since the processing of the message will
result in an update to the Local Route Set, the message SHOULD be regenerated or responded to, to ensure other routers
have up-to-date information and the best metrics. If the message is not regenerated, the best route may not be found. Regeneration or response is to be performed using the processes outlined in [](#aodv_msgs).


## Local Route Set Maintenance  {#route_maint}

Route maintenance involves monitoring LocalRoutes in the Local Route Set, updating LocalRoute.State to handle route timeouts and
reporting routes that become Invalid.

### LocalRoute State Changes {#routestatechanges}

During normal operation, AODVv2 does not require any explicit timeouts to manage the lifetime of a route. At any time, any
LocalRoute MAY be examined and updated according to the rules below. If timers are not used to prompt updates of LocalRoute.State,
the LocalRoute.State MUST be checked before IP packet forwarding and before any operation based on LocalRoute.State.

Route timeout behaviour is as follows:

*  An Unconfirmed route MUST be expunged at MAX_SEQNUM_LIFETIME after LocalRoute.LastSeqNumUpdate.
*  An Idle route MUST become Active when used to forward an IP packet. If the route is not used to forward an IP packet within
   MAX_IDLETIME, LocalRoute.State MUST become Invalid.
*  An Active route which is a timed route (i.e., with LocalRoute.ExpirationTime not equal to INFINITY_TIME) remains Active until
   LocalRoute.ExpirationTime, after which it MUST become Invalid. If it it not a timed route, it MUST become Idle if the route is
   not used to forward an IP packet within ACTIVE_INTERVAL.
*  An Invalid route SHOULD remain in the Local Route Set, since LocalRoute.SeqNum is used to classify future information about LocalRoute.Address as
   stale or fresh.
*  In all cases, if the time since LocalRoute.LastSeqNumUpdate exceeds MAX_SEQNUM_LIFETIME, LocalRoute.SeqNum must be set to
   zero. This is required to ensure that any AODVv2 routers following the initialization procedure can safely begin routing
   functions using a new sequence number. A LocalRoute with
   LocalRoute.State set to Active or Idle can remain in the Local Route Set after removing the sequence number, but if LocalRoute.State
   is Invalid, or later becomes Invalid, the LocalRoute MUST be expunged from the Local Route Set.

LocalRoutes can become Invalid before a timeout occurs:

*  If an external mechanism reports a link as broken, all LocalRoutes using that link for LocalRoute.NextHop MUST immediately have LocalRoute.State set to Invalid.
*  If a Route Error (RERR) message containing the route is received, either from LocalRoute.NextHop, or with PktSource set
   to a Router Client address, LocalRoute.State MUST immediately be set to Invalid.

LocalRoutes are also updated when Neighbor.State is updated:

*  While the value of Neighbor.State is set to Unknown, any routes in the Local Route Set using that neighbor as a next hop MUST have
   LocalRoute.State set to Unconfirmed.
*  When the value of Neighbor.State is set to Confirmed, the Unconfirmed routes in the Local Route Set using that neighbor as a next hop MUST have
   LocalRoute.State set to Idle. Any other matching LocalRoutes with metric values worse than LocalRoute.Metric
   MUST be expunged from the Local Route Set.
*  When the value of Neighbor.State is set to Blacklisted, any valid routes in the Local Route Set using that neighbor for their next hop MUST have
   LocalRoute.State set to Invalid.
*  When a Neighbor Table entry is removed, all routes in the Local Route Set using that neighbor as next hop MUST have LocalRoute.State set to Invalid.

<!-- SUGGESTED NEW TEXT -->

Memory constrained devices MAY choose to expunge routes from the AODVv2 Local Route Set before LocalRoute.ExpirationTime, but
MUST adhere to the following rules:

*   An Active route MUST NOT be expunged, as it is in use. If deleted, IP traffic forwarded to this router will prompt generation
    of a Route Error message, and it will be necessary for a Route Request to be generated by the originator's router to re-establish the route.
*   An Idle route SHOULD NOT be expunged, as it is still valid for forwarding IP traffic. If deleted, this could result in dropped
    IP packets and a Route Request could be generated to re-establish the route.
*   Any Invalid route MAY be expunged. Least recently used Invalid routes SHOULD be expunged first, since the sequence number information
    is less likely to be useful.
*   An Unconfirmed route MUST NOT be expunged if it was installed within the last RREQ_WAIT_TIME, because it may correspond to
    a route discovery in progress. A Route Reply message might be received which needs to use the LocalRoute.NextHop information.
    Otherwise, it MAY be expunged.



### Reporting Invalid Routes {#brokenrerr}

When LocalRoute.State changes from Active to Invalid as a result of a broken link or a received Route Error
(RERR) message, other AODVv2 routers MUST be informed by sending an RERR message containing details
of the invalidated route.

An RERR message MUST also be sent when an AODVv2 router receives an IP packet to forward on behalf
of another router but does not have a valid route in its Routing Information Base for the destination of the packet.

An RERR message MUST also be sent when an AODVv2 router receives an RREP message to regenerate, but the
LocalRoute to the OrigAddr in the RREP has been lost or is marked as Invalid.

The packet or message triggering the RERR MUST be discarded.

Generation of an RERR message is described in [](#RERR_gen).



# AODVv2 Protocol Messages  {#aodv_msgs}

AODVv2 defines four message types: Route Request (RREQ), Route Reply (RREP), Route Reply
Acknowledgement (RREP_Ack), and Route Error (RERR).

Each AODVv2 message is defined as a set of data. Rules for the generation, reception and
regeneration of each message type are described in the following sections. [](#represent) discusses
how the data is mapped to [](#RFC5444) Message TLVs, Address Blocks, and Address TLVs.


## Route Request (RREQ) Message  {#RREQ_msgs}

Route Request messages are used in route discovery operations to request a route to a specified
target address.  RREQ messages have the following contents:

    +-----------------------------------------------------------------+
    |                           AddressList                           |
    +-----------------------------------------------------------------+
    |                   PrefixLengthList (optional)                   |
    +-----------------------------------------------------------------+
    |                OrigSeqNum, (optional) TargSeqNum                |
    +-----------------------------------------------------------------+
    |                           MetricType                            |
    +-----------------------------------------------------------------+
    |                           OrigMetric                            |
    +-----------------------------------------------------------------+
    |                     ValidityTime (optional)                     |
    +-----------------------------------------------------------------+
^[RREQ_elem::RREQ message contents]

AddressList
:   <vspace/>Contains OrigAddr and TargAddr, the source and destination addresses
    of the IP packet for which a route is requested. OrigAddr and TargAddr MUST be routable
    unicast addresses.
PrefixLengthList
:   <vspace/>Contains OrigPrefixLen, i.e., the length, in bits, of the prefix associated with
    the Router Client entry which includes OrigAddr. If omitted, the prefix length is equal
    to OrigAddr's address length in bits.
OrigSeqNum
:   <vspace/>The sequence number associated with OrigAddr.
TargSeqNum
:   <vspace/>A sequence number associated with an existing Invalid route to TargAddr. This MAY be included
    if available, and is useful for the optional Intermediate RREP feature (see [](#iRREP)).
MetricType
:   <vspace/>The metric type associated with OrigMetric.
OrigMetric
:   <vspace/>The metric value associated with the LocalRoute to OrigAddr (and to any other addresses included in the
    given prefix length), as seen from the sender of the message.
ValidityTime
:   <vspace/>The length of time that the message sender is willing to offer a route
    toward OrigAddr (and any other addresses included in the given prefix length). Omitted if no time limit is imposed.

### RREQ Generation  {#RREQ_gen}

An RREQ is generated when an IP packet needs to be forwarded for a Router Client, and no valid route
currently exists for the packet's destination in the Routing Information Base.

Before creating an RREQ, the router SHOULD check the Multicast Route Message Table to see if an RREQ has recently been sent for the requested
destination. If so, and the wait time for a reply has not yet been reached, the router SHOULD
continue to await a response without generating a new RREQ. If the timeout has been reached, a new
RREQ MAY be generated. If buffering is configured, incoming IP packets awaiting this route SHOULD be buffered until the
route discovery is completed.

If the limit for the rate of AODVv2 control message generation has been reached, no message SHOULD be
generated. If approaching the limit, the message should be sent if the priorities in [](#MsgXmit) allow it.

To generate the RREQ, the router (referred to as RREQ_Gen) follows this procedure:

1.  Set AddressList := {OrigAddr, TargAddr}
1.  For the PrefixLengthList:
    *  If OrigAddr is part of an address range configured as a Router Client, set PrefixLengthList :=
       {RouterClient.PrefixLength, null}. This allows receiving routers to learn a route to all the
       addresses included by the prefix length, not only to OrigAddr.
    *  Otherwise, omit PrefixLengthList.
1.  For OrigSeqNum:
    *  Increment the router SeqNum as specified in [](#seqnum).
    *  Set OrigSeqNum := SeqNum.
1.  For TargSeqNum:
    *  If an Invalid route exists in the Local Route Set matching TargAddr using longest prefix matching and has a
       valid sequence number, set TargSeqNum := LocalRoute.SeqNum.
    *  If no Invalid route exists in the Local Route Set matching TargAddr, or the route doesn't have a sequence number,
       omit TargSeqNum.
1.  Include MetricType and set the type accordingly
1.  Set OrigMetric := RouterClient.Cost for the Router Client entry which includes OrigAddr
1.  Include ValidityTime if advertising that the route to OrigAddr (and any other addresses included in the given
    prefix length) via this router is offered for a limited time, and set ValidityTime accordingly

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)) which
is multicast, by default, to LL-MANET-Routers on all interfaces configured for AODVv2 operation.

<!-- CEP: Issue # to be generated for moving DestOnly to the irrep draft...
  <t>If RREQ_Gen requires that only the router providing connectivity
     to TargAddr is allowed to generate an RREP, then RREQ_Gen includes
     the "Destination RREP Only" (DestOnly) TLV as part of the RFC 5444
     message header.  This also assures that RREP_Gen increments its
     sequence number.  Otherwise, (if the optional behavior is enabled)
     other AODVv2 routers MAY respond to the RREQ if they have a
     valid route to TargAddr (see <xref target="iRREP" />). </t>
  -->

### RREQ Reception  {#RREQ_rcv}

Upon receiving a Route Request, an AODVv2 router performs the following steps:

1.  Update the Neighbor Table according to [](#nbrupdate)
    *  If the sender has Neighbor.State set to Blacklisted after the update, ignore this RREQ for further processing.
1.  Verify that the message contains the required data: OrigAddr,
    TargAddr, OrigSeqNum, and OrigMetric, and that OrigAddr and TargAddr are
    valid addresses (routable and unicast)
    *  If not, ignore this RREQ for further processing.
1.  Check that the MetricType is supported and configured for use
    *  If not, ignore this RREQ for further processing.
1.  Verify that the cost of the advertised route will not exceed the maximum allowed metric
    value for the metric type (Metric \<= MAX_METRIC[MetricType] - Cost(L))
    *  If it will, ignore this RREQ for further processing.
1.  Process the route to OrigAddr (and any other addresses included in the given
    prefix length) as specified in [](#processingrte)
1.  Check if the information in the message is redundant by comparing to entries in the Multicast Route Message
    table, following the procedure in [](#suppress)
    *  If redundant, ignore this RREQ for further processing.
    *  If not redundant, continue processing.
1.  Check if the TargAddr belongs to one of the Router Clients
    *  If so, generate an RREP as specified in [](#RREP_gen).
    *  If not, continue to RREQ regeneration.


### RREQ Regeneration  {#RREQ_regen}
By regenerating an RREQ, a router advertises that it will forward IP packets to the OrigAddr contained in the RREQ (and
to other addresses included in the given prefix length) according to the information enclosed. The router MAY choose not to
regenerate the RREQ, for example if the router is heavily loaded or low on energy and therefore unwilling to advertise
routing capability for more traffic. This could, however, decrease connectivity in the network or result in non-optimal paths.

The RREQ SHOULD NOT be regenerated if the limit for the rate of AODVv2 control message generation has been reached. If
approaching the limit, the message should be sent if the priorities in [](#MsgXmit) allow it.

The procedure for RREQ regeneration is as follows:

1.  Set AddressList, PrefixLengthList, sequence numbers and MetricType to the values in the
    received RREQ
1.  Set OrigMetric := LocalRoute[OrigAddr].Metric
1.  If the received RREQ contains a ValidityTime, or if the regenerating router wishes to
    limit the time that it offers a route to OrigAddr (and any other addresses included in the
    given prefix length), the regenerated RREQ MUST include ValidityTime
    *  The ValidityTime is either the time limit the previous AODVv2 router
       specified, or the time limit this router wishes to impose, whichever is lower.

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent))
which is multicast, by default, to LL-MANET-Routers on all interfaces configured for AODVv2
operation. However, the regenerated RREQ can be unicast to the next hop address of the LocalRoute
toward TargAddr, if known.


## Route Reply (RREP) Message  {#RREP_msgs}

When a Route Request message is received, requesting a route to a target address (TargAddr) which is configured as part of a
Router Client entry, a Route Reply message is sent in response. The RREP offers a route to TargAddr (and any other addresses
included in the prefix length).

RREP messages have the following contents:

    +-----------------------------------------------------------------+
    |                        AckReq (optional)                        |
    +-----------------------------------------------------------------+
    |                           AddressList                           |
    +-----------------------------------------------------------------+
    |                   PrefixLengthList (optional)                   |
    +-----------------------------------------------------------------+
    |                           TargSeqNum                            |
    +-----------------------------------------------------------------+
    |                           MetricType                            |
    +-----------------------------------------------------------------+
    |                           TargMetric                            |
    +-----------------------------------------------------------------+
    |                     ValidityTime (optional)                     |
    +-----------------------------------------------------------------+
^[figRREP::RREP message contents]

AckReq
:   <vspace/>The address of the intended next hop of the RREP. This is included when the
    link to the next hop toward OrigAddr is not known to be bidirectional. It indicates that an
    acknowledgement of the RREP is requested by the sender from the intended next hop (see [](#nexthopmonitoring)).
AddressList
:   <vspace/>Contains OrigAddr and TargAddr, the source and destination addresses
    of the IP packet for which a route is requested. OrigAddr and TargAddr MUST be routable
    unicast addresses.
PrefixLengthList
:   <vspace/>Contains TargPrefixLen, i.e., the length, in bits, of the prefix associated with
    the Router Client entry which includes TargAddr. If omitted, the prefix length is equal
    to TargAddr's address length, in bits.
TargSeqNum
:   <vspace/>The sequence number associated with TargAddr.
MetricType
:   <vspace/>The metric type associated with TargMetric.
TargMetric
:   <vspace/>The metric value associated with the LocalRoute to TargAddr (and any other addresses included in the
    given prefix length), as seen from the sender of the message.
ValidityTime
:   <vspace/>The length of time that the message sender is willing to offer a route
    toward TargAddr (and any other addresses included in the
    given prefix length). Omitted if no time limit is imposed.


### RREP Generation  {#RREP_gen}

A Route Reply message is generated when a Route Request for 
a Router Client of the AODVv2 router arrives. This is the case when
RteMsg.TargAddr matches an address which is configured as a Router
Client of the AODVv2 router.

Before creating an RREP, the router SHOULD check if the corresponding RREQ is redundant, i.e.,
a Route Reply has already been generated in response to the RREQ, or if the limit for the rate of AODVv2 control message
generation has been reached. If so, the RREP SHOULD NOT be created. If approaching the limit,
the message should be sent if the priorities in [](#MsgXmit) allow it.

The RREP will follow the path of the route to OrigAddr. If the best route to OrigAddr in the Local
Route Set is Unconfirmed, the link to the next hop neighbor is not yet confirmed as bidirectional (as described
in [](#nexthopmonitoring)). In this case the RREP MUST include AckReq set to the intended
next hop address. The AckReq indicates that an acknowledgement to the RREP is requested from the
intended next hop router in the form of a Route Reply Acknowledgement (RREP_Ack). If the best route to OrigAddr
in the Local Route Set is valid, the link to the next hop neighbor is already confirmed as bidirectional, and
the AckReq can be omitted.

Implementations MAY allow a number of retries of the RREP if a requested acknowledgement is not received within
RREP_Ack_SENT_TIMEOUT, doubling the timeout with each retry, up to a maximum of RREP_RETRIES, using
the same exponential backoff described in [](#route_discovery) for RREQ retries. The acknowledgement
MUST be considered to have failed after the wait time for an RREP_Ack response to the final RREP.

To generate the RREP, the router (also referred to as RREP_Gen) follows this procedure:

1.  If the link to the next hop router toward OrigAddr is not known to be bidirectional, include the
    AckReq with the address of the intended next hop router
1.  Set Address List := {OrigAddr, TargAddr}
1.  For the PrefixLengthList:
    *  If TargAddr is part of an address range configured as a Router Client, set PrefixLengthList :=
       {null, RouterClient.PrefixLength}. This allows receiving routers to learn a route to
       all the addresses included by the prefix length, not only to TargAddr.
    *  Otherwise, omit PrefixLengthList.
1.  For the TargSeqNum:
    *  Increment the router SeqNum as specified in [](#seqnum).
    *  Set TargSeqNum := SeqNum.
1.  Include MetricType and set the type to match the MetricType in the received RREQ message
1.  Set TargMetric := RouterClient.Cost for the Router Client entry which includes TargAddr
1.  Include ValidityTime if advertising that the route to TargAddr (and any other addresses included in the
    given prefix length) via this router is offered for a limited time, and set ValidityTime accordingly

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)). If the Neighbor Table
contains an entry for the neighbor stored as LocalRoute[OrigAddr].NextHop, with Neighbor.State set to Confirmed, the RREP is
sent by unicast to LocalRoute[OrigAddr].NextHop. Otherwise, the RREP is sent multicast to LL-MANET-Routers.


### RREP Reception  {#RREP_rcv}

Upon receiving a Route Reply, an AODVv2 router performs the following steps:

1.  Verify that the message contains the required data: OrigAddr,
    TargAddr, TargSeqNum, and TargMetric, and that OrigAddr and TargAddr are
    valid addresses (routable and unicast)
    *  If not, ignore this RREP for further processing.
1.  Check that the MetricType is supported and configured for use
    *  If not, ignore this RREP for further processing.
1.  If this RREP does not correspond to a RREQ generated or regenerated in the last RREQ_WAIT_TIME, ignore for further processing.
1.  Update the Neighbor Table according to [](#nbrupdate)
<!--    *  If the sender has Neighbor.State set to Blacklisted after the update, ignore this RREP for further processing. -->
1.  Verify that the cost of the advertised route does not exceed the maximum allowed metric
    value for the metric type (Metric \<= MAX_METRIC[MetricType] - Cost(L))
    *  If it does, ignore this RREP for further processing.
1.  If the AckReq is present, check the intended recipient of the received RREP
    *  If the receiving router is the intended recipient, send an acknowledgement as specified
       in [](#rrep_ack_msgs) and continue processing.
    *  If the receiving router is not the intended recipient, ignore this RREP for
       further processing.
1.  Process the route to TargAddr (and any other addresses included in the
    given prefix length) as specified in [](#processingrte)
1.  Check if the message is redundant by comparing to entries in the Multicast Route Message table ([](#suppress))
    *  If redundant, ignore this RREP for further processing.
    *  If not redundant, save the information in the Multicast Route Message table to identify future redundant
       RREP messages and continue processing.
1.  Check if the OrigAddr belongs to one of the Router Clients
    *  If so, no further processing is necessary.
    *  If not, continue to Step 10.
1.  Check if a valid (Active or Idle) or Unconfirmed LocalRoute exists to OrigAddr
    *  If so, continue to RREP regeneration.
    *  If not, a Route Error message SHOULD be transmitted to TargAddr according to
       [](#RERR_gen) and the RREP SHOULD be discarded and not regenerated.


### RREP Regeneration  {#RREP_regen}

A received Route Reply message is regenerated toward OrigAddr. Unless the router is prepared to
advertise the route contained within the received RREP, it halts processing. By regenerating a
RREP, a router advertises that it will forward IP packets to TargAddr (and any other addresses
included in the given prefix length) according to the information enclosed. The router MAY choose
not to regenerate the RREP, in the same way it MAY choose not to regenerate an RREQ (see [](#RREQ_regen)),
though this could decrease connectivity in the network or result in non-optimal paths.

The RREP SHOULD NOT be regenerated if the limit for the rate of AODVv2 control message generation
has been reached. If approaching the limit, the message should be sent if the priorities in [](#MsgXmit) allow it.

The procedure for RREP regeneration is as follows:

1.  If the link to the next hop router toward OrigAddr is not known to be bidirectional, include the
    AckReq with the address of the intended next hop router
1.  Set AddressList, PrefixLengthList, TargSeqNum and MetricType to the values in the
    received RREP
1.  Set TargMetric := LocalRoute[TargAddr].Metric
1.  If the received RREP contains a ValidityTime, or if the regenerating router wishes to
    limit the time that it will offer a route to TargAddr (and any other addresses included in the
    given prefix length), the regenerated RREP MUST include ValidityTime
    *  The ValidityTime is either the time limit the previous AODVv2 router
       specified, or the time limit this router wishes to impose, whichever is lower.

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)). If the Neighbor Table
contains an entry for the neighbor stored as LocalRoute[OrigAddr].NextHop, with Neighbor.State set to Confirmed, the RREP is
sent by unicast to LocalRoute[OrigAddr].NextHop. Otherwise, the RREP is sent multicast to LL-MANET-Routers.


## Route Reply Acknowledgement (RREP_Ack) Message  {#rrep_ack_msgs}

The Route Reply Acknowledgement is a response to a Route Reply message. When the RREP_Ack message is received by the
sender of the RREP, it confirms that the link between the two routers is bidirectional (see [](#nexthopmonitoring)).
The RREP_Ack has no further data.


<!-- TargSeqNum
     <vspace/> TargSeqNum as seen in the RREP, to allow matching with the RREP at the router
     requesting the acknowledgement. -->


### RREP_Ack Generation  {#RREP_Ack_gen}

An RREP_Ack MUST be generated if a received Route Reply includes an AckReq with an address matching
one of the receiving router's IP addresses. The RREP_Ack SHOULD NOT be generated if the limit for the rate of AODVv2
control message generation has been reached.

There is no further data in an RREP_Ack. The [](#RFC5444) representation is discussed in [](#represent).
The RREP_Ack is unicast, by default, to the source IP address of the RREP message that requested it.

<!-- Include the SeqNum := TargAddr's SeqNum from the RREP.  -->

### RREP_Ack Reception  {#RREP_Ack_rcv}

Upon receiving an RREP_Ack, an AODVv2 router performs the following steps:

1.   Check if the RREP_Ack was expected from the IP source address of the RREP_Ack, in response to an RREP sent previously by this router
     * If it was expected, the router cancels any associated timeouts and processing continues to Step 2.
     * If it was not expected, no actions are required and processing ends.
1.   Update the Neighbor Table according to [](#nbrupdate)

<!-- CEP: Need to define RREP_Ack_timeout.  To avoid handling extra
     timeouts, should specify that the RREP_Ack_timeout is verified prior
     to sending forwarding RREQs from that neighbor.
     Actually, it would make sense to put the neighbor in the blacklist
     immediately upon sending AckReq...  -->

## Route Error (RERR) Message  {#RERR_msgs}

A Route Error message is generated by an AODVv2 router to notify other AODVv2 routers of routes that
are no longer available. An RERR message has the following contents:

    +-----------------------------------------------------------------+
    |                       PktSource (optional)                      |
    +-----------------------------------------------------------------+
    |                           AddressList                           |
    +-----------------------------------------------------------------+
    |                   PrefixLengthList (optional)                   |
    +-----------------------------------------------------------------+
    |                       SeqNumList (optional)                     |
    +-----------------------------------------------------------------+
    |                          MetricTypeList                         |
    +-----------------------------------------------------------------+
^[figRERRstruct::RERR message contents]

PktSource
:   <vspace/>The source address of the IP packet triggering the RERR. If the RERR is
    triggered by a broken link, PktSource is not required.
AddressList
:   <vspace/>The addresses of the routes not available through RERR_Gen.
PrefixLengthList
:   <vspace/>The prefix lengths, in bits, associated with the routes not available through
    RERR_Gen. These values indicate whether routes represent a single device or an address range.
SeqNumList
:   <vspace/>The sequence numbers of the routes not available through RERR_Gen (where
    known).
MetricTypeList
:   <vspace/>The metric types associated with the routes not available through
    RERR_Gen.


### RERR Generation  {#RERR_gen}

A Route Error message is generated when an AODVv2 router (also referred to as RERR_Gen) needs to report that a
destination is not reachable. There are three events that cause this response:

*   When an IP packet that has been forwarded from another router, but cannot be forwarded further because there is no valid route in the
    Routing Information Base for its destination, the source of the packet needs to be informed that the route to the destination of
    the packet does not exist. The RERR generated MUST include PktSource set to the source address of the IP packet,
    and MUST contain only one unreachable address in the AddressList, i.e., the destination address of the IP packet. RERR_Gen MUST discard the
    IP packet that triggered generation of the RERR. The prefix length, sequence number and metric type SHOULD be included if known from an existing Invalid LocalRoute to the unreachable address.

*   When an RREP message cannot be regenerated because the LocalRoute to OrigAddr has been lost or is Invalid, RREP_Gen needs
    to be informed that the route to OrigAddr does not exist. The RERR generated MUST include PktSource set to
    the TargAddr of the RREP, and MUST contain only one unreachable address in the AddressList, the OrigAddr from
    the RREP. RERR_Gen MUST discard the RREP message that triggered generation of the RERR. The prefix length, sequence number
    and metric type SHOULD be included if known from an Invalid LocalRoute to the unreachable address.

*   When a link breaks, multiple LocalRoutes may become Invalid, and the RERR generated MAY contain multiple unreachable
    addresses. The RERR MUST include MetricTypeList. PktSource is omitted. All previously
    Active LocalRoutes that used the broken link MUST be reported. The AddressList, PrefixLengthList, SeqNumList, and MetricTypeList
    will contain entries for each LocalRoute which has become Invalid. An RERR message is only sent if an Active LocalRoute
    becomes Invalid, though an AODVv2 router can also include Idle LocalRoutes that become Invalid if the configuration parameter
    ENABLE_IDLE_IN_RERR is set (see [](#other)).

    <!-- CEP: To reconsider if we re-specify local repair.. -->

In order to avoid flooding the network with RERR messages when a stream of IP packets to an unreachable address arrives, an AODVv2
router SHOULD determine whether an RERR has recently been sent with the same unreachable address and PktSource, and SHOULD avoid
creating duplicate RERR messages.

The RERR SHOULD NOT be generated if the limit for the rate of AODVv2 control message generation
has been reached. If approaching the limit, the message should be sent if the priorities in [](#MsgXmit) allow it.

Incidentally, if an AODVv2 router receives an ICMP error packet to or from the address of one of
its Router Clients, it forwards the ICMP packet in the same way as any other IP packet,
and will not generate any RERR message based on the contents of the ICMP packet.

To generate the RERR, the router follows this procedure:

1.  If necessary, include PktSource and set the value as given above
1.  For each LocalRoute that needs to be reported:
    *  Insert LocalRoute.Address into the AddressList.
    *  Insert LocalRoute.PrefixLength into PrefixLengthList, if known and not equal to the address
       length.
    *  Insert LocalRoute.SeqNum into SeqNumList, if known.
    *  Insert LocalRoute.MetricType into MetricTypeList.

The AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)).

If the RERR is sent in response to an undeliverable IP packet or RREP message, i.e., if PktSource is included, the RERR SHOULD be
sent unicast to the next hop on the route to PktSource, or alternatively, if there is no route to PktSource, the RERR MUST be
multicast to LL-MANET-Routers. If the RERR is sent in response to a broken link, i.e., PktSource is not included, the RERR is,
by default, multicast to LL-MANET-Routers.

[](#precursor) describes processing steps when the optional precursor lists feature is enabled.

<!-- NOTE:  CEP:  Verify unicast delivery of IP multicast packets ... -->
<!--
    If the neighbor's IP address is
    unavailable, RERR_Gen MAY attempt layer-2 unicast delivery
    to the multicast address LL-MANET-Routers.
  -->

### RERR Reception  {#RERR_rcv}

Upon receiving a Route Error, an AODVv2 router performs the following steps:

<!-- 1.  Update the Neighbor Table according to [](#nbrupdate) -->
<!-- If the sender is blacklisted ([](#nbrlist)), check the entry's remove time
    *  If CurrentTime \< Remove Time, ignore this RERR for further processing.
    *  If CurrentTime >= Remove Time, reset the neighbor state to Unknown and continue to Step 2. -->
1.  Verify that the message contains the required data: at least one
    unreachable address
    *  If not, ignore this RERR for further processing.
1.  For each address in the AddressList, check that:
    *  The address is valid (routable and unicast)
    *  The MetricType is supported and configured for use
    *  There is a LocalRoute with the same MetricType matching the address using
       longest prefix matching
    *  Either the LocalRoute's next hop is the sender of the RERR and the next hop interface is
       the interface on which the RERR was received, or PktSource is present in the RERR
       and is a Router Client address
    *  The unreachable address' sequence number is either unknown, or is greater than the
       LocalRoute's sequence number

    If any of the above are false, a matching LocalRoute MUST NOT be made Invalid and the
    unreachable address MUST NOT be advertised in a regenerated RERR.

    If all of the above are true, the LocalRoute is no longer valid. If the LocalRoute was
    previously Active, it MUST be reported in a regenerated RERR. If the LocalRoute was
    previously Idle, it MAY be reported in a regenerated RERR, if ENABLE_IDLE_IN_RERR is
    configured. The Local Route Set MUST be updated according to these rules:
    *  If the LocalRoute's prefix length is the same as the unreachable address' prefix length,
       set LocalRoute.State to Invalid.
    *  If the LocalRoute's prefix length is longer than the unreachable address' prefix length,
       the LocalRoute MUST be expunged from the Local Route Set, since it is a sub-route of the
       route which is reported to be Invalid.
    *  If the prefix length is different, create a new LocalRoute with the unreachable address,
       and its prefix length and sequence number, and set LocalRoute.State to Invalid.
    *  Update the sequence number on the existing LocalRoute, if the reported sequence number is
       determined to be newer using the comparison technique described in [](#seqnum).

1.  If there are previously Active LocalRoutes that MUST be reported, as identified in step 2.:
    *  Regenerate the RERR as detailed in [](#RERR_regen).

### RERR Regeneration  {#RERR_regen}

The Route Error message SHOULD NOT be regenerated if the limit for the rate of AODVv2 control message generation
has been reached. If approaching the limit, the message should be sent if the priorities in [](#MsgXmit) allow it.

The procedure for RERR regeneration is as follows:

1.  If PktSource was included in the original RERR, and PktSource is not a Router Client, copy it into the
    regenerated RERR
1.  For each LocalRoute that needs to be reported as identified in [](#RERR_gen):
    *  Insert LocalRoute.Address into the AddressList.
    *  Insert LocalRoute.PrefixLength into PrefixLengthList, if known and not equal to the address
       length.
    *  Insert LocalRoute.SeqNum into SeqNumList, if known.
    *  Insert LocalRoute.MetricType into MetricTypeList.

The AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)). If the RERR contains
PktSource, the regenerated RERR SHOULD be sent unicast to the next hop on the LocalRoute to PktSource,
or alternatively if there is no route to PktSource, or PktSource is a Router Client, it MUST be multicast to LL-MANET-Routers.
If the RERR is sent in response to a broken link, the RERR is, by default, multicast to LL-MANET-Routers.



# RFC 5444 Representation  {#represent}

AODVv2 specifies that all control messages between routers MUST use the Generalized
Mobile Ad Hoc Network Packet/Message Format [](#RFC5444), and therefore AODVv2's route messages
comprise data which is mapped to message elements in [](#RFC5444).

[](#RFC5444) provides a multiplexed transport for multiple protocols. An [](#RFC5444) multiplexer MAY
choose to optimize the content of certain message elements to reduce control message overhead.

A brief summary of the [](#RFC5444) format:

1.   A packet contains zero or more messages
1.   A message contains a Message Header, one Message TLV Block, zero or more Address Blocks,
     and one Address Block TLV Block per Address Block
1.   The Message TLV Block MAY contain zero or more Message TLVs
1.   An Address Block TLV Block MAY include zero or more Address Block TLVs
1.   Each TLV value in an Address Block TLV Block can be associated with all of the
     addresses, or with a contiguous set of addresses, or with a single address in the Address Block

AODVv2 does not require access to the [](#RFC5444) packet header.

In the message header, AODVv2 uses \<msg-type\> and
\<msg-addr-length\>. The \<msg-addr-length\> field indicates the length of any addresses in the message,
using \<msg-addr-length\> := (address length in octets - 1), i.e. 3 for IPv4 and 15 for IPv6.

The addresses in an Address Block MAY appear in any order, and values in a TLV in the Address Block
TLV Block must be associated with the correct address in the Address Block by the [](#RFC5444) implementation.
To indicate which value is associated with each address, the AODVv2 message representation uses lists where
the order of the addresses in the AODVv2 AddressList matches the order of values in other data lists, e.g., the
order of SeqNums in the SeqNumList in an RERR. [](#RFC5444) maps this information to Address Block TLVs associated
with the relevant addresses in the Address Block.

Each address included in the Address Block is identified as OrigAddr, TargAddr, PktSource, or
Unreachable Address by including an ADDRESS_TYPE TLV in the Address Block TLV Block.

The following sections show how AODVv2 data is represented in [](#RFC5444) messages. AODVv2
makes use of the VALIDITY_TIME Address Block TLV from [](#RFC5497), and defines (in [](#IANA)) a number of new TLVs.
To calculate the time-value for the VALIDITY_TIME Address Block TLV, the value of C is defined in [](#constants).

<!-- Deleted / Issue #28 - - >
  <t> When multiple messages are aggregated into a single packet according
      to RFC 5444 formatting, and the aggregation of messages is also
      authenticated (e.g., with IPsec), and the IP destination is multiple
      hops away, it becomes infeasible to delete individual messages.  In such
      cases, instead of deleting individual messages, they are maintained
      in the aggregation of messages, but simply ignored for further
      processing.  In such cases where individual messages cannot be
      deleted, in this document "disregarded" means "ignored".  Otherwise,
      any such "disregarded" AODVv2 messages SHOULD be deleted from
      the aggregated messages in the RFC 5444 packet.  </t>
< ! - - Deleted / Issue #28 -->

Where the extension type of a TLV is set to zero, this is the default [](#RFC5444) value and the extension type
will not be included in the message.


## Route Request Message Representation

### Message Header

Data           Header Field       Value
------------   ---------------    -----
None           \<msg-type\>       RREQ

### Message TLV Block

An RREQ contains no Message TLVs.

### Address Block
An RREQ contains two addresses, OrigAddr and TargAddr, and each address has an associated prefix length. If the prefix length
has not been included in the AODVv2 message, it is equal to the address length in bits.

Data                        Address Block
-------------               ---------------
OrigAddr\/OrigPrefixLen     \<address\> + \<prefix-length\>
TargAddr\/TargPrefixLen     \<address\> + \<prefix-length\>


### Address Block TLV Block
Address Block TLVs are always associated with one or more addresses in the Address Block. The following
sections show the TLVs that apply to each address.

#### Address Block TLVs for OrigAddr

Data                     TLV Type       Extension Type  Value
------------             ------------   --------------  -----
None                     ADDRESS_TYPE   0               ADDRTYPE_ORIGADDR
OrigSeqNum               SEQ_NUM        0               Sequence number of RREQ_Gen, the router which initiated route discovery.
OrigMetric \/MetricType  PATH_METRIC    MetricType      Metric value for the route to OrigAddr, using MetricType.
ValidityTime             VALIDITY_TIME  0               ValidityTime for route to OrigAddr, represented as detailed in [](#RFC5497).

#### Address Block TLVs for TargAddr

Data                     TLV Type       Extension Type  Value
------------             ------------   --------------  -----
None                     ADDRESS_TYPE   0               ADDRTYPE_TARGADDR
TargSeqNum               SEQ_NUM        0               The last known TargSeqNum for TargAddr.



## Route Reply Message Representation

### Message Header

Data            Header Field       Value
------------    ---------------    -----
None            \<msg-type\>       RREP

### Message TLV Block

An RREP contains no Message TLVs.

### Address Block

An RREP contains a minimum of two addresses, OrigAddr and TargAddr, and each address has an associated prefix length. If the prefix length
has not been included in the AODVv2 message, it is equal to the address length in bits.

It MAY also contain the address of the intended next hop, in order to request acknowledgement to confirm bidirectionality of the link, as described
in [](#nexthopmonitoring). The prefix length associated with this address is equal to the address length in bits.

Data                        Address Block
-------------               ---------------
OrigAddr\/OrigPrefixLen     \<address\> + \<prefix-length\>
TargAddr\/TargPrefixLen     \<address\> + \<prefix-length\>
AckReq                      \<address\> + \<prefix-length\>

### Address Block TLV Block
Address Block TLVs are always associated with one or more addresses in the Address Block. The following
sections show the TLVs that apply to each address.

#### Address Block TLVs for OrigAddr

Data                     TLV Type       Extension Type        Value
------------             ------------   --------------        -----
None                     ADDRESS_TYPE   0                     ADDRTYPE_ORIGADDR

#### Address Block TLVs for TargAddr

Data                      TLV Type       Extension Type         Value
------------              ------------   --------------         -----
None                      ADDRESS_TYPE   0                      ADDRTYPE_TARGADDR
TargSeqNum                SEQ_NUM        0                      Sequence number of RREP_Gen, the router which created the RREP.
TargMetric \/MetricType   PATH_METRIC    MetricType             Metric value for the route to TargAddr, using MetricType.
ValidityTime              VALIDITY_TIME  0                      ValidityTime for route to TargAddr, represented as detailed in [](#RFC5497).


#### Address Block TLVs for AckReq Intended Recipient Address

Data                     TLV Type       Extension Type        Value
------------             ------------   --------------        -----
None                     ADDRESS_TYPE   0                     ADDRTYPE_INTEND

## Route Reply Acknowledgement Message Representation

### Message Header

Data           Header Field       Value
------------   ---------------    -----
None           \<msg-type\>       RREP_Ack

### Message TLV Block

An RREP_Ack contains no Message TLVs.

### Address Block
An RREP_Ack contains no Address Block.

### Address Block TLV Block
An RREP_Ack contains no Address Block TLV Block.



## Route Error Message Representation

Route Error Messages MAY be split into multiple [](#RFC5444) messages when the desired contents would exceed the MTU. However,
all of the resulting messages MUST have the same message header as described
below. If PktSource is included in the AODVv2 message, it MUST be included in
all of the resulting [](#RFC5444) messages.

### Message Header

Data           Header Field       Value
------------   ---------------    -----
None           \<msg-type\>       RERR

### Message TLV Block
An RERR contains no Message TLVs.

### Address Block
The Address Block in an RERR MAY contain PktSource, the source address of the IP packet triggering
RERR generation, as detailed in [](#RERR_msgs). The prefix length associated with PktSource is equal to the
address length in bits.

Address Block always contains one address per route that is no longer valid, and each address
has an associated prefix length.  If a prefix length has not been included for this address, it is equal
to the address length in bits.

Data                            Address Block
------------                    ---------------
PktSource                       \<address\> + \<prefix-length\> for PktSource
AddressList\/PrefixLengthList   \<address\> + \<prefix-length\> for each unreachable address in AddressList


### Address Block TLV Block
Address Block TLVs are always associated with one or more addresses in the Address Block. The following
sections show the TLVs that apply to each type of address in the RERR.

#### Address Block TLVs for PktSource

Data           TLV Type      Extension Type Value
------------   --------      -------------- -----
PktSource      ADDRESS_TYPE  0              ADDRTYPE_PKTSOURCE

#### Address Block TLVs for Unreachable Addresses

Data                      TLV Type     Extension Type Value
------------              --------     -------------- -----
None                      ADDRESS_TYPE 0              ADDRTYPE_UNREACHABLE
SeqNumList                SEQ_NUM      0              Sequence number associated with invalid route to the unreachable address.
MetricTypeList            PATH_METRIC  MetricType     None. Extension Type set to MetricType of the route to the unreachable address.


# Simple External Network Attachment  {#gateway}

[](#net_top) shows a stub (i.e., non-transit) network of AODVv2 routers which is attached to
an external network via a single External Network Access Router (ENAR). The interface to the
external network MUST NOT be configured in the AODVv2_INTERFACES list.

As in any externally-attached network, AODVv2 routers and Router Clients that wish to be
reachable from the external network MUST have IP addresses within the ENAR's routable and
topologically correct prefix (i.e., 191.0.2.0/24 in [](#net_top)). This AODVv2 network and networks attached to routers within it will
be advertised to the external network using procedures which are out of scope for this specification.


      /-------------------------\
     / +----------------+        \
    /  |  AODVv2 Router |         \
    |  |  191.0.2.2/32  |         |
    |  +----------------+         |            Routable
    |                       +-----+--------+   Prefix
    |                       |     ENAR     |  /191.0.2.0/24
    |                       | AODVv2 Router| /
    |                       |  191.0.2.1   |/      /---------------\
    |                       | serving net  +------+    External     \
    |                       | 191.0.2.0/24 |      \     Network     /
    |                       +-----+--------+       \---------------/
    |         +----------------+  |
    |         |  AODVv2 Router |  |
    |         |  191.0.2.3/32  |  |
    \         +----------------+  /
     \                           /
      \-------------------------/
^[net_top::Simple External Network Attachment Example]

When an AODVv2 router within the AODVv2 MANET wants to discover a route toward an address on the
external network, it uses the normal AODVv2 route discovery for that IP Destination Address. The ENAR
MUST respond to RREQ on behalf of all external network destinations, i.e., destinations not on the
configured 191.0.2.0/24 network. RREQs for addresses inside the AODVv2 network, i.e. destinations
on the configured 191.0.2.0/24 network, are handled using the standard processes described
in [](#aodv_msgs).

When an IP packet from an address on the external network destined for an address in the AODVv2 MANET reaches the
ENAR, if the ENAR does not have a route toward that exact destination in its Routing Information Base, it will perform normal
AODVv2 route discovery for that destination.

Configuring the ENAR as a default router is outside the scope of this specification.


# Optional Features  {#optional}
A number of optional features for AODVv2, associated initially with AODV, MAY be useful in
networks with greater mobility or larger populations, or networks requiring reduced
latency for application launches. These features are not required by minimal implementations.

## Expanding Rings Multicast  {#rings}
For multicast RREQ, the [](#RFC5444) message may initially be limited to a low number of hops to limit the
RREQ propagation to a subset of the local network and possibly reduce route discovery overhead. If the route
is not discovered, the number of hops allowed for distribution of the RREQ is increased, in accordance with
an expanding ring search, as described in [](#RFC3561).


## Precursor Lists  {#precursor}
This section specifies an interoperable enhancement to AODVv2 enabling more economical Route Error
notifications.
<!-- Issue #22 -->

<!-- NOTE!  CEP: TODO:  Precursors should NOT be notified if
     Precursor.LastUsed < (MAX_IDLETIME + ACTIVE_INTERVAL)   -->
<!--
    , then for
    the IP.SourceAddress of the packet, Precursor[LastHop].LastUsed := CurrentTime.
    the packet is forwarded to the route's next hop.
  -->

There can be several sources of traffic for a certain destination.  Each source of traffic
and each upstream router between the forwarding AODVv2 router and the traffic source is known
as a "precursor" for the destination. For each destination, an AODVv2 router MAY choose to keep
track of precursors that have provided traffic for that destination. Route Error
messages about that destination can be sent unicast to these precursors instead of multicast to
all AODVv2 routers.

Since an RERR will be regenerated if it comes from a next hop on a valid LocalRoute, the RERR SHOULD ideally
be sent backwards along the route that the source of the traffic uses, to ensure it is regenerated
at each hop and reaches the traffic source. If the reverse path is unknown, the RERR SHOULD be sent
toward the source along some other route. Therefore, the options for saving precursor information are
as follows:

* Save the next hop on an existing route to the IP packet's source address as the precursor. In this case,
  it is not guaranteed that an RERR that is sent will follow the reverse of the source's route. In
  rare situations, this may prevent the route from being invalidated at the source of the data traffic.
* Save the IP packet's source address as the precursor. In this case, the RERR can be sent along any existing
  route to the source of the data traffic, and SHOULD include PktSource to ensure that the
  route will be invalidated at the source of the traffic, in case the RERR does not follow the reverse of
  the source's route.
* By inspecting the MAC address of each forwarded IP packet, determine which router forwarded the packet,
  and save the router address as a precursor. This ensures that when an RERR is sent to the precursor router,
  the route will be invalidated at that router, and the RERR will be regenerated toward the source
  of the IP packet.

During normal operation, each AODVv2 router maintaining precursor lists for a LocalRoute must update the
precursor list whenever it uses this route to forward traffic to the destination.  Precursors are
classified as Active if traffic has recently been forwarded by the precursor. The precursor is
marked with a timestamp to indicate the time it last forwarded traffic on this route.

When an AODVv2 router detects that one or more LocalRoutes are broken, it MAY notify each Active
precursor using a unicast Route Error message instead of creating multicast traffic. Unicast
is applicable when there are few Active precursors compared to the number of neighboring AODVv2
routers. However, the default multicast behavior is still preferable when there are many
precursors, since fewer message transmissions are required.

When an AODVv2 router supporting precursor lists receives an RERR message, it MAY identify the list
of its own affected Active precursors for the routes in the RERR, and choose to send a unicast RERR
to those, rather than send a multicast RERR.

When a LocalRoute is expunged, any precursor list associated with it MUST also be expunged.

<!-- ## Multicast RREP  {#mcast-to-RREQ}
An AODVv2 router creating a Route Reply (RREP) message MAY be configured to use multicast
to distribute the RREP. The RREP is created as described in [](#RREP_gen), but is multicast
to the link-local MANET routers address [](#RFC5498) in the same way as a Route Request. Routers
receiving the multicast RREP must perform RteMsg suppression (see [](#suppress)).

Multicast RREP was originally specified to handle unidirectional links, but it is
expensive.  Due to the significant overhead, AODVv2 routers MUST NOT use multicast RREP unless
configured to do so by setting the administrative parameter USE_MULTICAST_RREP.  This technique
can be used to find the best return path rather than follow the RREQ path in reverse.

-in optional feature settings-
USE_MULTICAST_RREP         Disabled    Network-wide ([](#mcast-to-RREQ))

-in suppressing redundant messages-
[](#mcast-to-RREQ) describes an optional feature for AODVv2 where RREP messages are sent using
multicast. If this feature is enabled, regeneration of redundant RREP messages SHOULD be
avoided using an analogous process, substituting RREP for RREQ, TargSeqNum for OrigSeqNum, and
[](#RREP_regen) for [](#RREQ_regen).

-->



## Intermediate RREP  {#iRREP}
Without iRREP, only the AODVv2 router responsible for the target address can respond to an RREQ. Using
iRREP, route discoveries can be faster and create less control traffic. This specification has been
published as a separate Internet Draft [](#I-D.perkins-irrep).

 <!-- CEP: issue #40 should be revisited!!  -->

## Message Aggregation Delay  {#aggreg}
The aggregation of multiple messages into a packet is specified in [](#RFC5444).

Implementations MAY choose to briefly delay transmission of messages for the purpose of
aggregation (into a single packet) or to improve performance by using jitter [](#RFC5148).



# Configuration  {#param}

AODVv2 uses various parameters which can be grouped into the following categories:

*  Timers
*  Protocol constants
*  Administrative parameters and controls

This section show the parameters along with their definitions and default values (if any).

Note that several fields have limited size (bits or bytes). These sizes and their encoding may
place specific limitations on the values that can be set.

## Timers  {#timers}

AODVv2 requires certain timing information to be associated with Local Route Set entries and
message replies. The default values are as follows:

Name                                   Default Value
------                                 ------------
ACTIVE_INTERVAL                        5 second
MAX_IDLETIME                           200 seconds
MAX_BLACKLIST_TIME                     200 seconds
MAX_SEQNUM_LIFETIME                    300 seconds
RteMsg_ENTRY_TIME                      12 seconds
RREQ_WAIT_TIME                         2 seconds
RREP_Ack_SENT_TIMEOUT                  1 second
RREQ_HOLDDOWN_TIME                     10 seconds

^[timer-tbl::Timing Parameter Values]

The above timing parameter values have worked well for small and medium well-connected
networks with moderate topology changes. The timing parameters SHOULD be administratively
configurable. Ideally, for networks with frequent topology changes the AODVv2 parameters
SHOULD be adjusted using experimentally determined values or dynamic adaptation. For example,
in networks with infrequent topology changes MAX_IDLETIME MAY be set to a much larger value.

If MAX_SEQNUM_LIFETIME was configured differently across the network, and any of the routers
lost their sequence number or rebooted, this could result in their next route messages being
classified as stale at any AODVv2 router using a greater value for MAX_SEQNUM_LIFETIME. This would
delay route discovery from and to the re-initializing router.

## Protocol Constants  {#constants}

AODVv2 protocol constants typically do not require changes. The following table lists these
constants, along with their values and a reference to the section describing their use.

Name                      Default   Description
---                       -------   ----------
DISCOVERY_ATTEMPTS_MAX    3         [](#route_discovery)
RREP_RETRIES              2         [](#RREP_gen)
MAX_METRIC[MetricType]    [TBD]     [](#metrics)
MAX_METRIC[HopCount]      255       [](#metrics) and [](#aodv_msgs)
INFINITY_TIME             [TBD]     Maximum expressible clock time ([](#update_rte))
C                         1/1024    Constant used in validity time calculation [](#RFC5497)

^[const-tbl::AODVv2 Constants]
<!-- MAX_HOPCOUNT             20        Limit to number of hops an AODVv2 message can traverse -->

<!-- Need to figure out what the time format. -->

<!-- Note that \<msg-hop-count\> is an 8-bit field in the [](#RFC5444) message header and therefore
MAX_HOPCOUNT cannot be larger than 255. -->

MAX_METRIC[MetricType] MUST always be the maximum expressible metric value of type MetricType.
Field lengths associated with metric values are found in [](#metric-type).

These protocol constants MUST have the same values for all AODVv2 routers in the ad hoc
network.  If the values were configured differently, the following consequences may be observed:

*  DISCOVERY_ATTEMPTS_MAX: Routers with higher values are likely to be more successful at finding
   routes, at the cost of additional control traffic.
*  RREP_RETRIES: Routers with lower values are more likely to blacklist neighbors when there is a
*  MAX_METRIC[MetricType]: No interoperability problems due to variations on different routers, but
   routers with lower values may exhibit overly restrictive behavior during route comparisons.
   temporary fluctuation in link quality.
<!-- *  MAX_HOPCOUNT: Routers with a value too small would not be able to discover routes to distant addresses. -->
*  INFINITY_TIME: No interoperability problems due to variations on different routers, but if a
   lower value is used, route state management may exhibit overly restrictive behavior.
*  C: Routers with lower values will invalidate timed routes before routers with higher values, which
   will cause Route Error messages to be generated and the route will effectively take on the shorter
   validity time.

## Local Settings {#other}
The following table lists AODVv2 parameters which SHOULD be administratively configured for each router:

Name                      Default Value             Description
---                       ------------              --------------
AODVv2_INTERFACES                                   [](#apply)
BUFFER_SIZE_PACKETS       2                         [](#route_discovery)
BUFFER_SIZE_BYTES         MAX_PACKET_SIZE [TBD]     [](#route_discovery)
CONTROL_TRAFFIC_LIMIT     [TBD - 50 pkts/sec?]      [](#aodv_msgs)

^[admincontrol::Configuration for Local Settings]

## Network-Wide Settings
The following administrative controls MAY be used to change the operation of the network. The same
settings SHOULD be used across the network. Inconsistent settings at different routers in the network
will not result in protocol errors, but poor performance may result.

Name                       Default               Description
------                     --------              ----------
ENABLE_IDLE_IN_RERR        Disabled              [](#RERR_gen)

^[suggestedoptions::Configuration for Network-Wide Settings]



## Optional Feature Settings

These options are not required for correct routing behavior, although they may reduce AODVv2
protocol overhead in certain situations. The default behavior is to leave these options disabled.

Name                       Default     Description
------                     --------    ----------
PRECURSOR_LISTS            Disabled    Local setting ([](#precursor))
MSG_AGGREGATION            Disabled    Local setting ([](#aggreg))
ENABLE_IRREP               Disabled    Network-wide setting ([](#iRREP))
EXPANDING_RINGS_MULTICAST  Disabled    Network-wide setting ([](#rings))

^[optionsettings:: Configuration for Optional Features]


## MetricType Allocation  {#metric-type}

The metric types used by AODVv2 are identified according to the assignments in [](#RFC6551).
All implementations MUST use these values.

Name of MetricType        Type                     Metric Value Size
--------------------      ------                   -------------
Unassigned                0                        Undefined
Hop Count                 3 [TBD]                  1 octet
Unallocated               9 - 254                  TBD
Reserved                  255                      Undefined

^[metric-tbl::AODVv2 Metric Types]


# IANA Considerations  {#IANA}

This section specifies several [](#RFC5444) message types and address tlv-types required
for AODVv2.

## RFC 5444 Message Types  {#msgtype}

This specification defines four Message Types, to be allocated from the 0-223 range of
the "Message Types" namespace defined in [](#RFC5444), as specified in [](#msgtypes).

Name of Message                        Type
------------------------               ------
Route Request (RREQ)                   10 (TBD)
Route Reply (RREP)                     11 (TBD)
Route Error (RERR)                     12 (TBD)
Route Reply Acknowledgement (RREP_Ack) 13 (TBD)

^[msgtypes::AODVv2 Message Types]


## RFC 5444 Address Block TLV Types  {#addrtlvspec}

This specification defines three Address Block TLV Types, to be allocated from the
"Address Block TLV Types" namespace defined in [](#RFC5444), as specified in [](#addrtlvtypes).

----------------------------------------------------------------------
Name of TLV                   Type      Length (octets) Reference
--------------------------    --------  ----------      --------------
PATH_METRIC                   11 (TBD)  depends on      [](#aodv_msgs)
                                        MetricType

SEQ_NUM                       12 (TBD)  2               [](#aodv_msgs)

ADDRESS_TYPE                  13 (TBD)  1               [](#represent)
----------------------------------------------------------------------
^[addrtlvtypes::AODVv2 Address Block TLV Types]

## ADDRESS_TYPE TLV Values {#address-type}

These values are used in the [](#RFC5444) Address Type TLV discussed in [](#represent).
All implementations MUST use these values.

Address Type            Value
------------            -----
ORIGADDR                0
TARGADDR                1
UNREACHABLE             2
PKTSOURCE               3
INTEND                  4
UNSPECIFIED             255

^[addrtype-tbl::AODVv2 Address Types]

# Security Considerations  {#Security}

<!-- security considerations revisions...

Protocol changes to support ICV:
- Should make a new type extension (TBD ?= 2?) for TIMESTAMP TLV
- RERR includes its SeqNum as the timestamp field value
- RREP_Ack includes TargSeqNum as the timestamp field value
- RERR receivers have to keep track of the neighbor's SeqNum
- RREP_Ack receivers have to keep track of which TargSeqNum was sent in
  the RREP

I picked these as the handiest strictly increasing values available for use.
Other designs are possible.
  -->

This section describes various security considerations and potential avenues to secure
AODVv2 routing. The objective of the AODVv2 protocol is for each router to communicate
reachability information about addresses for which it is responsible, and for routes it
has learned from other AODVv2 routers. Positive routing information (i.e. a route exists)
is distributed via RREQ and RREP messages.  AODVv2 routers store the information
contained in these messages in order to properly forward IP packets, and they generally
provide this information to other AODVv2 routers. Negative routing information (i.e. a route
does not exist) is distributed via RERR messages. AODVv2 routers process these messages and
remove routes, and forward this information to other AODVv2 routers.

Networks using AODVv2 to maintain connectivity and establish routes on demand may be
vulnerable to certain well-known types of threats. Flooding attacks using RREQ amount
to a denial of service for route discovery. Valid route table entries can be replaced
by maliciously constructed RREQ and RREP messages.  Links could be erroneously treated
as bidirectional if malicious unsolicited RREP or RREP_Ack messages were to be accepted.
Replay attacks using RERR messages could, in some circumstances, be used to disrupt active
routes. Passive inspection of AODVv2 control messages could enable unauthorized devices
to gain information about the network topology, since exchanging such information is the
main purpose of AODVv2.

The on-demand nature of AODVv2 route discovery reduces the vulnerability to route disruption.
Since control traffic for updating route tables is diminished, there is less opportunity
for failure. Processing requirements for AODVv2 are typically quite small, and would
typically be dominated by calculations to verify integrity. This has the effect of reducing
(but by no means eliminating) AODVv2's vulnerability to denial of service attacks.

Encryption MAY be used for AODVv2 messages. If the routers share a packet-level
security association, the message data can be encrypted prior to message transmission.
The establishment of such security associations is outside the scope of this specification.
Encryption will not only protect against unauthorized devices obtaining information about
network topology but will ensure that only trusted routers participate in routing operations.

Message integrity checking is enabled by the Integrity Check Value mechanisms defined in
[](#RFC7182). The data contained in AODVv2 routing protocol messages SHOULD be verified using
ICV values, to avoid the use of message data if the message has been tampered with or replayed.
Otherwise, it would be possible to disrupt communications by injecting nonexistent or malicious
routes into the route tables of routers within the ad hoc network.  This can result in loss of
data or message processing by unauthorized devices.

The remainder of this section provides specific recommendations for the use of the integrity
checking and timestamp functions defined in [](#RFC7182) to ensure the integrity of each
AODVv2 message. The calculation used for the Integrity Check Value will depend on the message
type. Sequence numbers can be used as timestamps to protect against replay, since they are
known to be strictly increasing.

RREQ messages advertise a route to OrigAddr, and impose very little processing requirement
for receivers. The main threat presented by sending an RREQ message with false information
is that traffic to OrigAddr could be disrupted.  Since RREQ is multicast and likely to be
received by all routers in the ad hoc network, this threat could have serious impact on
applications communicating by way of OrigAddr. The actual threat to disrupt routes to
OrigAddr is reduced by the AODVv2 mechanism of marking RREQ-derived routes as "Unconfirmed"
until the link to the next hop is confirmed.  If AODVv2 routers always verify the integrity
of the RREQ message data, then the threat of disruption is minimized.  The ICV mechanisms
offered in [](#RFC7182) are sufficient for this purpose.  Since OrigAddr is included in
the RREQ, the ICV can be calculated and verified using message contents. The
ICV SHOULD be verified at every step along the dispersal path of the RREQ to mitigate the
threat. Since RREQ_Gen's sequence number is incremented for each new RREQ, replay protection
is already afforded and no extra timestamp mechanism is required.

RREP messages advertise a route to TargAddr, and impose very little processing requirement
for receivers.  The main threat presented by sending an RREP message with false information
is that traffic to TargAddr could be disrupted.  Since RREP is unicast, this threat is
restricted to receivers along the path from OrigAddr to TargAddr. If AODVv2 routers always
verify the integrity of the RREP message data, then this threat is minimized. This facility
is offered by the ICV mechanisms in [](#RFC7182). Since TargAddr is included as a Data
Element of the RREP, the ICV can be calculated and verified using message contents. The
ICV SHOULD be verified at every step along the unicast path of the RREP. Since RREP_Gen's
sequence number is incremented for each new RREP, replay protection is afforded and no extra
timestamp mechanism is required.

RREP_Ack messages are intended to verify bidirectional neighbor connectivity, and impose very
little processing requirement for receivers.  The main threat presented by sending an RREP_Ack
message with false information is that the route advertised to a target address in an RREP might
be erroneously accepted even though the route would contain a unidirectional link and thus
not be suitable for most traffic. Since RREP_Ack is unicast, this threat is strictly local to
the RREP transmitter expecting the acknowledgement.  A malicious router could also attempt to
send an unsolicited RREP_Ack to convince another router that a bidirectional link exists and
subsequently use further messages to divert traffic along a route which is not valid. If AODVv2
routers always verify the integrity of the RREP_Ack message data, then this threat is minimized.
This facility is offered by the ICV mechanisms in [](#RFC7182). The RREP_Gen SHOULD use the
source IP address of the RREP_Ack to identify the sender, and so the ICV SHOULD be calculated
using the message contents and the IP source address.  The message must also include the
Timestamp defined in [](#RFC7182) to protect against replay attacks, using TargSeqNum from the
RREP as the value in the TIMESTAMP TLV.

RERR messages remove routes, and impose very little processing requirement for receivers. The
main threat presented by sending an RERR message with false information is that traffic to the
advertised destinations could be disrupted.  Since RERR is multicast and can be received by
many routers in the ad hoc network, this threat could have serious impact on applications
communicating by way of the sender of the RERR message. However, since the sender of the RERR
message with erroneous information MAY be presumed to be either malicious or broken, it is
better that such routes not be used anyway.  Another threat is that a malicious RERR message
MAY be sent with a PktSource included, to disrupt PktSource's ability to send to
the addresses contained in the RERR. If AODVv2 routers always verify the integrity of the RERR
message data, then this threat is reduced.  This facility is offered by the ICV mechanisms in
[](#RFC7182). The receiver of the RERR SHOULD use the source IP address of the RERR to identify
the sender. The message must also include the Timestamp defined in [](#RFC7182) to protect
against replay attacks, using SeqNum from RERR_Gen as the value in the TIMESTAMP TLV.

<!-- This "should" require new extension type 2 for the TIMESTAMP TLV  -->



<!--  ================ OLD TEXT ================== -->
<!-- CEP: this paragraph can be deleted, but I don't see the harm in including it... -->
<!-- If a router transmits incorrect or false routing information, it will likely be stored and propagated.-->

<!--  ================ OLD TEXT ================== -->
<!--
 Security for authentication of AODVv2 routers, and/or encryption of traffic is dealt with by
 the underlying transport mechanism (e.g., by using the techniques for Authentication, Integrity,
 and Confidentiality documented in [](#RFC5444)). The most important security mechanism for AODVv2
 routing is integrity/authentication. -->

<!--
 In situations where routing information are suspect, integrity and authentication techniques
 SHOULD be applied to AODVv2 messages. In these situations, routing information that is distributed
 over multiple hops SHOULD also verify the integrity of information based on originator of the
 routing information.

 In situations where confidentiality of AODVv2 messages is important, cryptographic techniques can be
 applied.

 In certain situations, for example sending an RREP or RERR, an AODVv2 router could include proof that
 it has previously received valid routing information to reach the destination, at one point of time
 in the past. In situations where routers are suspected of transmitting maliciously erroneous
 information, the original routing information along with its security credentials SHOULD be included.

 Note that if multicast is used, any confidentiality and integrity algorithms used MUST permit
 multiple receivers to handle the message [](#RFC7182).

 Routing protocols, however, are prime targets for impersonation attacks.  In networks where the
 node membership is not known, it is difficult to determine the occurrence of impersonation
 attacks, and security prevention techniques are difficult at best. However, when the network
 membership is known and there is a danger of such attacks, AODVv2 messages must be protected by
 the use of authentication techniques, such as those involving generation of unforgeable and
 cryptographically strong message digests or digital signatures. -->

<!-- DEREK comments
Some threats to the system could include an injection of RERR message either by an outside attacker,
a rogue router, or a compromised router.  The TTL check protects against some injection techniques
unless it's injected by an actual rogue or compromised router.

In terms of source identification of a RREQ or RREP you might want to add a digital signature field
(which also requires some nonce or timestamp to protect against replay attacks).  There's also a
question of how you authorize a router to supply an RREP.  For example a rogue or compromised router
could decide to "advertize" a route by responding with an RREP even though it's not necessarily the
"best" route or it might not even have a route toward the destination.

When an intermediate router generates an RREP it needs to authenticate that it has the original route.
Perhaps what needs to happen is that it includes the original RREP signed by the TargNode in order to
prove that it HAD (at one point in the past) a valid route toward the TargAddr. This is particularly
an issue in generating the RREP on the fly to the TargAddr from the OrigAddr because there IS no RREP.
In this case it might want to include the original RREQ from the OrigAddr as the authentication token. -->

<!--
 Most AODVv2 messages are transmitted to the multicast address LL-MANET-Routers [](#RFC5498).  It is
 therefore required for security that AODVv2 neighbors exchange security information that can be used
 to insert an ICV [](#RFC7182) into the AODVv2 message block [](#RFC5444). This enables hop-by-hop
 security.  -->
<!-- Issue #Q which is proper for these message types that may have mutable fields.-->
<!--
 For destination-only RREP discovery procedures, AODVv2 routers that share a security association SHOULD
 use the appropriate mechanisms as specified in [](#RFC7182). The establishment of these security
 associations is out of scope for this document. -->


# Acknowledgments

AODVv2 is a descendant of the design of previous MANET on-demand protocols, especially AODV
[](#RFC3561) and DSR [](#RFC4728). Changes to previous MANET on-demand protocols stem from
research and implementation experiences.  Thanks to Elizabeth Belding and Ian Chakeres for
their long time authorship of AODV.  Additional thanks to
Derek Atkins,
Emmanuel Baccelli,
Abdussalam Baryun,
Ramon Caceres,
Thomas Clausen,
Justin Dean,
Christopher Dearlove,
Fatemeh Ghassemi,
Ulrich Herberg,
Henner Jakob,
Ramtin Khosravi,
Luke Klein-Berndt,
Lars Kristensen,
Tronje Krop,
Koojana Kuladinithi,
Kedar Namjoshi,
Keyur Patel,
Alexandru Petrescu,
Henning Rogge,
Fransisco Ros,
Pedro Ruiz,
Christoph Sommer,
Romain Thouvenin,
Richard Trefler,
Jiazi Yi,
Seung Yi,
Behnaz Yousefi,
and
Cong Yuan,
for their reviews of AODVv2 and DYMO, as well as numerous specification suggestions.


<!-- for cutting and pasting...

<section anchor="" title="">

<t>
<figure>
<artwork>



</artwork>
</figure>
</t>
</section>  <- end of "" subsection  >



     for cutting and pasting...  -->