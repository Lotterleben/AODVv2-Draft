<!--
==================================== 80 ========================================
==================================== 72 ================================
 -->
<!--
     Check for lines containing the string "CEP".
     Also for lines containing the string "JPD" (John Dowdell 20140827)
  -->


# Overview

The Ad hoc On-Demand Distance Vector Version 2 (AODVv2) protocol enables
dynamic, multihop routing between participating mobile
nodes wishing to establish and maintain an ad hoc network. The
basic operations of the AODVv2 protocol are route discovery and
route maintenance.  AODVv2 does not require nodes to maintain routes
to destinations that are not in active communication.  AODVv2 allows
mobile nodes to respond to link breakages and changes in network
topology in a timely manner.  The operation of AODVv2 is loop-free,
and by avoiding the Bellman-Ford "counting to infinity" problem
offers quick convergence when the ad hoc network topology changes
(typically, when a node moves in the network).  When links break,
AODVv2 causes the affected set of nodes to be notified so that they
are able to invalidate the routes using the lost link.

One distinguishing feature of AODVv2 is its use of a destination
sequence number for each route entry.  The destination sequence
number is created by the destination to be included along with any
route information it sends to requesting nodes.  Using destination
sequence numbers ensures loop freedom and is simple to program.
Given the choice between two routes to a destination, a requesting
node is required to select the one with the greatest sequence number.

Compared to AODV [](#RFC3561), AODVv2 has moved some features out of the scope of the document, notably intermediate route replies, expanding ring search, route lifetimes and precursor lists. However, the document has been designed to allow their specification in a separate document. Hello messages and local repair have been removed.
AODVv2 provides a mechanism for the use of multiple metric types.
Message formats have been updated and made compliant with [](#RFC5444).
AODVv2 control messages are defined as sets of data, which are mapped
to message elements using the Generalized MANET Packet/Message Format
defined in [](#RFC5444) and sent using the parameters in [](#RFC5498).
Verification of link bidirectionality has been substantially improved, and additional refinements made for route timeouts and state management.

AODVv2 is an Experimental protocol. The purpose of the experiment with AODVv2 is to gain information on the behavior of the protocol in real-world deployments, furthering the knowledge base of both reactive protocols in general, and with AODVv2 in particular. Another goal of the experiment is to determine if sufficient demand exists for the AODVv2 protocol to prompt an effort to bring the protocol to Standards Track.

The basic protocol mechanisms are as follows.
Since AODVv2 is a reactive protocol, route discovery is initiated only when a route to the target is needed (i.e. when a router' client wants to send data). AODVv2 does this with the help of a Route Request (RREQ) and Route Reply (RREP) cycle: an RREQ is distributed across the network until it arrives at the target. When forwarding an RREQ, all routers across the network store the neighbor they've received the RREQ from, memorizing a possible route back to the originator of the RREQ.
When the target receives the RREQ, it answers with an RREP, which then travels back to the originator along the path memorized by the intermediate routers.
A metric value is included within the messages to record the cost of the route. AODVv2 uses sequence numbers to identify stale routing information, and compares route metric values to determine
if advertised routes could form loops.

Route maintenance includes confirming bidirectionality of links to next hop AODVv2 routers and issuing Route Error (RERR) messages informing other routers of broken links. It also includes reacting to received Route Error messages, and extending and enforcing route timeouts.

The on-demand nature of AODVv2 requires signals to be exchanged between AODVv2 and the forwarding plane. These signals
indicate when: 
*  a packet is to be forwarded, in order to initiate route discovery
*  packet forwarding fails, in order to initiate route error reporting
*  a packet is successfully forwarded, for route maintenance.

Security for authentication of AODVv2 routers and encryption of control messages is accomplished using the TIMESTAMP
and ICV TLVs defined in [](#RFC7182).


# Terminology
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as described in [](#RFC2119). In addition, this document
uses terminology from [](#RFC5444), and defines the following terms:

AddressList
:   <vspace/>A list of IP addresses as used in AODVv2 messages.
AckReq
:   <vspace/>Used in a Route Reply message to indicate the IP address of the router from which a Route Reply Acknowledgement
    is expected.
AdvRte
:   <vspace/>A route advertised in an incoming route message.
AODVv2 Router
:   <vspace/>An IP addressable device in the ad hoc network that performs the AODVv2 protocol operations specified in this document.
CurrentTime
:   <vspace/>The current time as maintained by the AODVv2 router.
<!-- [JPD] Need to have a discussion of time somewhere in the text. If no security, only need locally scoped time. Add security, and you
     need globally scoped time to support SSL etc -->
<!-- CEP: It would be wrong to require NTP for ad hoc networks -->
<!-- JPD: Completely agree, but to maintain security should we say that some method of acquiring time either locally (eg from GPS) or remotely
     (eg NTP or tlsdate) is necessary? I think it would be wrong to mandate a particular method but I believe we need to say something -->
ENAR (External Network Access Router)
:   <vspace/>An AODVv2 router with an interface to an external, non-AODVv2 network.
InterfaceSet
:   <vspace/>The set of all network interfaces supporting AODVv2.
Invalid route
:   <vspace/>A route that cannot be used for forwarding but still contains useful sequence number information.
LocalRoute
:   <vspace/>An entry in the Local Route Set as defined in [](#rte).
MANET
:   <vspace/>A Mobile Ad Hoc Network as defined in [](#RFC2501).
MetricType
:   <vspace/>The metric type for a metric value included in a message.
MetricTypeList
:   <vspace/>A list of metric types associated with the addresses in the AddressList of a Route Error message.
Neighbor
:   <vspace/>An AODVv2 router from which an RREQ or RREP message has been received. Neighbors exchange routing information and verify bidirectionality of the
    link to a neighbor before installing a route via that neighbor into the Local Route Set.
OrigAddr
:   <vspace/>The source IP address of the IP packet triggering route discovery.
OrigMetric
:   <vspace/>The metric value associated with the route to OrigPrefix.
OrigPrefix
:   <vspace/>The prefix configured in the Router Client entry which includes OrigAddr.
OrigPrefixLen
:   <vspace/>The prefix length, in bits, configured in the Router Client entry which includes OrigAddr.
OrigSeqNum
:   <vspace/>The sequence number of the AODVv2 router which originated the Route Request on behalf of OrigAddr.
PktSource
:   <vspace/>The source address of the IP packet which triggered a Route Error message.
PrefixLengthList
:   <vspace/>A list of routing prefix lengths associated with the addresses in the AddressList of a message.
Reactive
:   <vspace/>Performed only in reaction to specific events. In AODVv2, routes are requested only when data packets need to be forwarded. In
    this document, "reactive" is synonymous with "on-demand".
RERR (Route Error)
:   <vspace/>The AODVv2 message type used to indicate that an AODVv2 router does not have a valid LocalRoute toward one or more particular destinations.
RERR_Gen (RERR Generating Router)
:   <vspace/>The AODVv2 router generating a Route Error message.
RerrMsg (RERR Message)
:   <vspace/>A Route Error (RERR) message.
Routable Unicast IP Address
:   <vspace/>A routable unicast IP address is a unicast IP address that is scoped sufficiently to be forwarded by a router.  Globally-scoped unicast
    IP addresses and Unique Local Addresses (ULAs) [](#RFC4193) are examples of routable unicast IP addresses.
    <!-- [JPD] ULAs are NOT globally routable -->
    <!-- [CEP] That is true, but they *are* routable unicast addresses -->
    <!-- [CEP] Can it be determined if an address is multihop-capable? -->
Router Client
:   <vspace/>An address or address range configured on an AODVv2 router, on behalf of which that router will initiate and respond to route discoveries. These addresses may be used by the
    AODVv2 router itself or by non-routing devices that are reachable without traversing another AODVv2 router.
RREP (Route Reply)
:   <vspace/>The AODVv2 message type used to reply to a Route Request message.
RREP_Gen (RREP Generating Router)
:   <vspace/>The AODVv2 router that generates the Route Reply message, i.e., the router configured with TargAddr as a Router Client.
RREQ (Route Request)
:   <vspace/>The AODVv2 message type used to discover a route to TargAddr and distribute information about a route to OrigPrefix.
RREQ_Gen (RREQ Generating Router)
:   <vspace/>The AODVv2 router that generates the Route Request message, i.e., the router configured with OrigAddr as a Router Client.
RteMsg (Route Message)
:   <vspace/>A Route Request (RREQ) or Route Reply (RREP) message.
SeqNum
:   <vspace/>The sequence number maintained by an AODVv2 router to indicate freshness of route information.
SeqNumList
:   <vspace/>A list of sequence numbers associated with the addresses in the AddressList of a message.
TargAddr
:   <vspace/>The target address of a route request, i.e., the destination address of the IP packet triggering route discovery.
TargMetric
:   <vspace/>The metric value associated with the route to TargPrefix.
TargPrefix
:   <vspace/>The prefix configured in the Router Client entry which includes TargAddr.
TargPrefixLen
:   <vspace/>The prefix length, in bits, configured in the Router Client entry which includes TargAddr.
TargSeqNum
:   <vspace/>The sequence number of the AODVv2 router which originated the Route Reply on behalf of TargAddr.
Unreachable Address
:   <vspace/>An address reported in a Route Error message, as described in [](#RERR_gen).
Upstream
:   <vspace/>In the direction from destination to source (from TargAddr to OrigAddr).
Valid route
:   <vspace/>A route that can be used for forwarding, as described in [](#RERR_gen). <!-- TODO: while I couldn’t really find a suitable place for it in 7.4.1.  RERR Generation, it wasn’t defined elsewhere either (apart from the terminology section, of course)– maybe that could be done in 4.5.  Local Route Set-->


This document uses the notational conventions in [](#conventions) to simplify the text.

Notation                               Meaning
-------                                ------
Route[Address]                         A route toward Address
Route[Address].Field                   A field in a route toward Address
RteMsg.Field                           A field in either RREQ or RREP

^[conventions:: Notational Conventions]

# Applicability Statement  {#apply}
  <!-- The nets do not have to be mobile, and AODVv2 may be applicable in low power lossy sensor networks. -->

The AODVv2 routing protocol is a reactive routing protocol intended for use in mobile ad hoc wireless networks. A reactive protocol only sends messages to discover a route when there is data to send on that route. Therefore, a reactive routing protocol requires certain interactions with the forwarding plane (for example, to indicate when a packet is to be forwarded,
in order to initiate route discovery). The set of signals exchanged between AODVv2 and the forwarding
plane are discussed in [](#fwdplane).

AODVv2 is designed for stub or disconnected mobile ad hoc networks, i.e., non-transit
networks or those not connected to the internet. AODVv2 can, however, be configured to perform gateway functions when attached to external
networks, as discussed in [](#gateway).

AODVv2 handles a wide variety of mobility and traffic patterns by determining routes on-demand. In networks with a large number of routers, AODVv2 is best suited for relatively sparse traffic scenarios where each router forwards IP packets to a small percentage of other AODVv2 routers in the network. In this case fewer routes are needed, and therefore less control traffic is produced.
In large networks with very frequent or bursty traffic, AODVv2 control messages may cause a broadcast storm, overwhelming the network with control messages and preventing routes from being established.
This especially applies to networks with point-to-point or point-to-multipoint traffic. In this case, the transmission priorities described in [](#MsgXmit) prioritize route maintenance traffic over route discovery traffic.

Data packets may be buffered until a route to their destination is available, as described in [](#route_discovery).

<!-- AODVv2 is well suited to reactive scenarios such as emergency and disaster relief, where the ability to communicate might be more important than being assured of
secure operations.  For other ad hoc networking applications, in which insecure operation could negate the value of establishing communication paths, it is
important for neighboring AODVv2 routers to establish security associations with one another. -->

AODVv2 provides for message integrity and security against replay attacks
by using integrity check values, timestamps and sequence numbers, as described in [](#Security). If security associations can be established,
encryption can be used for AODVv2 messages to ensure that only trusted routers participate in routing operations.

Since the route discovery process aims for a route to be established in both directions along the same path, uni-directional links
are not suitable. AODVv2 will detect and exclude those links from route discovery. The route discovered is optimised for the requesting router,
and the return path may not be the optimal route. <!-- Route costs learned by routers other than the requesting router may not reflect the true route
cost. -->
<!-- and the TargAddr end wouldnt request a better route if it already has a route -->

<!-- Issue #22 -->
AODVv2 is applicable to memory constrained devices, since only a little routing state is maintained in each AODVv2 router. AODVv2 routes that are not needed for forwarding data
do not need to be maintained. On routers unable to store persistent AODVv2 state, recovery can impose a performance penalty (e.g., in case of AODVv2
router reboot), since if a router loses its sequence number, there is a delay before the router can resume full operations. This is described in [](#boot).

AODVv2 supports routers with multiple interfaces and multiple IP addresses per interface. A router may also use the same IP address on multiple interfaces.
AODVv2 requires only that each interface configured for AODVv2 has at least one unicast IP address. Address assignment procedures are out of scope for AODVv2.

AODVv2 supports Router Clients with multiple interfaces, as long as each interface is configured with its own unicast IP address. Multi-homing of a Router
Client IP address is not supported by AODVv2, and therefore an IP address SHOULD NOT be configured as a Router Client on more than one AODVv2 router at any
one time.

<!-- CEP : this can be deleted -->
The routing algorithm in AODVv2 MAY be operated at layers other than the network layer, using layer-appropriate addresses.


# Purpose of the Experiment

<!-- 2) The motivation and experiments to be conducted need to be elaborated. It's even necessary to have a separate section/subsection for it. Some experiment points that come to my mind without much thinking: support of multiple interfaces, support of gateways, use of different metrics, the security model, etc.. -->

AODVv2 is an Experimental protocol. While it is based on AODV [](#RFC3561), important protocol mechanisms have changed:
Bidirectionality is ensured using a new mechanism, alternate metrics may be used to determine route quality, redundant messages are suppressed, support for multiple interfaces and a new security model allowing end to end integrity checks has been added and a new message format ([](#RFC5444)) is used.
Many of these changes have been made quite recently, after a protocol development hiatus of several years.

Thus, the purpose of the experiment is to gain information on the behavior of these significant changes in real-world deployments, not only to learn about AODVv2 in particular, but also to further the knowledge base of reactive protocols in general.

Suitable future experiments could be:

* Evaluation of the new features mentioned above with regard to performance and functionality
* Evaluation of different metrics and their suitability for reactive distance vector protocols


The final goal of the experiment is to determine if sufficient demand
exists for the AODVv2 protocol to prompt an effort to bring the
protocol to Standards Track.


<!-- TODO: Because RFC 3561 has already been experimented for 13 years, as its version 2, AODVv2 should summarize what kind of experiences have been obtained in the past 13 years, and justify the design choices made in the current draft (like use of RFC5444, removing some of the features, etc)-->

# Data Structures

## InterfaceSet {#interfaceslist}

The InterfaceSet is a conceptual data structure which contains information about all interfaces available to AODVv2. Each element in the InterfaceSet MUST contain the following:

Interface.Id
:   <vspace/>An identifier that is unique in node-local scope and that allows the AODVv2 implementation to identify exactly one local network interface.

If multiple interfaces of the AODVv2 router are configured for use by AODVv2, they MUST be configured in the InterfaceSet.

Otherwise the InterfaceSet MAY be empty.

<!-- TODO when I resolve this see also TODO in {#gateway}-->

## Router Client Set {#clients}
An AODVv2 router provides route discovery services for its own local applications and for other non-routing devices that are reachable
without traversing another AODVv2 router. The addresses used by these devices, and the AODVv2 router itself, are configured in the
Router Client Set. An AODVv2 router will only originate Route Request and Route Reply messages on behalf of configured Router Client addresses.

Router Client Set entries MUST contain:

RouterClient.IPAddress
:   <vspace/>An IP address or the start of an address range that requires route discovery services from the AODVv2 router.
<!-- A client node with multiple IP addresses MAY cause the AODVv2 router to be configured with multiple Router Client entries. -->
RouterClient.PrefixLength
:   <vspace/>The length, in bits, of the routing prefix associated with the RouterClient.IPAddress. If a prefix length is
    included, the AODVv2 router MUST provide connectivity for all addresses within that prefix.
RouterClient.Cost
:   <vspace/>The cost associated with reaching this address or address range.

A Router Client address MUST NOT be served by more than one AODVv2 router at any one time. To shift responsibility for a Router Client to
a different AODVv2 router, correct AODVv2 routing behavior MUST be observed; The AODVv2 router adding the Router Client MUST wait for any
existing routing information about this Router Client to be purged from the network, i.e., at least MAX_SEQNUM_LIFETIME since the last SeqNum
update on the router which is removing this Router Client.


## Neighbor Set  {#nbrlist}

A Neighbor Set MUST be maintained with information about neighboring AODVv2 routers. Neighbor Set entries are stored when AODVv2 messages
are received. If the Neighbor is chosen as a next hop on an installed route, the link to the Neighbor MUST be tested for bidirectionality and
the result stored in this set. A route will only be considered valid when the link is confirmed to be bidirectional.

Neighbor Set entries MUST contain:

Neighbor.IPAddress
:   <vspace/>An IP address of the neighboring router, learned from the source IP address of a received route message.
Neighbor.State
:   <vspace/>Indicates whether the link to the neighbor is bidirectional. There are three possible states: Confirmed, Unknown,
    and Blacklisted. Unknown is the initial state. Confirmed indicates that the link to the neighbor has been confirmed as
    bidirectional. Blacklisted indicates that the link to the neighbor is uni-directional. [](#nexthopmonitoring) discusses
    how to monitor link bidirectionality.
Neighbor.ResetTime
:   <vspace/>When the value of Neighbor.State is Blacklisted, this indicates the time at which the value of Neighbor.State
    will revert to Unknown. By default this value is calculated at the time the router is blacklisted and is equal to CurrentTime +
    MAX_BLACKLIST_TIME. When the value of Neighbor.State is not Blacklisted, this time is set to INFINITY_TIME.
Neighbor.Interface
:   <vspace/>The interface on which the link to the neighbor was established.


## Sequence Numbers  {#seqnum}

Sequence numbers enable AODVv2 routers to determine the temporal order of route discovery
messages, identifying stale routing information so that it can be discarded. The sequence
number fulfills the same roles as the "Destination Sequence Number" of DSDV [](#Perkins94),
and the AODV Sequence Number in [](#RFC3561).

<!-- If the router has multiple AODVv2 interfaces or IP addresses, it MAY maintain different sequence
numbers for each interface or IP address, but the router MUST NOT use multiple sequence numbers
for any one IP address.  All route messages created on behalf of Router
Clients on a particular interface MUST include the sequence number associated with that Router Client. -->

Each AODVv2 router in the network MUST maintain its own sequence number. All RREQ and RREP messages created by
an AODVv2 router include the router's sequence number, reported as a 16-bit unsigned integer. Each AODVv2 router
MUST ensure that its sequence number is strictly increasing, and that it is incremented by one (1) whenever an RREQ or
RREP is created, except when the sequence number is 65,535 (the maximum value of a 16-bit unsigned integer), in
which case it MUST be reset to one (1). The value zero (0) is reserved to indicate that the sequence
number is unknown.

An AODVv2 router MUST only attach its own sequence number to information about a route to one of its configured Router
Clients, all route messages forwarded by other routers retain the originator's sequence number. To determine staleness, the previously stored sequence number associated with the originator, is subtracted
from the incoming sequence number. The result of the subtraction is to be interpreted as a signed 16-bit integer, and if
less than zero, the information in the new AODVv2 message is stale and MUST be discarded.
<!-- subtraction is unsigned values, actual calculation is incoming + twos complement of current. then interpret result as a signed twos complement value -->

This, along with the processes in [](#test), ensures loop freedom.

An AODVv2 router SHOULD maintain its sequence number in persistent storage. If the
sequence number is lost, the router MUST follow the procedure in [](#boot) to safely resume
routing operations with a new sequence number.


## Local Route Set  {#rte}

All AODVv2 routers MUST maintain a Local Route Set, containing information about routes learned from AODVv2 route messages. The Local Route Set is stored separately from the forwarding plane's routing table (referred to as Routing Information Base (RIB)), which may be updated by other routing protocols operating on the AODVv2 router as well.
The Routing Information Base is updated using information from the Local Route Set.
Alternatively, implementations MAY choose to modify the Routing Information Base directly.

Routes learned from AODVv2 route messages are referred to in this document as LocalRoutes, and MUST contain the following information:

LocalRoute.Address
:   <vspace/>An address, which, when combined with LocalRoute.PrefixLength, describes the set of destination addresses this
    route includes.
LocalRoute.PrefixLength
:   <vspace/>The prefix length, in bits, associated with LocalRoute.Address.
LocalRoute.SeqNum
:   <vspace/>The sequence number associated with LocalRoute.Address, obtained from the last route message that successfully
    updated this entry.
LocalRoute.NextHop
:   <vspace/>The source IP address of the IP packet containing the AODVv2 message advertising the route to LocalRoute.Address, i.e. an
    IP address of the AODVv2 router used for the next hop on the path toward LocalRoute.Address.
LocalRoute.NextHopInterface
:   <vspace/>The interface used to send IP packets toward LocalRoute.Address.
LocalRoute.LastUsed
:   <vspace/>If this route is installed in the Routing Information Base, the time it was last used to forward an IP packet.
LocalRoute.LastSeqNumUpdate
:   <vspace/>The time LocalRoute.SeqNum was last updated.
LocalRoute.MetricType
:   <vspace/>The type of metric associated with this route.
LocalRoute.Metric
:   <vspace/>The cost of the route toward LocalRoute.Address expressed in units consistent with LocalRoute.MetricType.
LocalRoute.State
:   <vspace/>The last known state (Unconfirmed, Idle, Active, or Invalid) of the route.

There are four possible states for a LocalRoute:

Unconfirmed
:   <vspace/>A route learned from a Route Request message, which has not yet been confirmed as bidirectional. It MUST NOT
    be used for forwarding IP packets, and therefore it is not referred to as a valid route. This state only applies to routes learned through RREQ messages.
Idle
:   <vspace/>A route which has been learned from a route message, and has also been confirmed, but has not been used in
    the last ACTIVE_INTERVAL. It is able to be used for forwarding IP packets, and therefore it is referred to as a valid
    route.
Active
:   <vspace/>A route which has been learned from a route message, and has also been confirmed, and has been used in the
    last ACTIVE_INTERVAL. It is able to be used for forwarding IP packets, and therefore it is referred to as a valid
    route.
Invalid
:   <vspace/>A route which has expired or been lost. It MUST NOT be used for forwarding IP packets, and therefore it
    is not referred to as a valid route. Invalid routes contain sequence number information which allows
    incoming information to be assessed for freshness.

When the Local Route Set is stored separately from the Routing Information Base, routes are added to the Routing Information Base
when LocalRoute.State is valid (set to Active or Idle), and removed from the Routing Information Base when LocalRoute.State becomes Invalid.

Changes to LocalRoute state are detailed in [](#routestatechanges).

Multiple valid routes for the same address and prefix length but for different metric types may exist in the Local Route Set, but
the decision of which of these routes to install in the Routing Information Base to use for forwarding is outside the scope of AODVv2.


## Multicast Route Message Set  {#rtemsgtable}

A route message (RteMsg) is either a Route Request or Route Reply message. RREQ messages are multicast by default and forwarded
multiple times, and RREP messages will be multicast when the link to the next router is not known to be bidirectional. Multiple similar
route messages might be received by any one router during one route discovery attempt. The AODVv2 router does not need to forward or respond to every
one of these messages.

The Multicast Route Message Set is a conceptual set which contains information about previously received multicast route messages, so that
incoming route messages can be compared with previously received messages to determine if the incoming information is redundant or stale, and the router can
avoid sending redundant control traffic.

Multicast Route Message Set entries MUST contain the following information:

RteMsg.MessageType
:   <vspace/>Either RREQ or RREP.
RteMsg.OrigPrefix
:   <vspace/>The prefix associated with OrigAddr, the source address of the IP packet triggering the route request.
RteMsg.OrigPrefixLen
:   <vspace/>The prefix length associated with RteMsg.OrigPrefix, originally from the Router Client entry on RREQ_Gen which includes OrigAddr.
RteMsg.TargPrefix
:   <vspace/>The prefix associated with TargAddr, the destination address of the IP packet triggering the route request. In an RREQ this MUST be set to TargAddr.
RteMsg.TargPrefixLen
:   <vspace/>The prefix length associated with RteMsg.TargPrefix, originally from the Router Client entry on RREP_Gen which includes TargAddr. If RteMsg is an RREQ, RteMsg.TargPrefixLen MUST equal address length.
RteMsg.OrigSeqNum
:   <vspace/>The sequence number associated with the route to OrigPrefix, if RteMsg is an RREQ.
RteMsg.TargSeqNum
:   <vspace/>The sequence number associated with the route to TargPrefix, if RteMsg is an RREP.
RteMsg.MetricType
:   <vspace/>The metric type of the route requested.
RteMsg.Metric
:   <vspace/>The metric value received in the RteMsg.
RteMsg.Timestamp
:   <vspace/>The last time this Multicast Route Message Set entry was updated.
RteMsg.RemoveTime
:   <vspace/>The time at which this entry MUST be removed from the Multicast Route Message Set. This is set
    to CurrentTime + MAX_SEQNUM_LIFETIME, whenever the sequence number of this entry (RteMsg.OrigSeqNum for an
    RREQ, or RteMsg.TargSeqNum for an RREP) is updated.
RteMsg.AckReqAddr
:   <vspace/>The address from which an RREP_Ack is expected, if RteMsg is an RREP that contains an AckReq.
RteMsg.Interface
:   <vspace/>The interface on which the message was received.

The Multicast Route Message Set is maintained so that no two entries have the same MessageType, OrigPrefix, OrigPrefixLen, TargPrefix, TargPrefixLen, and MetricType. See [](#suppress) for details about updating this set.


## Route Error (RERR) Set  {#rerrtable}

Each sent RERR message SHOULD be recorded in a conceptual set called the Route Error (RERR) Set. Each entry contains the following information:

RerrMsg.Timeout
:   <vspace/>The time after which the entry SHOULD be deleted.
RerrMsg.AddressList
:   <vspace/>The AddressList of the RERR to be recorded.
RerrMsg.PktSource:
:   <vspace/>The PktSource of the RERR to be recorded, if any.

See section [](#suppressrerr) for instructions on how to update the set.

# Metrics  {#metrics}

Metrics measure a cost or quality associated with a route or a link, e.g., latency, delay, financial cost, energy, etc. Metric
values are reported in Route Request and Route Reply messages.

In Route Request messages, the metric describes the cost of the route from OrigPrefix to the router sending the Route Request. For RREQ_Gen, this is the cost associated with the Router Client entry which includes OrigAddr. For routers which forward the RREQ, this is the cost from OrigPrefix to the forwarding router, combining the metric value from the received RREQ message with knowledge of the link cost from the sender to the receiver, i.e., the incoming link cost. This updated route cost is included when forwarding the Route Request message,
and used to install a route to OrigPrefix.

Similarly, in Route Reply messages, the metric reflects the cost of the route from TargPrefix to the router sending the Route Reply. For RREP_Gen, this is the cost associated with the Router Client entry which includes TargAddr. For routers which forward the RREP, this is the cost from TargPrefix to the forwarding router, combining the metric value from the received RREP message with knowledge of the link cost from the sender to the receiver, i.e., the incoming link cost. This updated route cost is included when forwarding the Route Reply message,
and used to install a route to TargPrefix.

Assuming link metrics are symmetric, the cost of the routes installed in the Local Route Set at each router will be correct. While this assumption is not always correct, calculating incoming/outgoing metric data is outside of scope of this document.
The route discovered is optimised for the requesting router, and the return path may not be the optimal route.

<!-- if not symmetric...could be stored with MAX_METRIC..then if forwarding data from a Router Client on a route with MAX_METRIC maybe this could indicate that a route should be requested, to learn the best cost from us to them, rather than them to us which is what we would have installed.  -->
<!-- Similarly cost on route to TargAddr is currently stored with metric from targ->current. The existing route to TargAddr is probably a good one, because it was found on a prev RREQ in that direction - its just that we dont know the accurate metric. OR, we could be adding up outgoing link costs back toward targaddr in a rrep, and also transporting the orig->targ metric unchanged, add up outgoing metrics to get correct cost for targaddr -->

AODVv2 enables the use of multiple metric types. Each route discovery attempt indicates the metric type which is requested for
the route. Only one metric type MUST be used in each route discovery attempt.

For each MetricType, AODVv2 requires:

* A MetricType number, to indicate the metric type of a route. MetricType numbers allocated are detailed in [](#metric-type).
* A maximum value, denoted MAX_METRIC[MetricType]. This MUST always be the maximum expressible metric value of type MetricType.
  Field lengths associated with metric values are found in [](#metric-type). If the cost of a route exceeds MAX_METRIC[MetricType], the route is ignored.
* A function for incoming link cost, denoted Cost(L). Using incoming link costs means that the route learned has a path optimized
  for the direction from OrigAddr to TargAddr.
* A function for route cost, denoted Cost(R).
* A function to analyze routes for potential loops based on metric information, denoted LoopFree(R1, R2). LoopFree verifies that a route R2 is not a sub-section
  of another route R1. An AODVv2 router invokes LoopFree() as part of the process in [](#test), when an advertised route (R1) and an
  existing LocalRoute (R2) have the same destination address, metric type, and sequence number. LoopFree returns FALSE to indicate
  that an advertised route is not to be used to update a stored LocalRoute, as it may cause a routing loop. In the case where the
  existing LocalRoute is Invalid, it is possible that the advertised route includes the existing LocalRoute and came from a router
  which did not yet receive notification of the route becoming Invalid, so the advertised route should not be used to update the Local
  Route Set, in case it forms a loop to a broken route.

AODVv2 currently supports cost metrics where Cost(R) is strictly increasing, by defining:

* Cost(R) := Sum of Cost(L) of each link in the route
* LoopFree(R1, R2) := ( Cost(R1) \<= Cost(R2) )

Implementers MAY consider other metric types, but the definitions of Cost and LoopFree functions for such types are undefined, and
interoperability issues need to be considered.



# AODVv2 Protocol Operations  {#aodv_ops}

The AODVv2 protocol's operations include managing sequence numbers, monitoring next hop AODVv2 routers on discovered routes and updating the Neighbor Set,
performing route discovery and dealing with requests from other routers, processing incoming route information and updating the Local
Route Set, updating the Multicast Route Message Set and suppressing redundant messages, and reporting broken routes. These processes
are discussed in detail in the following sections.

## Initialization {#boot}

During initialization where an AODVv2 router does not have information about its previous sequence number, or if its sequence number
is lost at any point, the router resets its sequence number to one (1). However, other AODVv2 routers may still hold sequence number
information that this router previously issued. Since sequence number information is removed if there has been no update to the sequence
number in MAX_SEQNUM_LIFETIME, the initializing router MUST wait for MAX_SEQNUM_LIFETIME before it creates any messages containing its
new sequence number. It can then be sure that the information it sends will not be considered stale.

During this wait period, the router is permitted to do the following:

* Process information in a received RREQ or RREP message to learn a route to the originator or target of that route discovery
* Forward a received RREQ or RREP
* Send an RREP_Ack
* Maintain valid routes in the Local Route Set
<!-- and therefore in the Routing Information Base, in order that the forwarding process can forward IP packets to Router Clients and to other routers -->
* Create, process and forward RERR messages


## Next Hop Monitoring  {#nexthopmonitoring}

To ensure AODVv2 routers Routers do not establish routes over uni-directional links, AODVv2 routers MUST verify that the link to the next hop router is bidirectional before marking a route as valid in the Local Route Set.

AODVv2 provides a mechanism for testing bidirectional connectivity during route discovery, and blacklisting routers where bidirectional
connectivity is not available. If a route discovery is retried by RREQ_Gen, the blacklisted routers can be excluded from the process, and
a different route can be discovered. Further, a route is not to be used for forwarding until the bidirectionality of the link to the next
hop is confirmed. AODVv2 routers do not need to monitor bidirectionality for links to neighboring routers which are not used as next hops
on routes in the Local Route Set.

*  Bidirectional connectivity to upstream routers is tested by
   requesting acknowledgement of RREP messages by including an AckReq, which MUST be answered by sending an RREP_Ack. Receipt of an RREP_Ack within RREP_Ack_SENT_TIMEOUT proves that bidirectional connectivity exists. Otherwise, a link is determined to be unidirectional. All AODVv2 routers MUST support this process, which is explained in [](#RREP_msgs) and [](#rrep_ack_msgs).
*  For the downstream router, receipt of an RREP message
   containing the route to TargAddr is confirmation of bidirectionality , since an RREP message is a reply to a RREQ message which previously crossed the link in the opposite direction.

To assist with next hop monitoring, a Neighbor Set ([](#nbrlist)) is maintained. When an RREQ or RREP is received, search for an entry in the Neighbor Set where all of the following conditions are met:

* Neighbor.IPAddress == IP address from which the RREQ or RREP was received
* Neighbor.Interface == Interface on which the RREQ or RREP was received.

If such an entry does not exist, a new entry is created as described in [](#nbrupdate). While the value of Neighbor.State is Unknown, acknowledgement of RREP messages sent to that neighbor MUST be requested. If an acknowledgement is not received within the timeout period, the neighbor MUST have Neighbor.State set to Blacklisted. If an acknowledgement is received within the timeout period, Neighbor.State is set to Confirmed. While the value of Neighbor.State is Confirmed, the request for an acknowledgement of any other RREP message is unnecessary.

<!-- While Neighbor.State is Blacklisted, RREQs received from that router MUST be disregarded.-->
<!-- TODO if a previously confirmed link goes uni-directional...we think it still works... if route was established and route goes unidirectional, do we
get a notification? i.e. would route break, send RERR etc? if we establish other routes over this link (but it no longer unidirectional) this is baaad....-->

When routers perform other operations such as those from the list below, these MAY be used as additional indications of connectivity:

* NHDP HELLO Messages [](#RFC6130)
* Route timeout
* Lower layer triggers, e.g. message reception or link status notifications
* TCP timeouts
* Promiscuous listening
* Other monitoring mechanisms or heuristics

If such an external process signals that the link to a neighbor is
bidirectional, the AODVv2 router MAY update the matching Neighbor
Set entry by changing the value of Neighbor.State to Confirmed, e.g. receipt of a Neighborhood Discovery
Protocol HELLO message with the receiving router listed as a neighbor.  If
an external process signals that a link is not bidirectional, the the
value of Neighbor.State MAY be changed to Blacklisted, e.g. notification of a TCP timeout.



## Neighbor Set Update {#nbrupdate}

On receipt of an RREQ or RREP message, the Neighbor Set MUST be checked for an entry with Neighbor.IPAddress which matches the source IP address of a packet containing the AODVv2 message. If no matching entry is found, a new entry is created.

A new Neighbor Set entry is created as follows:

* Neighbor.IPAddress := Source IP address of the received route message
* Neighbor.State := Unknown
* Neighbor.ResetTime := INFINITY_TIME
* Neighbor.Interface := Interface on which the RREQ or RREP was received. MUST equal Interface.Id of one of the entries in the InterfaceSet (see [](#interfaceslist)).

If the message is one of the following:

* an RREP which answers an RREQ sent within RREQ_WAIT_TIME over the same interface as Neighbor.Interface <!-- TODO? also check if it matches an existing unconfirmed route -->
* an RREP_Ack which answers an RREP sent within RREP_Ack_SENT_TIMEOUT over the same interface as Neighbor.Interface

the link to the neighbor is bidirectional and the Neighbor Set entry is updated as follows:

* Neighbor.State := Confirmed <!-- could set reset time when set state to confirmed, to re-test after certain time -->
* Neighbor.ResetTime := INFINITY_TIME

If the Multicast Route Message Set contains an entry where:

* RteMsg.MessageType == RREP
* RteMsg.AckReqAddr == Neighbor.IPAddress
* RteMsg.Interface == Neighbor.Interface
* RteMsg.Timestamp + RREP_Ack_SENT_TIMEOUT < CurrentTime

the link is considered to be uni-directional and the Neighbor Set entry is updated as follows:

* Neighbor.State := Blacklisted
* Neighbor.ResetTime := CurrentTime + MAX_BLACKLIST_TIME

When the Neighbor.ResetTime is reached, the Neighbor Set entry is updated as follows:

* Neighbor.State := Unknown

If an external mechanism reports a link as broken, the Neighbor Set entry SHOULD be removed.

Route requests from neighbors with Neighbor.State set to Blacklisted are ignored to avoid persistent IP packet
loss or protocol failures. Neighbor.ResetTime allows the neighbor to again be allowed to participate in route discoveries after MAX_BLACKLIST_TIME, in case the link between the routers has become bidirectional.


## Interaction with the Forwarding Plane {#fwdplane}

The signals descried in the following are conceptual signals, and can be implemented in various ways.
Conformant implementations of AODVv2 are not mandated
to implement the forwarding plane separately from the control plane or data plane; these signals and interactions are
identified simply as assistance for implementers who may find them useful.

AODVv2 requires signals from the forwarding plane:

*   A packet cannot be forwarded because a route is unavailable: AODVv2 needs to know the source and destination IP addresses of the packet.
    If the source of the packet is configured as a Router Client, the router should initiate route discovery to the destination. If it is not
    a Router Client, the router should create a Route Error message.
*   A packet is to be forwarded: AODVv2 needs to check the state of the route to ensure it is still valid.
*   Packet forwarding succeeds: AODVv2 needs to update the record of when a route was last used to forward a packet.
*   Packet forwarding failure occurs: AODVv2 needs to create a Route Error message.

AODVv2 needs to send signals to the forwarding plane:

*   A route discovery is in progress: buffering might be configured for packets requiring a route, while route discovery is attempted.
*   A route discovery failed: any buffered packets requiring that route should be discarded, and the source of the packet
    should be notified that the destination is unreachable (using an ICMP Destination Unreachable message). Route discovery fails
    if an RREQ cannot be generated because the control message generation limit has been reached, or if an RREP is not received
    within RREQ_WAIT_TIME (see [](#route_discovery)).
*   A route discovery is not permitted: any buffered packets requiring that route should be discarded. A route discovery will
    not be attempted if the source address of the packet needing a route is not configured as a Router Client.
*   A route discovery succeeded: install a corresponding route into the Routing Information Base and begin transmitting any buffered packets.
*   A route has been made invalid: remove the corresponding route from the Routing Information Base.
*   A route has been updated: update the corresponding route in the Routing Information Base.

## Message Transmission  {#MsgXmit}

AODVv2 sends [](#RFC5444) formatted messages using the parameters for port number and IP protocol specified in [](#RFC5498).
Mapping of AODVv2 data to [](#RFC5444) messages is detailed in [](#represent). AODVv2 multicast
messages are sent to the link-local multicast address LL-MANET-Routers [](#RFC5498). All AODVv2 routers MUST subscribe to
LL-MANET-Routers on all AODVv2 interfaces [](#RFC5498) to receive AODVv2 messages. Note that multicast messages MAY be sent via unicast. For example,
this may occur for certain link-types (non-broadcast media), for manually configured router adjacencies, or in order to
improve robustness.

When multiple interfaces are available, an AODVv2 router transmitting a multicast message to LL-MANET-Routers MUST send the
message on all interfaces that have been configured for AODVv2 operation, as given in the InterfaceSet ([](#interfaceslist)).

<!-- Implementations MAY choose to employ techniques to reduce the number of multicast messages sent. Use of [](#RFC6621) in deployments
is recommended. Employing [](#RFC6621) in a subset of the operational AODVv2 routers in a network, or configuring different algorithms
on different routers, will not cause interoperability issues, but will reduce the effectiveness of the multicast reduction scheme. -->

To avoid congestion, each AODVv2 router's rate of message generation SHOULD be limited (CONTROL_TRAFFIC_LIMIT) and administratively
configurable. Messages SHOULD NOT be sent more frequently than one message per (1 / CONTROL_TRAFFIC_LIMIT)th of a second. If this threshold is reached, messages MUST be sent based on their priority:

* Highest priority SHOULD be given to RREP_Ack messages. This allows links between routers to be confirmed as bidirectional and
  avoids undesired blacklisting of next hop routers.
* Second priority SHOULD be given to RERR messages for undeliverable IP packets. This avoids repeated forwarding of packets over broken routes that are still in use by other routers.
* Third priority SHOULD be given to RREP messages in order that RREQs do not time out.
* Fourth priority SHOULD be given to RREQ messages.
* Fifth priority SHOULD be given to RERR messages for newly invalidated routes.
* Lowest priority SHOULD be given to RERR messages generated in response to RREP messages which cannot be forwarded. In this case the
  route request will be retried at a later point.

<!-- Messages may travel a maximum of MAX_HOPCOUNT hops. -->

<!-- IP packets containing AODVv2 protocol messages SHOULD be given priority queuing and channel
access. -->

To implement the congestion control, a queue length is set. If the queue is full, in order to queue a new message, a message of lower priority must be removed from the queue. If this is not possible, the new message MUST be discarded. The queue should be sorted in order of message priority

## Route Discovery, Retries and Buffering  {#route_discovery}

AODVv2's RREQ and RREP messages are used for route discovery. RREQ messages are multicast to solicit an RREP, whereas
RREP are unicast where possible. The constants used in this section are defined in [](#param).

When an AODVv2 router needs to forward an IP packet (with source address OrigAddr and destination address TargAddr) from
one of its Router Clients, it needs a route to TargAddr in its Routing Information Base. If no route exists,
the AODVv2 router generates (RREQ_Gen) and multicasts a Route Request message (RREQ), on all configured interfaces, containing information about the source and destination. The procedure for this
is described in [](#RREQ_gen). Each generated RREQ results in an increment to the router's sequence number. The AODVv2 router generating an
RREQ is referred to as RREQ_Gen.

<!-- CEP: Issue # to be generated for moving DestOnly to the irrep draft...
    Optionally, RREQ_Gen MAY specify that only the router serving
    TargAddr is allowed to generate an RREP message, by including
    the DestOnly Data Element (see <xref target="RREQ_gen" />).
  -->

Buffering might be configured for IP packets awaiting a route for forwarding by RREQ_Gen, if sufficient memory is available. 
Buffering of IP packets might have both positive and negative effects. Real-time traffic, voice, and scheduled delivery may suffer if packets are
buffered and subjected to delays, but TCP connection establishment will benefit if packets are queued while route discovery is performed [](#Koodli01).
Recommendations for appropriate buffer methods are out of scope for this specification. Determining which packets to discard first when the buffer is full is a matter of policy at each AODVv2 router. Note that using different or no buffer methods does not affect interoperability.

RREQ_Gen awaits reception of a Route Reply message (RREP) containing a route toward TargAddr. This can be achieved by monitoring the entry in the Multicast Route Message Table that corresponds to the generated RREP. When CurrentTime exceeds RteMsg.Timestamp + RREQ_WAIT_TIME and no RREP has been received, RREQ_Gen will retry the route discovery.

To reduce congestion in a network, repeated attempts at route discovery for a particular target address utilize a binary exponential backoff: for each additional attempt, the time to wait for receipt of the RREP is
multiplied by 2. If the requested route is not learned within the wait period, another RREQ is sent, up to a total of DISCOVERY_ATTEMPTS_MAX.
This is the same technique used in AODV [](#RFC3561).

Through the use of bidirectional link monitoring and blacklists (see [](#nexthopmonitoring)) uni-directional links on initial selected route will be ignored on subsequent route discovery attempts.

Route discovery is considered to have failed after DISCOVERY_ATTEMPTS_MAX and the corresponding wait time for an RREP response to
the final RREQ. After the attempted route discovery has failed, RREQ_Gen waits at least RREQ_HOLDDOWN_TIME before attempting another route
discovery to the same destination, in order to avoid repeatedly generating control traffic that is unlikely to discover a route. Any IP
packets buffered for TargAddr are also dropped and a Destination Unreachable ICMP message (Type 3) with a code of 1 (Host Unreachable Error)
is delivered to the source of the packet, so that the application knows about the failure.

If RREQ_Gen does receive a route message containing a route to TargAddr within the timeout, it processes the message according to
[](#aodv_msgs). When a valid LocalRoute entry is created in the Local Route Set, the route is also installed in the Routing Information Base, and
the router will begin sending the buffered IP packets. Any retry timers for the corresponding RREQ are then cancelled.

During route discovery, all routers on the path learn a route to both OrigPrefix and TargPrefix, so that routes are constructed in both directions.
The route is optimized for the forward route.

<!-- For RREQ, use incoming cost from previous hop, so that the return path will be the optimal for Orig->Targ. -->
<!-- Targ rtr doesnt learn the optimal path to OrigAddr, in fact learns wrong metric too -->

<!--
Routes to OrigAddr learned from an RREQ will reflect the route cost in the direction from OrigAddr toward
TargAddr, calculated at each receiving router. This might not be the correct cost for their route to OrigAddr.
The corresponding RREP contains this accumulated metric value. It is not changed at intermediate routers, so
RREQ_Gen and all intermediate routers install a route to TargAddr using this metric. At intermediate routers
this route does not correctly reflect the cost of their route to TargAddr.
-->

## Processing Received Route Information {#processingrte}

All AODVv2 route messages contain a route. A Route Request (RREQ) contains a route to OrigPrefix, and a Route Reply (RREP) contains a route to TargPrefix. All AODVv2 routers that receive a route
message are able to store the route contained within it in their Local Route Set. Incoming information is first checked to verify that it is both safe
to use and offers an improvement to existing information, as explained in [](#test).
If these checks pass, the Local Route Set MUST be updated according to [](#update_rte).

In the processes below, RteMsg is used to denote the route message, AdvRte is used to denote the route contained within it, and LocalRoute
denotes an existing entry in the Local Route Set which matches AdvRte on address, prefix length, and metric type.

AdvRte has the following properties:

* AdvRte.Address := RteMsg.OrigPrefix (in RREQ) or RteMsg.TargPrefix (in RREP)
* AdvRte.PrefixLength := RteMsg.OrigPrefixLen (in RREQ) or RteMsg.TargPrefixLen (in RREP). If no prefix length was
  included in RteMsg, prefix length is the address length, in bits, of RteMsg.OrigPrefix (in RREQ) or RteMsg.TargPrefix (in RREP)
* AdvRte.SeqNum := RteMsg.OrigSeqNum (in RREQ) or RteMsg.TargSeqNum (in RREP)
* AdvRte.NextHop := RteMsg.IPSourceAddress (an address of the sending interface of the router from which the RteMsg was received)
* AdvRte.MetricType := RteMsg.MetricType
* AdvRte.Metric := RteMsg.Metric
* AdvRte.Cost := Cost(R) using the cost function associated with the route's metric type,
  i.e. Cost(R) = AdvRte.Metric + Cost(L), as described in [](#metrics), where L is the link from the
  advertising router


### Evaluating Route Information  {#test}

An incoming advertised route (AdvRte) is compared to existing LocalRoutes to determine whether the advertised route is to be used to update the AODVv2 Local Route Set. The incoming route information MUST be processed as follows:

1.  Search for LocalRoutes in the Local Route Set matching AdvRte's address, prefix length and metric type
    *   If no matching LocalRoute exists, AdvRte MUST be used to update the Local Route Set and no further checks are required.
    *   If matching LocalRoutes are found, continue to Step 2.

1.  Compare sequence numbers using the technique described in [](#seqnum)
    *   If AdvRte is more recent than all matching LocalRoutes, AdvRte MUST be used to update the Local Route Set and no further checks are required.
    *   If AdvRte is stale, AdvRte MUST NOT be used to update the Local Route Set. Ignore AdvRte for further processing.
    *   If the sequence numbers are equal, continue to Step 3.

1.  Check that AdvRte is safe against routing loops compared to all matching LocalRoutes (see [](#metrics))
    *   If LoopFree(AdvRte, LocalRoute) returns FALSE, ignore AdvRte for further processing. AdvRte MUST NOT be used to update the Local Route Set because using the incoming information might cause a routing loop.
    *   If LoopFree(AdvRte, LocalRoute) returns TRUE, continue to Step 4.

1.  Compare route costs
    *   If AdvRte is better than all matching LocalRoutes, it SHOULD be used to update the Local Route Set because it offers improvement. If it is not used to update the Local Route Set, the existing non-optimal LocalRoute will continue to be used, causing data traffic to use a non-optimal route.
    *   If AdvRte is equal in cost and LocalRoute is valid, AdvRte SHOULD NOT be used to update the Local Route Set because it will offer no improvement.
    *   If AdvRte is worse and LocalRoute is valid, ignore AdvRte for further processing. AdvRte MUST NOT be used to update the Local Route Set because it does not offer any improvement.
    *   If AdvRte is not better (i.e., it is worse or equal) but LocalRoute is Invalid, AdvRte SHOULD be used to update the Local Route Set because it can safely repair the existing Invalid LocalRoute.

If the advertised route is to be used to update the Local Route Set, the procedure in [](#update_rte) MUST be followed. If not, non-optimal routes will remain in the Local Route Set.

For information on how to apply these changes to the Routing Information Base, see [](#rte).

### Applying Route Updates  {#update_rte}

After determining that AdvRte is to be used to update the Local Route Set (as described in [](#test)), the following procedure applies.

If AdvRte is learned from an RREQ message, the link to the next hop neighbor may not be confirmed as bidirectional (see [](#nbrlist)). The route will offer improvement to the Local Route Set if the neighbor can be confirmed. If there is no existing matching route, AdvRte allows a corresponding RREP to be sent. If a matching entry already exists, AdvRte offers potential improvement.

The route update is applied as follows:

1.  If no existing entry in the Local Route Set matches AdvRte's address, prefix length and metric type, continue to Step 4 and create a new entry in the Local Route Set.

1.  If two matching LocalRoutes exist in the Local Route Set, one is a valid route, and one is an Unconfirmed route, AdvRte may offer further improvement to the Unconfirmed route, or may offer an update to the valid route.

    * If AdvRte.NextHop's Neighbor.State is Unknown, the advertised route may offer improvement to the existing valid route, if the link to the next hop can be confirmed as bidirectional. Continue processing from Step 5 to update the existing Unconfirmed LocalRoute.
    * If AdvRte.NextHop's Neighbor.State is Confirmed, the advertised route offers an update or improvement to the existing valid route. Continue processing from Step 5 to update the existing valid LocalRoute.

1.  If only one matching LocalRoute exists in the Local Route Set:

    * If AdvRte.NextHop's Neighbor.State is Confirmed, continue processing from Step 5 to update the existing LocalRoute.
    * If AdvRte.NextHop's Neighbor.State is Unknown, AdvRte may offer improvement the existing LocalRoute, if the link to AdvRte.NextHop can be confirmed as bidirectional.
    * If LocalRoute.State is Unconfirmed, AdvRte is an improvement to an existing Unconfirmed route. Continue processing from Step 5 to update the existing LocalRoute.
    * If LocalRoute.State is Invalid, AdvRte can replace the existing LocalRoute. Continue processing from Step 5 to update the existing LocalRoute.
    * If LocalRoute.State is Active or Idle, AdvRte SHOULD be stored as an additional entry in the Local Route Set, with LocalRoute.State set to Unconfirmed. Continue processing from Step 4 to create a new LocalRoute.

1.  Create an entry in the Local Route Set and initialize as follows:

    *  LocalRoute.Address := AdvRte.Address
    *  LocalRoute.PrefixLength := AdvRte.PrefixLength
    *  LocalRoute.MetricType := AdvRte.MetricType

1.  Update the LocalRoute as follows:

    *  LocalRoute.SeqNum := AdvRte.SeqNum
    *  LocalRoute.NextHop := AdvRte.NextHop
    *  LocalRoute.NextHopInterface := interface on which RteMsg was received
    *  LocalRoute.Metric := AdvRte.Cost
    *  LocalRoute.LastUsed := CurrentTime
    *  LocalRoute.LastSeqNumUpdate := CurrentTime

1.  If a new LocalRoute was created, or if the existing LocalRoute.State is Invalid or Unconfirmed, update LocalRoute
    as follows:

    *  LocalRoute.State := Unconfirmed (if the next hop's Neighbor.State is Unknown)
    *  LocalRoute.State := Idle (if the next hop's Neighbor.State is Confirmed)

1.  If an existing LocalRoute.State changed from Invalid or Unconfirmed to become Idle, any matching Unconfirmed LocalRoute
    with worse metric value SHOULD be expunged.

1.  If an existing LocalRoute was updated with a better metric value, any matching Unconfirmed LocalRoute with worse metric
    value SHOULD be expunged.

1.  If this update results in LocalRoute.State of Active or Idle, which matches a route request which is still in progress,
    the associated route request retry timers SHOULD be cancelled.

If this update to the Local Route Set results in two LocalRoutes to the same address, the best LocalRoute will be
Unconfirmed. In order to improve the route used for forwarding, the router SHOULD try to determine if the link to the
next hop of that LocalRoute is bidirectional, by using that LocalRoute to forward future RREPs and request acknowledgements
(see [](#RREP_gen)).


## Suppressing Redundant Messages Using the Multicast Route Message Set  {#suppress}

When route messages are flooded in a MANET, an AODVv2 router may receive multiple similar
messages. Forwarding every one of these gives little additional benefit, and generates
unnecessary signaling traffic and might generate unnecessary interference.

Each AODVv2 router stores information about recently received route messages in the AODVv2 Multicast Route Message Set ([](#rtemsgtable)).

Entries in the Multicast Route Message Set SHOULD be maintained for at least RteMsg_ENTRY_TIME after
the last Timestamp update in order to account for long-lived RREQs traversing the network. An entry MUST
be deleted when the sequence number is no longer valid, i.e., after MAX_SEQNUM_LIFETIME. Memory-constrained
devices MAY remove the entry before this time.

Received route messages are tested against previously received route messages, and if determined to be
redundant, forwarding or response can be avoided.

To determine if a received message is redundant:

1.  Search for an entry in the Multicast Route Message Set with the same MessageType, OrigPrefix, OrigPrefixLen, TargPrefix, TargPrefixLen, Interface and MetricType
    *   If there is no entry, the message is not redundant.
    *   If there is an entry, continue to Step 2.
2.  Compare sequence numbers using the technique described in [](#seqnum)
    *   For RREQ messages, use OrigSeqNum of the entry for comparison. For RREP messages, use TargSeqNum of
        the entry for comparison.
    *   If the entry has an older sequence number than the received message, the message is not redundant.
    *   If the entry has a newer sequence number than the received message, the message is redundant.
    *   If the entry has the same sequence number, continue to Step 3.
3.  Compare the metric values
    *   If the entry has a Metric value that is worse than or equal to the metric in the received message,
        the message is redundant.
    *   If the entry has a Metric value that is better than the metric in the received message, the message
        is not redundant.

If the message is redundant, update the Timestamp and RemoveTime on the entry, since matching route messages are still
traversing the network and this entry should be maintained. This message MUST NOT be forwarded or
responded to.

If the message is not redundant, create an entry or update the existing entry.

To update a Multicast Route Message Set entry, set:

* RteMsg.MessageType := the message type of the received message
* RteMsg.OrigPrefix := OrigPrefix from the message
* RteMsg.OrigPrefixLen := the prefix length associated with OrigPrefix
* RteMsg.TargPrefix := TargPrefix from the message
* RteMsg.TargPrefixLen := the prefix length associated with TargPrefix
* RteMsg.OrigSeqNum := the sequence number associated with OrigPrefix, if present in the received message
* RteMsg.TargSeqNum := the sequence number associated with TargPrefix, if present in the received message
* RteMsg.Metric := the metric value associated with OrigPrefix in a received RREQ or TargPrefix in a received RREP
* RteMsg.MetricType := the metric type associated with RteMsg.Metric
* RteMsg.Timestamp := CurrentTime
* RteMsg.RemoveTime := CurrentTime + MAX_SEQNUM_LIFETIME

Where the message is determined not redundant before Step 3, it MUST be forwarded or responded to. When a message is determined to be not redundant in Step 3, it MAY be suppressed to avoid extra control traffic. However, since the processing of the message will
result in an update to the Local Route Set, the message SHOULD be forwarded or responded to, to ensure other routers
have up-to-date information and the best metrics. If the message is not forwarded, the best route may not be found. Forwarding or response is to be performed using the processes outlined in [](#aodv_msgs).

## Suppressing Redundant Route Error Messages using the Route Error Set {#suppressrerr}

In order to avoid flooding the network with RERR messages when a stream of IP packets to an unreachable address arrives, an AODVv2
router SHOULD avoid creating duplicate messages by determining whether an equivalent RERR has recently been sent. This is achieved with the help of the Route Error Set (see [](#rerrtable)).

To determine if a received RERR is redundant:

1.  Search for an entry in the Route Error Set where:
    * RerrMsg.AddressList == RERR.AddressList
    * RerrMsg.PktSource == RERR.PktSource

    If a matching entry is found, no further processing is required and the RERR SHOULD NOT be sent.

2.  If no matching entry is found, a new entry with the following properties is created:
    * RerrMsg.Timeout := CurrentTime + RERR_TIMEOUT
    * RerrMsg.AddressList == RERR.AddressList
    * RerrMsg.PktSource == RERR.PktSource

## Local Route Set Maintenance  {#route_maint}

Route maintenance involves monitoring LocalRoutes in the Local Route Set, updating LocalRoute.State to handle route timeouts and
reporting routes that become Invalid.

### LocalRoute State Changes {#routestatechanges}

During normal operation, AODVv2 does not require any explicit timeouts to manage the lifetime of a route. At any time, any
LocalRoute MAY be examined and updated according to the rules below. If timers are not used to prompt updates of LocalRoute.State,
the LocalRoute.State MUST be checked before IP packet forwarding and before any operation based on LocalRoute.State.

Route timeout behaviour is as follows:

*  An Unconfirmed route MUST be expunged at MAX_SEQNUM_LIFETIME after LocalRoute.LastSeqNumUpdate.
*  An Idle route MUST become Active when used to forward an IP packet. If the route is not used to forward an IP packet within
   MAX_IDLETIME, LocalRoute.State MUST become Invalid.
*  An Invalid route SHOULD remain in the Local Route Set, since LocalRoute.SeqNum is used to classify future information about LocalRoute.Address as
   stale or fresh.
*  In all cases, if the time since LocalRoute.LastSeqNumUpdate exceeds MAX_SEQNUM_LIFETIME, LocalRoute.SeqNum must be set to
   zero. This is required to ensure that any AODVv2 routers following the initialization procedure can safely begin routing
   functions using a new sequence number. A LocalRoute with
   LocalRoute.State set to Active or Idle can remain in the Local Route Set after removing the sequence number, for exmple if the route is reliably carrying traffic. If LocalRoute.State
   is Invalid, or later becomes Invalid, the LocalRoute MUST be expunged from the Local Route Set.

LocalRoutes can become Invalid before a timeout occurs:

*  If an external mechanism reports a link as broken, all LocalRoutes using that link for LocalRoute.NextHop MUST immediately have LocalRoute.State set to Invalid.

* LocalRoute.State MUST immediately be set to Invalid if a Route Error (RERR) message is received where:
    * The sender is LocalRoute.NextHop or PktSource is a Router Client address
    * There is an Address in AddressList which matches LocalRoute.Address, and:
        * The prefix length associated with this Address, if any, matches LocalRoute.PrefixLength
        * The sequence number associated with this Address, if any, is newer or equal to LocalRoute.SeqNum (see [](#seqnum))
        * The metric type associated with this Address matches LocalRoute.MetricType



LocalRoutes are also updated when Neighbor.State is updated:

*  While the value of Neighbor.State is set to Unknown, any routes in the Local Route Set using that neighbor as a next hop MUST have
   LocalRoute.State set to Unconfirmed.
*  When the value of Neighbor.State is set to Confirmed, the Unconfirmed routes in the Local Route Set using that neighbor as a next hop MUST have
   LocalRoute.State set to Idle. Any other matching LocalRoutes with metric values worse than LocalRoute.Metric
   MUST be expunged from the Local Route Set.
*  When the value of Neighbor.State is set to Blacklisted, any valid routes in the Local Route Set using that neighbor for their next hop MUST have
   LocalRoute.State set to Invalid.
*  When a Neighbor Set entry is removed, all routes in the Local Route Set using that neighbor as next hop MUST have LocalRoute.State set to Invalid.

<!-- SUGGESTED NEW TEXT -->

Memory constrained devices MAY choose to expunge routes from the AODVv2 Local Route Set at other times, but MUST adhere to the following rules:

*   An Active route MUST NOT be expunged, as it is in use. If deleted, IP traffic forwarded to this router will prompt generation
    of a Route Error message, and it will be necessary for a Route Request to be generated by the originator's router to re-establish the route.
*   An Idle route SHOULD NOT be expunged, as it is still valid for forwarding IP traffic. If deleted, this could result in dropped
    IP packets and a Route Request could be generated to re-establish the route.
*   Any Invalid route MAY be expunged. Least recently used Invalid routes SHOULD be expunged first, since the sequence number information
    is less likely to be useful.
*   An Unconfirmed route MUST NOT be expunged if it was installed within the last RREQ_WAIT_TIME, because it may correspond to
    a route discovery in progress. A Route Reply message might be received which needs to use the LocalRoute.NextHop information.
    Otherwise, it MAY be expunged.



### Reporting Invalid Routes {#brokenrerr}

When LocalRoute.State changes from Active to Invalid as a result of a broken link or a received Route Error
(RERR) message, other AODVv2 routers MUST be informed by sending an RERR message containing details
of the invalidated route.

An RERR message MUST also be sent when an AODVv2 router receives an RREP message to forward, but the
LocalRoute to the OrigPrefix in the RREP has been lost or is marked as Invalid.

An RERR message MUST also be sent when an AODVv2 router receives an RREP message to forward, but the
LocalRoute to the OrigAddr in the RREP has been lost or is marked as Invalid.

The packet or message triggering the RERR MUST be discarded.

Generation of an RERR message is described in [](#RERR_gen).



# AODVv2 Protocol Messages  {#aodv_msgs}

AODVv2 defines four message types: Route Request (RREQ), Route Reply (RREP), Route Reply
Acknowledgement (RREP_Ack), and Route Error (RERR).

Each AODVv2 message is defined as a set of data. Rules for the generation, reception and forwarding of each message type are described in the following sections. [](#represent) discusses
how the data is mapped to [](#RFC5444) Message TLVs, Address Blocks, and Address TLVs.


## Route Request (RREQ) Message  {#RREQ_msgs}

Route Request messages are used in route discovery operations to request a route to a specified
target address.  RREQ messages have the following contents:

    +-----------------------------------------------------------------+
    |                          msg_hop_limit                          |
    +-----------------------------------------------------------------+
    |                           AddressList                           |
    +-----------------------------------------------------------------+
    |                   PrefixLengthList (optional)                   |
    +-----------------------------------------------------------------+
    |                OrigSeqNum, (optional) TargSeqNum                |
    +-----------------------------------------------------------------+
    |                           MetricType                            |
    +-----------------------------------------------------------------+
    |                           OrigMetric                            |
    +-----------------------------------------------------------------+

^[RREQ_elem::RREQ message contents]

msg_hop_limit
:   <vspace/>The remaining number of hops allowed for dissemination of the RREQ
    message.
AddressList
:   <vspace/>Contains OrigPrefix, from the Router Client entry which includes OrigAddr, the source address of the IP packet for which a route is requested, and TargPrefix, set to TargAddr, the destination address of the IP packet for which a route is requested.
PrefixLengthList
:   <vspace/>Contains OrigPrefixLen, i.e., the length, in bits, of the prefix associated with
    the Router Client entry which includes OrigAddr. If omitted, the prefix length is equal
    to OrigAddr's address length in bits.
OrigSeqNum
:   <vspace/>The sequence number associated with OrigPrefix.
TargSeqNum
:   <vspace/>A sequence number associated with an existing Invalid route to TargAddr. This MAY be included
    if available.
MetricType
:   <vspace/>The metric type associated with OrigMetric.
OrigMetric
:   <vspace/>The metric value associated with the route to OrigPrefix, as seen from the sender of the message.

### RREQ Generation  {#RREQ_gen}

An RREQ is generated when an IP packet needs to be forwarded for a Router Client, and no valid route
currently exists for the packet's destination in the Routing Information Base.

Before creating an RREQ, the router SHOULD check the Multicast Route Message Set to see if an RREQ has recently been sent for the requested
destination. If so, and the wait time for a reply has not yet been reached, the router SHOULD
continue to await a response without generating a new RREQ. If the timeout has been reached, a new
RREQ MAY be generated. If buffering is configured, incoming IP packets awaiting this route SHOULD be buffered until the
route discovery is completed.

If the limit for the rate of AODVv2 control message generation has been reached, no message SHOULD be generated.

To generate the RREQ, the router (referred to as RREQ_Gen) follows this procedure:

1.  Set msg_hop_limit := MAX_HOPCOUNT
1.  Set AddressList := {OrigPrefix, TargPrefix}
1.  For the PrefixLengthList:
    *  If OrigAddr is part of an address range configured as a Router Client, set PrefixLengthList :=
       {RouterClient.PrefixLength, null}.
    *  Otherwise, omit PrefixLengthList.
1.  For OrigSeqNum:
    *  Increment the router SeqNum as specified in [](#seqnum).
    *  Set OrigSeqNum := SeqNum.
1.  For TargSeqNum:
    *  If an Invalid route exists in the Local Route Set matching TargAddr using longest prefix matching and has a
       valid sequence number, set TargSeqNum := LocalRoute.SeqNum.
    *  If no Invalid route exists in the Local Route Set matching TargAddr, or the route doesn't have a sequence number,
       omit TargSeqNum.
1.  Include MetricType and set the type accordingly
1.  Set OrigMetric := RouterClient.Cost for the Router Client entry which includes OrigAddr

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)) which is handed to the RFC5444 multiplexer for further processing. By default, the multiplexer is instructed to multicast the message to LL-MANET- Routers on all interfaces configured for AODVv2 operation.

<!-- CEP: Issue # to be generated for moving DestOnly to the irrep draft...
  <t>If RREQ_Gen requires that only the router providing connectivity
     to TargAddr is allowed to generate an RREP, then RREQ_Gen includes
     the "Destination RREP Only" (DestOnly) TLV as part of the RFC 5444
     message header.  This also assures that RREP_Gen increments its
     sequence number.  Otherwise, (if the optional behavior is enabled)
     other AODVv2 routers MAY respond to the RREQ if they have a
     valid route to TargAddr (see <xref target="iRREP" />). </t>
  -->

### RREQ Reception  {#RREQ_rcv}

Upon receiving a Route Request, an AODVv2 router performs the following steps:

1.  Check and update the Neighbor Set according to [](#nbrupdate)
    *  If the sender has Neighbor.State set to Blacklisted, ignore this RREQ for further processing.
1.  Verify that the message contains the required data:
    msg_hop_limit, OrigPrefix, TargPrefix, OrigSeqNum, and OrigMetric,
    and that OrigPrefix and TargPrefix are valid addresses
    *  If not, ignore this RREQ for further processing.
1.  Check that the MetricType is supported and configured for use
    *  If not, ignore this RREQ for further processing.
1.  Verify that the cost of the advertised route will not exceed the maximum allowed metric
    value for the metric type (Metric \<= MAX_METRIC[MetricType] - Cost(L))
    *  If it will, ignore this RREQ for further processing.
1.  Process the route to OrigPrefix as specified in [](#processingrte)
1.  Check if the information in the message is redundant by comparing to entries in the Multicast Route Message Set, following the procedure in [](#suppress)
    *  If redundant, ignore this RREQ for further processing.
    *  If not redundant, continue processing.
1.  Check if the TargPrefix matches an entry in the Router Client Set
    *  If so, generate an RREP as specified in [](#RREP_gen).
    *  If not, continue to RREQ forwarding.

### RREQ Forwarding  {#RREQ_fwd}
By forwarding an RREQ, a router advertises that it will forward IP packets to the OrigPrefix contained in the RREQ according to the information enclosed.The router MAY choose not to
forward the RREQ, for example if the router is heavily loaded or low on energy and therefore unwilling to advertise
routing capability for more traffic. This could, however, decrease connectivity in the network or result in non-optimal paths.

The RREQ SHOULD NOT be forwarded if the limit for the rate of AODVv2 control message generation has been reached.

The procedure for RREQ forwarding is as follows:

1.  Set msg_hop_limit := received msg_hop_limit - 1
1.  If msg_hop_limit is now zero, do not continue the forwarding process
1.  Set AddressList, PrefixLengthList, sequence numbers and MetricType to the values in the
    received RREQ
1.  Set OrigMetric := LocalRoute[OrigPrefix].Metric

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)) which is handed to the RFC5444 multiplexer for further processing. By default, the multiplexer is instructed to multicast the message to LL-MANET-Routers on all interfaces configured for AODVv2 operation.  However, the forwarded RREQ can be unicast to the next hop address of the LocalRoute toward TargAddr, if known.


## Route Reply (RREP) Message  {#RREP_msgs}

When a Route Request message is received, requesting a route to a target address (TargAddr) which is configured as part of a
Router Client entry, a Route Reply message is sent in response. The RREP offers a route to TargPrefix.

RREP messages have the following contents:

    +-----------------------------------------------------------------+
    |                          msg_hop_limit                          |
    +-----------------------------------------------------------------+
    |                        AckReq (optional)                        |
    +-----------------------------------------------------------------+
    |                           AddressList                           |
    +-----------------------------------------------------------------+
    |                   PrefixLengthList (optional)                   |
    +-----------------------------------------------------------------+
    |                           TargSeqNum                            |
    +-----------------------------------------------------------------+
    |                           MetricType                            |
    +-----------------------------------------------------------------+
    |                           TargMetric                            |
    +-----------------------------------------------------------------+

^[figRREP::RREP message contents]

msg_hop_limit
:   <vspace/>The remaining number of hops allowed for dissemination of the RREP
    message.
AckReq
:   <vspace/>The address of the intended next hop of the RREP. This is included when the
    link to the next hop toward OrigPrefix is not known to be bidirectional. It indicates that an
    acknowledgement of the RREP is requested by the sender from the intended next hop (see [](#nexthopmonitoring)).
AddressList
:   <vspace/>Contains OrigPrefix and TargPrefix, the prefixes of the source and destination addresses
    of the IP packet for which a route is requested.
PrefixLengthList
:   <vspace/>Contains TargPrefixLen, i.e., the length, in bits, of the prefix associated with
    the Router Client entry which includes TargAddr. If omitted, the prefix length is equal
    to TargAddr's address length, in bits.
TargSeqNum
:   <vspace/>The sequence number associated with TargPrefix.
MetricType
:   <vspace/>The metric type associated with TargMetric.
TargMetric
:   <vspace/>The metric value associated with the route to TargPrefix, as seen from the sender of the message.


### RREP Generation  {#RREP_gen}

A Route Reply message is generated when a Route Request for
a Router Client of the AODVv2 router arrives. This is the case when
RteMsg.TargPrefix matches an entry in the Router Client Set of the AODVv2 router.

Before creating an RREP, the router SHOULD check if the corresponding RREQ is redundant, i.e.,
a Route Reply has already been generated in response to the RREQ, or if CONTROL_TRAFFIC_LIMIT has been reached. If so, the RREP SHOULD NOT be created.

The RREP will follow the path of the route to OrigPrefix. If the best route to OrigPrefix in the Local
Route Set is Unconfirmed, the link to the next hop neighbor is not yet confirmed as bidirectional (as described
in [](#nexthopmonitoring)). In this case the RREP MUST include AckReq set to the intended
next hop address. The AckReq indicates that an acknowledgement to the RREP is requested from the
intended next hop router in the form of a Route Reply Acknowledgement (RREP_Ack). If the best route to OrigAddr
in the Local Route Set is valid, the link to the next hop neighbor is already confirmed as bidirectional, and
the AckReq can be omitted.

Implementations MAY allow a number of retries of the RREP if a requested acknowledgement is not received within
RREP_Ack_SENT_TIMEOUT, doubling the timeout with each retry, up to a maximum of RREP_RETRIES, using
the same exponential backoff described in [](#route_discovery) for RREQ retries. The acknowledgement
MUST be considered to have failed after the wait time for an RREP_Ack response to the final RREP.

To generate the RREP, the router (also referred to as RREP_Gen) follows this procedure:

1.  Set msg_hop_limit := MAX_HOPCOUNT - msg_hop_limit from the received RREQ message
1.  If the link to the next hop router toward OrigPrefix is not known to
    be bidirectional, <!-- TODO: define what that means?-->include the AckReq with the address of the intended next hop router (see [](#rrep_addrblk))
1.  Set Address List := {OrigPrefix, TargPrefix}
1.  For the PrefixLengthList:
    *  If TargAddr is part of an address range configured as a Router Client, set PrefixLengthList :=
       {null, RouterClient.PrefixLength}.
    *  Otherwise, omit PrefixLengthList.
1.  For the TargSeqNum:
    *  Increment the router SeqNum as specified in [](#seqnum).
    *  Set TargSeqNum := SeqNum.
1.  Include MetricType and set the type to match the MetricType in the received RREQ message
1.  Set TargMetric := RouterClient.Cost for the Router Client entry which includes TargAddr

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)) which is handed to the RFC5444 multiplexer for further processing. If the Neighbor Set contains an entry for the neighbor stored as LocalRoute[OrigPrefix].NextHop, with Neighbor.State set to Confirmed, the multiplexer is instructed to unicast the RREP to LocalRoute[OrigPrefix].NextHop. Otherwise, it multicasts the RREP to LL-MANET-Routers. The RREP MUST be sent over the same interface on which the RREQ that triggered it was received.


### RREP Reception  {#RREP_rcv}

Upon receiving a Route Reply, an AODVv2 router performs the following steps:

1.  Verify that the message contains the required data:
    msg_hop_limit, OrigPrefix, TargPrefix, TargSeqNum, and TargMetric,
    and that OrigPrefix and TargPrefix are valid addresses
    *  If not, ignore this RREP for further processing.
1.  Check that the MetricType is supported and configured for use
    *  If not, ignore this RREP for further processing.
1.  If this RREP does not correspond to an RREQ generated or forwarded in the last RREQ_WAIT_TIME, ignore for further processing.
1.  Update the Neighbor Set according to [](#nbrupdate)
<!--    *  If the sender has Neighbor.State set to Blacklisted after the update, ignore this RREP for further processing. -->
1.  Verify that the cost of the advertised route does not exceed the maximum allowed metric
    value for the metric type (Metric \<= MAX_METRIC[MetricType] - Cost(L))
    *  If it does, ignore this RREP for further processing.
1.  If the AckReq is present, check the intended recipient of the received RREP:
    *  If there is an entry in the Router Client Set where RouterClient.IPAddress matches the address associated with the AckReq (see [](#rrep_addrblk)), the receiving router is the intended recipient. Send an acknowledgement as specified in [](#rrep_ack_msgs) and continue processing.
    *  Otherwise, ignore this RREP for further processing.
1.  Process the route to TargPrefix as specified in [](#processingrte)
1.  Check if the message is redundant by comparing to entries in the Multicast Route Message Set ([](#suppress))
    *  If redundant, ignore this RREP for further processing.
    *  If not redundant, save the information in the Multicast Route Message Set to identify future redundant
       RREP messages and continue processing.
1.  Check if the OrigPrefix matches an entry in the Router Client Set
    *  If so, no further processing is necessary.
    *  If not, continue to Step 10.
1.  Check if a valid (Active or Idle) or Unconfirmed LocalRoute exists to OrigPrefix
    *  If so, continue to RREP forwarding.
    *  If not, a Route Error message SHOULD be transmitted toward TargPrefix according to
       [](#RERR_gen) and the RREP SHOULD be discarded and not forwarded.

### RREP Forwarding  {#RREP_fwd}

A received Route Reply message is forwarded toward OrigPrefix. 
By forwarding an RREP, a router advertises that it will forward IP packets to TargPrefix.

The RREP SHOULD NOT be forwarded if CONTROL_TRAFFIC_LIMIT
has been reached. Otherwise, the router MUST forward the RREP.

The procedure for RREP forwarding is as follows:

1.  Set msg_hop_limit := received msg_hop_limit - 1
1.  If msg_hop_limit is now zero, do not continue the forwarding process
1.  If the link to the next hop router toward OrigPrefix is not known to be bidirectional, include the
    AckReq with the address of the intended next hop router
1.  Set AddressList, PrefixLengthList, TargSeqNum and MetricType to the values in the
    received RREP
1.  Set TargMetric := LocalRoute[TargPrefix].Metric

This AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)) which is handed to the RFC5444 multiplexer for further processing. If the Neighbor Set contains an entry for the neighbor stored as LocalRoute[OrigPrefix].NextHop, with Neighbor.State set to Confirmed, the multiplexer is instructed to unicast the RREP to LocalRoute[OrigPrefix].NextHop. Otherwise, it multicasts the RREP to LL-MANET-Routers. The RREP MUST be sent over LocalRoute[OrigPrefix].NextHopInterface.


## Route Reply Acknowledgement (RREP_Ack) Message  {#rrep_ack_msgs}

The Route Reply Acknowledgement is a response to a Route Reply message. When the RREP_Ack message is received by the
sender of the RREP, it confirms that the link between the two routers is bidirectional (see [](#nexthopmonitoring)).
The RREP_Ack has no further data.


<!-- TargSeqNum
     <vspace/> TargSeqNum as seen in the RREP, to allow matching with the RREP at the router
     requesting the acknowledgement. -->


### RREP_Ack Generation  {#RREP_Ack_gen}

An RREP_Ack MUST be generated if a received Route Reply includes an AckReq with an address matching
one of the receiving router's IP addresses. The RREP_Ack SHOULD NOT be generated if the limit for the rate of AODVv2
control message generation has been reached.

There is no further data in an RREP_Ack. The [](#RFC5444) representation is discussed in [](#represent).
The RREP_Ack is unicast, by default, to the source IP address of the RREP message that requested it. It MUST be sent over the same interface on which the RREP that triggered it was received.

<!-- Include the SeqNum := TargAddr's SeqNum from the RREP.  -->

### RREP_Ack Reception  {#RREP_Ack_rcv}

Upon receiving an RREP_Ack, an AODVv2 router performs the following steps:

1.   Check if the RREP_Ack was expected:

    * Check if the Multicast Route Message Set contains an entry where:
        * RteMsg.MessageType == RREP
        * RteMsg.AckReqAddr matches the source IP address of the RREP_Ack
        * RteMsg.Timestamp > CurrentTime - RREP_Ack_SENT_TIMEOUT
        * RteMsg.Interface matches the interface on which the RREP_Ack was received

     * If it does, the router cancels any associated timeouts and processing continues to Step 2.
     * Otherwise no actions are required and processing ends.
1.   Update the Neighbor Set according to [](#nbrupdate)

<!-- CEP: Need to define RREP_Ack_timeout.  To avoid handling extra
     timeouts, should specify that the RREP_Ack_timeout is verified prior
     to sending forwarding RREQs from that neighbor.
     Actually, it would make sense to put the neighbor in the blacklist
     immediately upon sending AckReq...  -->

## Route Error (RERR) Message  {#RERR_msgs}

A Route Error message is generated by an AODVv2 router to notify other AODVv2 routers of routes that
are no longer available. An RERR message has the following contents:

    +-----------------------------------------------------------------+
    |                       PktSource (optional)                      |
    +-----------------------------------------------------------------+
    |                           AddressList                           |
    +-----------------------------------------------------------------+
    |                   PrefixLengthList (optional)                   |
    +-----------------------------------------------------------------+
    |                       SeqNumList (optional)                     |
    +-----------------------------------------------------------------+
    |                          MetricTypeList                         |
    +-----------------------------------------------------------------+
^[figRERRstruct::RERR message contents]

PktSource
:   <vspace/>The source address of the IP packet triggering the RERR. If the RERR is
    triggered by a broken link, PktSource is not required.
AddressList
:   <vspace/>The addresses of the routes not available through RERR_Gen.
PrefixLengthList
:   <vspace/>The prefix lengths, in bits, associated with the routes not available through
    RERR_Gen. These values indicate whether routes represent a single device or an address range.
SeqNumList
:   <vspace/>The sequence numbers of the routes not available through RERR_Gen (where
    known).
MetricTypeList
:   <vspace/>The metric types associated with the routes not available through
    RERR_Gen.


### RERR Generation  {#RERR_gen}

A Route Error message is generated when an AODVv2 router (also referred to as RERR_Gen) needs to report that a
destination is not reachable. There are three events that cause this response:

*   When an IP packet that has been forwarded from another router, but cannot be forwarded further because there is no valid route in the
    Routing Information Base for its destination, the source of the packet needs to be informed that the route to the destination of
    the packet does not exist. The RERR generated MUST include PktSource set to the source address of the IP packet,
    and MUST contain only one unreachable address in the AddressList, i.e., the destination address of the IP packet. RERR_Gen MUST discard the
    IP packet that triggered generation of the RERR. The prefix length, sequence number and metric type SHOULD be included if known from an existing Invalid LocalRoute to the unreachable address.

*   When an RREP message cannot be forwardeded because the LocalRoute to OrigPrefix has been lost or is Invalid, RREP_Gen needs
    to be informed that the route to OrigPrefix does not exist. The RERR generated MUST include PktSource set to
    the TargPrefix of the RREP, and MUST contain only one unreachable address in the AddressList, the OrigPrefix from
    the RREP. RERR_Gen MUST discard the RREP message that triggered generation of the RERR. The prefix length, sequence number
    and metric type SHOULD be included if known from an Invalid LocalRoute to the unreachable address.

*   When a link breaks, multiple LocalRoutes may become Invalid, and the RERR generated MAY contain multiple unreachable
    addresses. The RERR MUST include MetricTypeList. PktSource is omitted. All previously
    Active LocalRoutes that used the broken link MUST be reported. The AddressList, PrefixLengthList, SeqNumList, and MetricTypeList
    will contain entries for each LocalRoute which has become Invalid. An RERR message is only sent if an Active LocalRoute
    becomes Invalid, though an AODVv2 router can also include Idle LocalRoutes that become Invalid if the configuration parameter
    ENABLE_IDLE_IN_RERR is set (see [](#other)).

    <!-- CEP: To reconsider if we re-specify local repair.. -->

The RERR SHOULD NOT be generated if CONTROL_TRAFFIC_LIMIT
has been reached.
The RERR also SHOULD NOT be generated if it is a duplicate, as determined by [](#suppressrerr).

Incidentally, if an AODVv2 router receives an ICMP error packet to or from the address of one of
its Router Clients, it forwards the ICMP packet in the same way as any other IP packet,
and will not generate any RERR message based on the contents of the ICMP packet.

To generate the RERR, the router follows this procedure:

1.  If necessary, include PktSource and set the value as given above
1.  For each LocalRoute that needs to be reported:
    *  Insert LocalRoute.Address into the AddressList.
    *  Insert LocalRoute.PrefixLength into PrefixLengthList, if known and not equal to the address
       length.
    *  Insert LocalRoute.SeqNum into SeqNumList, if known.
    *  Insert LocalRoute.MetricType into MetricTypeList.

The AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)).

If the RERR is sent in response to an undeliverable IP packet or RREP message, i.e., if PktSource is included, the RERR SHOULD be
sent unicast to the next hop on the route to PktSource. It MUST be sent over the same interface on which the undeliverable IP packet was received. If there is no route to PktSource, the RERR SHOULD be
multicast to LL-MANET-Routers. If the RERR is sent in response to a broken link, i.e., PktSource is not included, the RERR is,
by default, multicast to LL-MANET-Routers.

<!-- NOTE:  CEP:  Verify unicast delivery of IP multicast packets ... -->
<!--
    If the neighbor's IP address is
    unavailable, RERR_Gen MAY attempt layer-2 unicast delivery
    to the multicast address LL-MANET-Routers.
  -->

### RERR Reception  {#RERR_rcv}

Upon receiving a Route Error, an AODVv2 router performs the following steps:

<!-- 1.  Update the Neighbor Set according to [](#nbrupdate) -->
<!-- If the sender is blacklisted ([](#nbrlist)), check the entry's remove time
    *  If CurrentTime \< Remove Time, ignore this RERR for further processing.
    *  If CurrentTime >= Remove Time, reset the neighbor state to Unknown and continue to Step 2. -->
1.  Verify that the message contains the required data: at least one
    unreachable address
    *  If not, ignore this RERR for further processing.
1.  For each address in the AddressList, check that:
    *  The address is valid (routable and unicast)
    *  The MetricType is supported and configured for use
    *  There is a LocalRoute with the same MetricType matching the address using
       longest prefix matching
    *  Either the LocalRoute's next hop is the sender of the RERR and the next hop interface is
       the interface on which the RERR was received, or PktSource is present in the RERR
       and is a Router Client address
    *  The unreachable address' sequence number is either unknown, or is greater than the
       LocalRoute's sequence number

    If any of the above are false the address does not match a LocalRoute and MUST NOT be processed or regenerated in a RERR.

    If all of the above are true, the LocalRoute which matches the address is no longer valid. If the LocalRoute was previously Active, it MUST be reported in a regenerated RERR. If the LocalRoute was previously Idle, it MAY be reported in a regenerated RERR, if ENABLE_IDLE_IN_RERR is configured. The Local Route Set MUST be updated according to these rules:

    *  If the LocalRoute's prefix length is the same as the unreachable address' prefix length,
       set LocalRoute.State to Invalid.
    *  If the LocalRoute's prefix length is longer than the unreachable address' prefix length,
       the LocalRoute MUST be expunged from the Local Route Set, since it is a sub-route of the
       route which is reported to be Invalid.
    *  If the prefix length is different, create a new LocalRoute with the unreachable address,
       and its prefix length and sequence number, and set LocalRoute.State to Invalid.
       These Invalid routes are retained to avoid processing stale messages.
    *  Update the sequence number on the existing LocalRoute, if the reported sequence number is
       determined to be newer using the comparison technique described in [](#seqnum).

1.  If there are previously Active LocalRoutes that MUST be reported, as identified in step 2.:
    *  Regenerate the RERR as detailed in [](#RERR_regen).

### RERR Regeneration  {#RERR_regen}

The Route Error message SHOULD NOT be regenerated if CONTROL_TRAFFIC_LIMIT has been reached.

The procedure for RERR regeneration is as follows:

1.  If PktSource was included in the original RERR, and PktSource is not a Router Client, copy it into the
    regenerated RERR
1.  For each LocalRoute that needs to be reported as identified in [](#RERR_gen):
    *  Insert LocalRoute.Address into the AddressList.
    *  Insert LocalRoute.PrefixLength into PrefixLengthList, if known and not equal to the address
       length.
    *  Insert LocalRoute.SeqNum into SeqNumList, if known.
    *  Insert LocalRoute.MetricType into MetricTypeList.

The AODVv2 message is used to create a corresponding [](#RFC5444) message (see [](#represent)). If the RERR contains
PktSource, the regenerated RERR SHOULD be sent unicast to the next hop on the LocalRoute to PktSource. It MUST be sent over the same interface on which the undeliverable IP packet was received.
If there is no route to PktSource, or PktSource is a Router Client, it SHOULD be multicast to LL-MANET-Routers.
If the RERR is sent in response to a broken link, the RERR is, by default, multicast to LL-MANET-Routers.

# RFC 5444 Representation  {#represent}

AODVv2 specifies that all control messages between routers MUST use the Generalized
Mobile Ad Hoc Network Packet/Message Format [](#RFC5444), and therefore AODVv2's route messages
comprise data which is mapped to message elements in [](#RFC5444).

[](#RFC5444) provides a multiplexed transport for multiple protocols. An [](#RFC5444) implementation MAY choose to optimize the content of certain elements during message creation to reduce control message overhead.

A brief summary of the [](#RFC5444) format:

1.   A packet contains zero or more messages
1.   A message contains a Message Header, one Message TLV Block, zero or more Address Blocks,
     and one Address Block TLV Block per Address Block
1.   The Message TLV Block MAY contain zero or more Message TLVs
1.   An Address Block TLV Block MAY include zero or more Address Block TLVs
1.   Each TLV value in an Address Block TLV Block can be associated with all of the
     addresses, or with a contiguous set of addresses, or with a single address in the Address Block

AODVv2 does not require access to the [](#RFC5444) packet header.

In the message header, AODVv2 uses \<msg-type\>, \<msg-hop-limit\> and
\<msg-addr-length\>. The \<msg-addr-length\> field indicates the length of any addresses in the message,
using \<msg-addr-length\> := (address length in octets - 1), i.e. 3 for IPv4 and 15 for IPv6.

The addresses in an Address Block MAY appear in any order, and values in a TLV in the Address Block
TLV Block must be associated with the correct address in the Address Block by the [](#RFC5444) implementation.
To indicate which value is associated with each address, the AODVv2 message representation uses lists where
the order of the addresses in the AODVv2 AddressList matches the order of values in other data lists, e.g., the
order of SeqNums in the SeqNumList in an RERR. [](#RFC5444) maps this information to Address Block TLVs associated
with the relevant addresses in the Address Block.

Each address included in the Address Block is identified as OrigPrefix, TargPrefix, PktSource, or
Unreachable Address by including an ADDRESS_TYPE TLV in the Address Block TLV Block.

The following sections show how AODVv2 data is represented in [](#RFC5444) messages. AODVv2 defines (in [](#addrtlvspec)) a number of new TLVs.

<!-- Deleted / Issue #28 - - >
  <t> When multiple messages are aggregated into a single packet according
      to RFC 5444 formatting, and the aggregation of messages is also
      authenticated (e.g., with IPsec), and the IP destination is multiple
      hops away, it becomes infeasible to delete individual messages.  In such
      cases, instead of deleting individual messages, they are maintained
      in the aggregation of messages, but simply ignored for further
      processing.  In such cases where individual messages cannot be
      deleted, in this document "disregarded" means "ignored".  Otherwise,
      any such "disregarded" AODVv2 messages SHOULD be deleted from
      the aggregated messages in the RFC 5444 packet.  </t>
< ! - - Deleted / Issue #28 -->

Where the extension type of a TLV is set to zero, this is the default [](#RFC5444) value and the extension type
will not be included in the message.


## Route Request Message Representation

### Message Header

Data           Header Field       Value
------------   ---------------    -----
None           \<msg-type\>       RREQ
msg_hop_limit  \<msg-hop-limit\>  MAX_HOPCOUNT, reduced by number of hops traversed so far by the message.

### Message TLV Block

AODVv2 does not define any Message TLVs for an RREQ message.

### Address Block
An RREQ contains two addresses, OrigPrefix and TargPrefix, and each address has an associated prefix length. If the prefix length has not been included in the AODVv2 message, it is equal to the address length in bits.

Data                        Address Block
-------------               ---------------
OrigPrefix\/OrigPrefixLen   \<address\> + \<prefix-length\>
TargPrefix\/TargPrefixLen   \<address\> + \<prefix-length\>

### Address Block TLV Block
Address Block TLVs are always associated with one or more addresses in the Address Block. The following
sections show the TLVs that apply to each address.

#### Address Block TLVs for OrigPrefix

Data                     TLV Type       Extension Type  Value
------------             ------------   --------------  -----
None                     ADDRESS_TYPE   0               ADDRTYPE_ORIGPREFIX
OrigSeqNum               SEQ_NUM        0               Sequence number of RREQ_Gen, the router which initiated route discovery.
OrigMetric \/MetricType  PATH_METRIC    MetricType      Metric value for the route to OrigPrefix, using MetricType.

#### Address Block TLVs for TargPrefix

Data                     TLV Type       Extension Type  Value
------------             ------------   --------------  -----
None                     ADDRESS_TYPE   0               ADDRTYPE_TARGPREFIX
TargSeqNum               SEQ_NUM        0               The last known TargSeqNum for TargPrefix.

## Route Reply Message Representation

### Message Header

Data            Header Field       Value
------------    ---------------    -----
None            \<msg-type\>       RREP
msg_hop_limit   \<msg-hop-limit\>  MAX_HOPCOUNT - msg_hop_limit from the corresponding RREQ, reduced by number of hops traversed so far by the message.

### Message TLV Block

AODVv2 does not define any Message TLVs for an RREP message.

### Address Block {#rrep_addrblk}

An RREP contains a minimum of two addresses, OrigPrefix and TargPrefix, and each address has an associated prefix length. If the prefix length
has not been included in the AODVv2 message, it is equal to the address length in bits.

It MAY also contain the address of the intended next hop, in order to request acknowledgement to confirm bidirectionality of the link, as described
in [](#nexthopmonitoring). The prefix length associated with this address is equal to the address length in bits.

Data                        Address Block
-------------               ---------------
OrigPrefix\/OrigPrefixLen   \<address\> + \<prefix-length\>
TargPrefix\/TargPrefixLen   \<address\> + \<prefix-length\>
AckReq                      \<address\> + \<prefix-length\>

### Address Block TLV Block
Address Block TLVs are always associated with one or more addresses in the Address Block. The following
sections show the TLVs that apply to each address.

#### Address Block TLVs for OrigPrefix

Data                     TLV Type       Extension Type        Value
------------             ------------   --------------        -----
None                     ADDRESS_TYPE   0                     ADDRTYPE_ORIGPREFIX

#### Address Block TLVs for TargPrefix

Data                      TLV Type       Extension Type         Value
------------              ------------   --------------         -----
None                      ADDRESS_TYPE   0                      ADDRTYPE_TARGPREFIX
TargSeqNum                SEQ_NUM        0                      Sequence number of RREP_Gen, the router which created the RREP.
TargMetric \/MetricType   PATH_METRIC    MetricType             Metric value for the route to TargPrefix, using MetricType.


#### Address Block TLVs for AckReq Intended Recipient Address

Data                     TLV Type       Extension Type        Value
------------             ------------   --------------        -----
None                     ADDRESS_TYPE   0                     ADDRTYPE_INTEND

## Route Reply Acknowledgement Message Representation

### Message Header

Data           Header Field       Value
------------   ---------------    -----
None           \<msg-type\>       RREP_Ack

### Message TLV Block

AODVv2 does not define any Message TLVs for an RREP_ack message.

### Address Block
AODVv2 does not define an Address Block for an RREP_Ack message.

### Address Block TLV Block
AODVv2 does not define any Address Block TLVs for an RREP_Ack message.



## Route Error Message Representation

Route Error Messages MAY be split into multiple [](#RFC5444) messages when the desired contents would exceed the MTU. However,
all of the resulting messages MUST have the same message header as described
below. If PktSource is included in the AODVv2 message, it MUST be included in
all of the resulting [](#RFC5444) messages.

### Message Header

Data           Header Field       Value
------------   ---------------    -----
None           \<msg-type\>       RERR

### Message TLV Block
AODVv2 does not define any Message TLVs for an RERR message.

### Address Block
The Address Block in an RERR MAY contain PktSource, the source address of the IP packet triggering
RERR generation, as detailed in [](#RERR_msgs). The prefix length associated with PktSource is equal to the
address length in bits.

Address Block always contains one address per route that is no longer valid, and each address
has an associated prefix length.  If a prefix length has not been included for this address, it is equal
to the address length in bits.

Data                            Address Block
------------                    ---------------
PktSource                       \<address\> + \<prefix-length\> for PktSource
AddressList\/PrefixLengthList   \<address\> + \<prefix-length\> for each unreachable address in AddressList


### Address Block TLV Block
Address Block TLVs are always associated with one or more addresses in the Address Block. The following
sections show the TLVs that apply to each type of address in the RERR.

#### Address Block TLVs for PktSource

Data           TLV Type      Extension Type Value
------------   --------      -------------- -----
PktSource      ADDRESS_TYPE  0              ADDRTYPE_PKTSOURCE

#### Address Block TLVs for Unreachable Addresses

Data                      TLV Type     Extension Type Value
------------              --------     -------------- -----
None                      ADDRESS_TYPE 0              ADDRTYPE_UNREACHABLE
SeqNumList                SEQ_NUM      0              Sequence number associated with invalid route to the unreachable address.
MetricTypeList            PATH_METRIC  MetricType     None. Extension Type set to MetricType of the route to the unreachable address.


# Simple External Network Attachment  {#gateway}

[](#net_top) shows a stub (i.e., non-transit) network of AODVv2 routers which is attached to an external network via a single External Network Access Router (ENAR). The interface to the external network MUST NOT be configured in the InterfaceSet. <!-- TODO: if there's only one Interface, is this a MUST?-->

As in any externally-attached network, AODVv2 routers and Router Clients that wish to be reachable from the external network MUST have IP addresses within the ENAR's routable and topologically correct prefix (e.g., 191.0.2.0/24 in [](#net_top)). This AODVv2 network and networks attached to routers within it will be advertised to the external network using procedures which are out of scope for this specification.


      /-------------------------\
     / +----------------+        \
    /  |  AODVv2 Router |         \
    |  |  191.0.2.2/32  |         |
    |  +----------------+         |            Routable
    |                       +-----+--------+   Prefix
    |                       |     ENAR     |  /191.0.2.0/24
    |                       | AODVv2 Router| /
    |                       |  191.0.2.1   |/      /---------------\
    |                       | serving net  +------+    External     \
    |                       | 191.0.2.0/24 |      \     Network     /
    |                       +-----+--------+       \---------------/
    |         +----------------+  |
    |         |  AODVv2 Router |  |
    |         |  191.0.2.3/32  |  |
    \         +----------------+  /
     \                           /
      \-------------------------/
^[net_top::Simple External Network Attachment Example]

When an AODVv2 router within the AODVv2 MANET wants to discover a route toward an address on the external network, it uses the normal AODVv2 route discovery for that IP Destination Address. The ENAR MUST respond to RREQ on behalf of all external network destinations, e.g., destinations not on the configured 191.0.2.0/24 network. RREQs for addresses inside the AODVv2 network, e.g. destinations on the configured 191.0.2.0/24 network, are handled using the standard processes described in [](#aodv_msgs). Note that AODvv2 does not support RREQs for prefixes that do not equal address length.

When an IP packet from an address on the external network destined for an address in the AODVv2 MANET reaches the
ENAR, if the ENAR does not have a route toward that destination in its Routing Information Base, it will perform normal
AODVv2 route discovery for that destination.

Configuring the ENAR as a default router is outside the scope of this specification.

# Configuration  {#param}

AODVv2 uses various parameters which can be grouped into the following categories:

*  Timers
*  Protocol constants
*  Administrative parameters and controls

This section show the parameters along with their definitions and default values (if any).

Note that several fields have limited size (bits or bytes). These sizes and their encoding may
place specific limitations on the values that can be set.

## Timers  {#timers}

AODVv2 requires certain timing information to be associated with Local Route Set entries and
message replies. The default values are as follows:

Name                                   Default Value
------                                 ------------
ACTIVE_INTERVAL                        5 second
MAX_IDLETIME                           200 seconds
MAX_BLACKLIST_TIME                     200 seconds
MAX_SEQNUM_LIFETIME                    300 seconds
RERR_TIMEOUT                           3 seconds
RteMsg_ENTRY_TIME                      12 seconds
RREQ_WAIT_TIME                         2 seconds
RREP_Ack_SENT_TIMEOUT                  1 second
RREQ_HOLDDOWN_TIME                     10 seconds

^[timer-tbl::Timing Parameter Values]

The above timing parameter values have worked well for small and medium well-connected
networks with moderate topology changes. The timing parameters SHOULD be administratively
configurable. Ideally, for networks with frequent topology changes the AODVv2 parameters
SHOULD be adjusted using experimentally determined values or dynamic adaptation. For example, in networks with infrequent topology changes MAX_IDLETIME MAY be set to a much larger value.
If the values were configured differently, the following consequences may be observed:

* If MAX_SEQNUM_LIFETIME was configured differently across the network, and any of the routers lost their sequence number or rebooted, this could result in their next route messages being
classified as stale at any AODVv2 router using a greater value for MAX_SEQNUM_LIFETIME. This would
delay route discovery from and to the re-initializing router.
* Routers with lower values for ACTIVE_INTERVAL + MAX_IDLETIME will invalidate routes more quickly and free resources used to maintain them. This can affect bursty traffic flows which have quiet periods longer than ACTIVE_INTERVAL + MAX_IDLETIME. A route which has timed out due to perceived inactivity is not reported. When the bursty traffic resumes, it would cause a RERR to be generated, and the traffic itself would be dropped. This route would be removed from all upstream routers, even if those upstream routers had larger ACTIVE_INTERVAL or MAX_IDLETIME values. A new route discovery would be required to re-establish the route, causing extra routing protocol traffic and disturbance to the bursty traffic.
* Routers with lower values for MAX_BLACKLIST_TIME would allow neighboring routers to participate in route discovery sooner than routers with higher values. This could result in failed route discoveries if un-blacklisted links are still uni-directional. Since RREQs are retried, this would not affect success of route discovery unless this value was so small as to un-blacklist the router before the RREQ is retried. This value need not be consistent across the network since it is used for maintaining a 1-hop blacklist. However it MUST be greater than RREQ_WAIT_TIME.
<!-- TODO: [and probably a good idea to be at least a multiple of RREQ_WAIT_TIME?] -->
* Routers with lower values for RERR_TIMEOUT may create more RERR messages than routers with higher values. This value should be large enough that a RERR will reach all routers using the route reported within it before the timer expires, so that no further data traffic will arrive, and no duplicated RERR messages will be generated.
* Routers with lower values for RteMsg_ENTRY_TIME may not consider received redundant multicast route messages as redundant, and may forward these messages unnecessarily.
* Routers with lower values for RREQ_WAIT_TIME may send more frequent RREQ messages and wrongly determine that a route does not exist, if the delay in receiving an RREP is greater than this interval.
* Routers with lower values for RREP_Ack_SENT_TIMEOUT may wrongly determine links to neighbors to be unidirectional if an RREP_Ack is delayed longer than this timeout.
* Routers with lower values for RREQ_HOLDDOWN_TIME will retry failed route discoveries sooner than routers with higher values. This may be an advantage if the network topology is frequently changing, or may unnecessarily cause more routing protocol traffic.

MAX_SEQNUM_LIFETIME MUST be configured to have the same values for all AODVv2 routers in the network.


## Protocol Constants  {#constants}

AODVv2 protocol constants typically do not require changes. The following table lists these
constants, along with their values and a reference to the section describing their use.

Name                      Default   Description
---                       -------   ----------
DISCOVERY_ATTEMPTS_MAX    3         [](#route_discovery)
RREP_RETRIES              2         [](#RREP_gen)
MAX_METRIC[MetricType]    [TBD]     [](#metrics)
MAX_METRIC[HopCount]      255       [](#metrics) and [](#aodv_msgs)
MAX_HOPCOUNT              20        Limit to number of hops an RREQ or RREP message can traverse
INFINITY_TIME             [TBD]     Maximum expressible clock time ([](#update_rte))

^[const-tbl::AODVv2 Constants]

<!-- Need to figure out what the time format. -->

MAX_HOPCOUNT cannot be larger than 255.

MAX_METRIC[MetricType] MUST always be the maximum expressible metric value of type MetricType.
Field lengths associated with metric values are found in [](#metric-type).

These protocol constants MUST have the same values for all AODVv2 routers in the ad hoc
network.  If the values were configured differently, the following consequences may be observed:

*  DISCOVERY_ATTEMPTS_MAX: Routers with higher values are likely to be more successful at finding
   routes, at the cost of additional control traffic.
*  RREP_RETRIES: Routers with lower values are more likely to blacklist neighbors when there is a temporary fluctuation in link quality.
*  MAX_METRIC[MetricType]: No interoperability problems due to variations on different routers, but
   routers with lower values may exhibit overly restrictive behavior during route comparisons.
*  MAX_HOPCOUNT: Routers with a value too small would not be able to discover routes to distant addresses.
*  INFINITY_TIME: No interoperability problems due to variations on different routers, but if a
   lower value is used, route state management may exhibit overly restrictive behavior.

## Local Settings {#other}
The following table lists AODVv2 parameters which SHOULD be administratively configured for each router:

Name                      Default Value             Description
---                       ------------              --------------
InterfaceSet                                        [](#interfaceslist)
BUFFER_SIZE_PACKETS       2                         [](#route_discovery)
BUFFER_SIZE_BYTES         MAX_PACKET_SIZE [TBD]     [](#route_discovery)
CONTROL_TRAFFIC_LIMIT     [TBD - 50 pkts/sec?]      [](#aodv_msgs)

^[admincontrol::Configuration for Local Settings]

## Network-Wide Settings
The following administrative controls MAY be used to change the operation of the network. The same
settings SHOULD be used across the network. Inconsistent settings at different routers in the network
will not result in protocol errors, but poor performance may result.

Name                       Default               Description
------                     --------              ----------
ENABLE_IDLE_IN_RERR        Disabled              [](#RERR_gen)

^[suggestedoptions::Configuration for Network-Wide Settings]

## MetricType Allocation  {#metric-type}

The metric types used by AODVv2 are identified according to [](#metric-tbl).  All implementations MUST use these values.


Name of MetricType        Type                     Metric Value Size
--------------------      ------                   -------------
Unassigned                0                        Undefined
Hop Count                 1                        1 octet
Unallocated               2 - 254                  TBD
Reserved                  255                      Undefined

^[metric-tbl::AODVv2 Metric Types]

## RFC 5444 Message Type Allocation {#msgtype}

This specification defines four Message Types, to be allocated from the Experimental range of the "Message Types" namespace defined in [](#RFC5444), as specified in [](#msgtypes).

Name of Message                        Type
------------------------               ------
Route Request (RREQ)                   224
Route Reply (RREP)                     225
Route Error (RERR)                     226
Route Reply Acknowledgement (RREP_Ack) 227

^[msgtypes::AODVv2 Message Types]

If the AODVv2 experiment proves to be successful, types from the 0-223 range can be allocated in the future.

## RFC 5444 Address Block TLV Type Allocation {#addrtlvspec}

This specification defines three Address Block TLV Types, to be allocated from the Message-Type-specific  
"Address Block TLV Types" namespace defined in [](#RFC5444), as specified in [](#addrtlvtypes).

----------------------------------------------------------------------
Name of TLV                   Type      Length (octets) Reference
--------------------------    --------  ----------      --------------
PATH_METRIC                   128 (TBD)  depends on      [](#aodv_msgs)
                                        MetricType

SEQ_NUM                       129 (TBD)  2               [](#aodv_msgs)

ADDRESS_TYPE                  130 (TBD)  1               [](#represent)
----------------------------------------------------------------------
^[addrtlvtypes::AODVv2 Address Block TLV Types]

## ADDRESS_TYPE TLV Values {#address-type}

These values are used in the [](#RFC5444) Address Type TLV discussed in [](#represent).
All implementations MUST use these values.

Address Type            Value
------------            -----
ORIGPREFIX              0
TARGPREFIX              1
UNREACHABLE             2
PKTSOURCE               3
INTEND                  4
UNSPECIFIED             255

^[addrtype-tbl::AODVv2 Address Types]

# IANA Considerations  {#IANA}

This document has no IANA actions.

# Security Considerations  {#Security}

<!-- security considerations revisions...

Protocol changes to support ICV:
- Should make a new type extension (TBD ?= 2?) for TIMESTAMP TLV
- RERR includes its SeqNum as the timestamp field value
- RREP_Ack includes TargSeqNum as the timestamp field value
- RERR receivers have to keep track of the neighbor's SeqNum
- RREP_Ack receivers have to keep track of which TargSeqNum was sent in
  the RREP

I picked these as the handiest strictly increasing values available for use.
Other designs are possible.
  -->

This section describes various security considerations and potential
avenues to secure AODVv2 routing.  The main objective of the AODVv2
protocol is for each router to communicate reachability information
about addresses for which it is responsible, and for routes it has
learned from other AODVv2 routers.

Networks using AODVv2 to maintain connectivity and establish routes
on demand may be vulnerable to certain well-known types of threats,
which will be detailed in the following. Some of the threats described
can be mitigated or eliminated. Tools to do so will be described also.

<!--
TODO:
   "The threat environment addressed by the Security Considerations
   section MUST at a minimum include deployment across the global
    Internet across multiple administrative boundaries without assuming
    that firewalls are in place, even if only to provide justification
    for why such consideration is out of scope for the protocol."
-->

With the exception of metric values, AODVv2 assures the integrity of all RteMsg data end-to-end though the use of ICVs (see [](#security-protection-integrity).

The on-demand nature of AODVv2 route discovery automatically reduces
the vulnerability to route disruption. Since control traffic for
updating route tables is diminished, there is less opportunity for
attack and failure.


## Availability {#security-availability}

Threats to AODVv2 which reduce availability are considered below.

### Denial of Service {#security-availability-dos}

Flooding attacks using RREQ amount to a (BLIND) denial of service for route discovery: By issuing RREQ messages for targets that don't exist, an attacker can flood the network, blocking resources and drowning out legitimate traffic. The effect of this attack is dampened by the
fact that duplicate RREQ messages are dropped (preventing the network from DDoSing itself). Processing requirements for AODVv2 messages are typically quite small, however AODVv2 routers receiving RREQs do allocate resources in the form of Neighbor Set, Local Route Set and Multicast Route Message Set entries. The attacker can maximize their impact on set growth by changing OrigPrefix or OrigPrefixLen for each RREQ. If a specific node is to be targeted, this attack may be carried out in a DISTRIBUTED fashion, either by compromising its direct neighbors or by specifying the target's address with TargPrefix and TargPrefixLen.
Note that it might be more economical for the attacker to simply jam the medium; an attack which AODVv2 cannot defend itself against.

Mitigation:

*   If AODVv2 routers always verify that the sender of the RERR message
    is trusted, this threat is reduced. Processing requirements would typically be dominated by calculations to verify integrity.
    This has the effect of reducing (but by no means eliminating) AODVv2's vulnerability to denial of service attacks.
*   Authentication of senders can prevent foreign nodes from DoSing an
    AODVv2 router. However, this does not protect the network if an attacker has access to an already authorized router.

### Malicious RERR messages {#security-availability-rerr}

RERR messages are designed to cause removal of installed routes. A malicious node could
send an RERR message with false information to attempt to get other routers to remove a
route to one or more specific destinations, therefore disrupting traffic to the advertised
destinations.

Routes will be deleted if an RERR is received, withdrawing a route for which the sender is
the receiver's next hop, and when the RERR includes the MetricType of the installed route,
and includes either no sequence number for the route, or includes a greater sequence number
than the sequence number stored with that route in the receiver's Local Route Set. Routes
will also be deleted if a received RERR contains a PktSource address corresponding to a Router
Client.

The information necessary to construct a malicious RERR could be learned by eavesdropping,
either by listening to AODVv2 messages or by watching data packet flows.

Since the RERR is multicast, it can be received by many routers in the ad hoc network, and will
be regenerated when processing results in an active route being removed. This threat could
have serious impact on applications communicating by way of the sender of the RERR message.

*  The set of routers which use the malicious router as a next hop may be targeted with
    a malicious RERR with no PktSource address included, if the RERR contains routes for which
    the malicious router is a next hop from the receiving router. However, since the sender of
    the RERR message is either malicious or broken, it is better that it is not used as a next
    hop for these routes anyway.
*  A single router which does not use the malicious router as part of its route may be targeted
    with a malicious RERR with a PktSource address included.
*   Replayed RERR messages could be used to disrupt active routes.

Mitigation:

*   Protection against eavesdropping of AODVv2 messages would mitigate this attack to some extent,
    but eavesdropping of data packets can also be used to deduce the information about which routes
    could be targeted.
*   Protection against a malicious router becoming part of a route will mitigate the attack where a
    set of routers are targeted. This will not protect against the attack if a PktSource address is
    included.
*   By only regenerating RERR messages where active routes are removed, the spread of the malicious
    RERR is limited.
*   Including sequence numbers in RERR messages offers protection against attacks using replays of
    these RERR messages.
*   If AODVv2 routers always verify that the sender of the RERR message is trusted, this threat is
    reduced.

### False Confirmation of Link Bidirectionality {#security-availability-bidirectionality}

Links could be erroneously treated as bidirectional if malicious unsolicited or spoofed RREP
messages were to be accepted. This would result in a route being installed which could
not in fact be used to forward data to the destination, and may divert data packets away from the
intended destination.

There is a window of RREQ_WAIT_TIME after an RREQ is sent, in which any malicious router could
send an RREP in response, in order for the link to the malicious router to be deemed as
bidirectional.

Mitigation:

*   Ignoring unsolicited RREP and RREP_Ack messages partially mitigates against this threat.
*   If AODVv2 routers always verify that the sender of the RERR message is trusted, this threat is
reduced.

### Message Deletion {#security-availability-deletion}

A malicious router could decide not to forward an RREQ or RREP or RERR message. Not forwarding a
RERR or RREP message would disrupt route discovery. Not regenerating a RERR message would result in the
source of data packets continuing to maintain and use the route, and further RERR messages being generated
by the sender of the non-regenerated RERR. A malicious router could intentionally disrupt traffic flows by
not allowing the source of data traffic to re-discover a new route when one breaks.

Failing to send an RREP_Ack would also disrupt route establishment, by not allowing the reverse route to be
validated. Return traffic which needs that route will prompt a new route discovery, wasting resources and
incurring a slight delay but not disrupting the ability for applications to communicate.

Mitigation:

* None. also note that malicious router would have to wait for a route to break before it could perform this attack.

## Confidentiality {#security-confidentiality}

Passive inspection (eavesdropping) of AODVv2 control messages could enable unauthorized devices to gain
information about the network topology, since exchanging such information is the main purpose of AODVv2.

Eavesdropping of data traffic could allow a malicious device to obtain information about how data traffic
is being routed. With knowledge of source and destination addresses, malicious messages could be constructed
to disrupt normal operation.

## Integrity {#security-integrity}

Integrity of route information can be compromised in the following types of attack:

### Message Insertion {#security-integrity-insertion}

Valid route set entries can be replaced or modified by maliciously constructed AODVv2 messages, destroying
existing routes and the network's integrity. Any router may pose as another router by sending RREQ, RREP,
RREP_Ack and RERR messages in its name.

*  Sending an RREQ message with false information can disrupt traffic to OrigPrefix, if the sequence
    number attached is not stale compared to any existing information about OrigPrefix. Since RREQ
    is multicast and likely to be received by all routers in the ad hoc network, this threat
    could have serious impact on applications communicating with OrigPrefix. The actual threat
    to disrupt routes to OrigPrefix is reduced by the AODVv2 mechanism of marking RREQ-derived
    routes as "Unconfirmed" until the link to the next hop is confirmed.

*  Sending an RREP message with false information can disrupt traffic to TargPrefix. Since RREP
    is unicast, and ignored if a corresponding RREQ was not recently sent, this threat is minimized,
    and is restricted to receivers along the path from OrigAddr to TargAddr.

*  Sending an RREP_Ack message with false information can cause the route advertised to a target
    address in an RREP to be erroneously accepted even though the route would contain a unidirectional
    link and thus not be suitable for most traffic. Since RREP_Ack is unicast, and ignored if an RREP was
    not sent recently to the sender of the RREP_Ack, this threat is minimized and is strictly local
    to the RREP transmitter expecting the acknowledgement. Unsolicited RREP_Acks are ignored.

*  Sending an RERR message with false information is discussed in [](#security-availability-rerr).

Mitigation:

*   If AODVv2 routers always verify that the sender of a message is trusted, this threat is
reduced.


### Message Modification - Man in the Middle {#security-integrity-mitm}

Any AODVv2 router can forward messages with modified data.

Mitigation:

*   If AODVv2 routers verify the integrity of AODVv2 messages, then the threat of disruption is minimized. A
man in the middle with no knowledge of the shared secret key used to calculate an integrity check value
MAY modify a message but the message will be rejected when it fails an integrity check.

### Replay Attacks {#security-integrity-relay}

Replaying of RREQ or RREP messages would be of less use to an attacker, since they would be
dropped immediately due to their stale sequence number. RERR messages MAY or MAY NOT include
sequence numbers and are therefore susceptible to replay attacks. RREP_Ack messages do not
include sequence numbers and are therefore susceptible to replay attacks.

Mitigation:

*   Use of timestamps or sequence numbers prevents replay attacks.

## Protection Mechanisms {#security-protection}

### Confidentiality and Authentication {#security-protection-confidentiality}

Encryption MAY be used for AODVv2 messages.  If the routers share a
packet-level security association, the message data can be encrypted
prior to message transmission.  The establishment of such security
associations is outside the scope of this specification.  Encryption
will not only protect against unauthorized devices obtaining
information about network topology (eavesdropping) but will ensure that
only trusted routers participate in routing operations.

### Integrity and Trust using ICVs {#security-protection-integrity}

Cryptographic Integrity Check Values (ICVs) can be used to ensure integrity of received messages,
protecting against man in the middle attacks. Further, by using ICVs, only those routers with knowledge
of a shared secret key are allowed to participate in routing information exchanges. [](#RFC7182) defines
ICV TLVs for use with [](#RFC5444).

The data contained in AODVv2 routing protocol messages MUST be verified using Integrity Check
Values, to avoid the use of message data if the message has been tampered with.

The method of distribution of shared secret keys is out of the scope of this protocol. Key
management is not specified for the following reasons:

<!--
TODO (like OLSRv2 section 23.6)
-->

### Replay Protection using Timestamps {#security-protection-replay}

Replay attacks MUST be prevented by using timestamps or sequence numbers in messages. [](#RFC7182) defines a
TIMESTAMP TLV for use with [](#RFC5444).

The data contained in AODVv2 routing protocol messages MUST be protected with a TIMESTAMP value
to ensure the protection against replaying of the message. Sequence numbers can be used as
timestamps, since they are known to be strictly increasing.

### Application to AODVv2 {#security-protection-application}

<!--
TODO: choose HASH_FUNCTION and CRYPTOGRAPHIC_FUNCTION.
-->

AODVv2 implementations MUST support ICV and TIMESTAMP TLVs, unless the implementation is intended solely for an environment in which security is unnecessary. AODVv2 deployments SHOULD be configured to use these TLVs to secure messages. 

Implementations of AODVv2 MUST support ICV TLVs using type-extensions 1 and 2,
hash-function HASH_FUNCTION, and cryptographic function CRYPTOGRAPHIC_FUNCTION. An ICV
MUST be included with every message. The ICV value MAY be truncated as specified in [](#RFC7182).

Implementations of AODVv2 MUST support a TIMESTAMP TLV using type-extension 0. The timestamp used
is a sequence number, and therefore the length of the \<TIMESTAMP-value\> field matches the AODVv2
sequence number defined in [](#seqnum). The TIMESTAMP TLV MUST be included in RREP_Ack and RERR
messages.

When more than one message is included in an RFC5444 packet, using a single ICV Packet TLV or
single TIMESTAMP Packet TLV is more efficient than including ICV and TIMESTAMP Message TLVs in
each message created. If the RFC5444 multiplexer is capable of adding the Packet TLVs, it SHOULD 
be instructed to include the Packet TLVs in packets containing AODVv2 messages. However, if the 
multiplexer is not capable of adding the Packet TLVs, the TLVs MUST be included as Message TLVs 
in each AODVv2 message in the packet.

After message generation but before transmission, the ICV and TIMESTAMP TLVs MUST be added
according to each message type as detailed in the following sections. The following steps list the
generic procedure to be performed:

1.  The considerations in Section 8 of [](#RFC7182) are followed, removing existing ICV TLVs
    and adjusting the size and flags fields.

2. The ICV is calculated over the fields specified below, depending on message type. This value
    MAY be truncated (as specified in [](#RFC7182)).

3. If the TIMESTAMP is to be included, add the TIMESTAMP TLV, updating size fields as necessary.

4. Add the ICV TLV, updating size fields as necessary.

5. The changes made in Step 1 are reversed to re-add any existing ICV TLVs and adjusting the
    size and flags fields.

The ICV MUST be verified at the receiver. Verification of a received ICV value is performed by
repeating Step 1 and Step 2. If the ICV value calculated from the received message or packet does
not match the value of \<ICV-data\> in the received message or packet, the validation fails and the
AODVv2 message MUST be discarded.

Verification of a received TIMESTAMP value is performed differently depending on message type.

<!--
TODO: "If the protocol incorporates cryptographic
protection mechanisms, it should be clearly indicated which portions
of the data are protected and what the protections are (i.e.,
integrity only, confidentiality, and/or endpoint authentication,
etc.). Some indication should also be given to what sorts of attacks
the cryptographic protection is susceptible.   Data which should be
held secret (keying material, random seeds, etc.) should be clearly
labeled."

TODO:
"There should be a clear description of the residual risk to the user
or operator of that protocol after threat mitigation has been
deployed." (i.e. detail what happens if parts are compromised, weak cipher
is deployed etc)
-->

#### RREQ Generation and Reception {#security-protection-application-rreq}

Since OrigPrefix is included in the RREQ, the ICV can be calculated and verified using all
of the message contents. This provides message integrity and endpoint authentication,
because trusted routers MUST hold the shared key in order to calculate the ICV value.
The ICV TLV has type extension := 1.

Since RREQ_Gen's sequence number is incremented for each new RREQ, replay protection is
already afforded and no extra timestamp mechanism is required.

#### RREP Generation and Reception {#security-protection-application-rrep}

Since TargPrefix is included in the RREP, the ICV can be calculated and verified using all
of the message contents. This provides message integrity and endpoint authentication,
because trusted routers MUST hold the shared key in order to calculate the ICV value.
The ICV TLV has type extension := 1.

Since RREP_Gen's sequence number is incremented for each new RREP, replay protection is
afforded and no extra timestamp mechanism is required.

#### RREP_Ack Generation and Reception {#security-protection-application-rrepack}

The RREP_Gen uses the source IP address of the RREP_Ack to identify the sender to look up whether
the RREP_Ack is expected and update the Neighbor Set, and so the ICV MUST be calculated using
the message contents and the IP source address. The ICV TLV has type extension := 2 in order to
accomplish this. This provides message integrity and endpoint authentication, because trusted routers
MUST hold the shared key in order to calculate the ICV value.

The message MUST also include a timestamp to protect against replay attacks, using TargSeqNum from
the RREP as the value in the TIMESTAMP TLV. Verification of a received TIMESTAMP value is performed
by comparing the sequence number in the \<TIMESTAMP-value\> field with the sequence number in a recently
sent RREP awaiting acknowledgement from the sender of the RREP_Ack. If the sequence number is not
equal, the AODVv2 message MUST be discarded.


#### RERR Generation and Reception {#security-protection-application-rerr}

The receiver of the RERR MUST use the source IP address of the RERR to identify the sender to look
up routes using that sender as next hop, and so the ICV MUST be calculated using the message contents
and the IP source address. The ICV TLV has type extension := 2 in order to accomplish this. This provides
message integrity and endpoint authentication, because trusted routers MUST hold the shared key in order
to calculate the ICV value.

The message MUST also include a timestamp to protect against replay attacks, incrementing and using
RERR_Gen's sequence number as the value in the TIMESTAMP TLV. Verification of a received TIMESTAMP
value is performed by comparing the sequence number in the \<TIMESTAMP-value\> field with the last seen
sequence number from the sender of the RERR. If the sequence number is not greater, the AODVv2
message MUST be discarded.



<!--
 Most AODVv2 messages are transmitted to the multicast address LL-MANET-Routers [](#RFC5498).  It is
 therefore required for security that AODVv2 neighbors exchange security information that can be used
 to insert an ICV [](#RFC7182) into the AODVv2 message block [](#RFC5444). This enables hop-by-hop
 security.  -->
<!-- Issue #Q which is proper for these message types that may have mutable fields.-->
<!--
 For destination-only RREP discovery procedures, AODVv2 routers that share a security association SHOULD
 use the appropriate mechanisms as specified in [](#RFC7182). The establishment of these security
 associations is out of scope for this document. -->


# Acknowledgments

AODVv2 is a descendant of the design of previous MANET on-demand protocols, especially AODV
[](#RFC3561) and DSR [](#RFC4728). Changes to previous MANET on-demand protocols stem from
research and implementation experiences.  Thanks to Elizabeth Belding and Ian Chakeres for
their long time authorship of AODV.  Additional thanks to
Derek Atkins,
Emmanuel Baccelli,
Abdussalam Baryun,
Ramon Caceres,
Justin Dean,
Christopher Dearlove,
Fatemeh Ghassemi,
Ulrich Herberg,
Henner Jakob,
Ramtin Khosravi,
Luke Klein-Berndt,
Lars Kristensen,
Tronje Krop,
Koojana Kuladinithi,
Kedar Namjoshi,
Keyur Patel,
Alexandru Petrescu,
Henning Rogge,
Fransisco Ros,
Pedro Ruiz,
Christoph Sommer,
Romain Thouvenin,
Richard Trefler,
Jiazi Yi,
Seung Yi,
Behnaz Yousefi,
and
Cong Yuan,
for their reviews of AODVv2 and DYMO, as well as numerous specification suggestions.


<!-- for cutting and pasting...

<section anchor="" title="">

<t>
<figure>
<artwork>



</artwork>
</figure>
</t>
</section>  <- end of "" subsection  >



     for cutting and pasting...  -->
