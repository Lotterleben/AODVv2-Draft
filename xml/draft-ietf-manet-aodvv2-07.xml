<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!--
==================================== 80 ========================================
==================================== 72 ================================
 -->
<!--
     Check for lines containing the string "CEP".
     Also for lines containing the string "JPD" (John Dowdell 20140827)
  -->
<rfc category="std" docName="draft-ietf-manet-aodvv2-07" ipr="trust200902">
  <front>
    <title abbrev="AODVv2">Dynamic MANET On-demand (AODVv2) Routing</title>

    <author fullname="Charles E. Perkins" initials="C.E." surname="Perkins">
      <organization abbrev="Futurewei">Futurewei Inc. </organization>
      <address>
        <postal>
          <street>2330 Central Expressway</street>

          <city>Santa Clara</city>

          <code>95050</code>

          <region>CA</region>

          <country>USA</country>
        </postal>

        <phone>+1-408-330-4586</phone>

        <email>charliep@computer.org</email>
      </address>
    </author>

    <author fullname="Stan Ratliff" initials="S." surname="Ratliff">
      <organization>Idirect</organization>

      <address>
        <postal>
          <street>13861 Sunrise Valley Drive, Suite 300</street>

          <city>Herndon</city>

          <region>VA</region>

          <code>20171</code>

          <country>USA</country>
        </postal>

        <email>ratliffstan@gmail.com</email>

      </address>
    </author>

    <author fullname="John Dowdell" initials="J." surname="Dowdell">
      <organization>Airbus Defence and Space</organization>

      <address>
        <postal>
          <street>Celtic Springs</street>

          <city>Newport</city>

          <region>Wales</region>

          <code>NP10 8FZ</code>

          <country>United Kingdom</country>
        </postal>

        <email>john.dowdell@airbus.com</email>

      </address>
    </author>

    <author fullname="Lotte Steenbrink" initials="L." surname="Steenbrink">
      <organization>HAW Hamburg, Dept. Informatik</organization>

      <address>
        <postal>
          <street>Berliner Tor 7</street>

          <city>D-20099 Hamburg</city>

          <!-- <code>D-20099</code>  -->

          <country>Germany</country>
        </postal>

        <email>lotte.steenbrink@haw-hamburg.de</email>

      </address>
    </author>

    <author fullname="Victoria Mercieca" initials="V." surname="Mercieca">
      <organization>Airbus Defence and Space</organization>

      <address>
        <postal>
          <street>Celtic Springs</street>

          <city>Newport</city>

          <region>Wales</region>

          <code>NP10 8FZ</code>

          <country>United Kingdom</country>
        </postal>

        <email>victoria.mercieca@airbus.com</email>

      </address>
    </author>

    <date/>

    <area>Routing</area>

    <workgroup>Mobile Ad hoc Networks Working Group</workgroup>

    <keyword>RFC</keyword>

    <keyword>Request for Comments</keyword>

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <keyword>XML</keyword>

    <keyword>reactive protocol</keyword>

    <abstract>
      <t>The revised Ad Hoc On-demand Distance Vector (AODVv2) routing
      protocol is
      intended for use by mobile routers in wireless, multihop
      networks. AODVv2 determines unicast routes among AODVv2 routers
      within the network in an on-demand fashion, offering rapid
      convergence in dynamic topologies.</t>
    </abstract>
  </front>

  <middle>
<section title="Overview">
  <t> The revised Ad Hoc On-demand Distance Vector (AODVv2) routing protocol
      [formerly named DYMO] enables on-demand, multihop unicast routing among
      AODVv2 routers in mobile ad hoc networks [MANETs]<xref target="RFC2501"/>.
      The basic operations of the AODVv2 protocol are route discovery and
      route maintenance. Route discovery is performed when an AODVv2 router
      must transmit a packet towards a destination for which it does not have
      a route.  Route maintenance is performed to avoid prematurely expunging
      routes from the route table, and to avoid dropping packets when a
      route breaks.</t>

  <t> During route discovery, the originating AODVv2 router (RREQ_Gen)
      multicasts a Route Request message (RREQ) to find a route toward some
      target
      destination.  Using a hop-by-hop regeneration algorithm, each AODVv2
      router receiving the RREQ message records a route toward the originator.
      When the target's AODVv2 router (RREP_Gen) receives the RREQ, it records a
      route toward RREQ_Gen and generates a Route Reply (RREP) unicast
      toward RREQ_Gen. Each AODVv2 router that receives the RREP stores a
      route toward the target, and again unicasts the RREP toward the
      originator. When RREQ_Gen receives the RREP, routes have then been
      established between RREQ_Gen (the originating AODVv2 router) and
      RREP_Gen (the target's AODVv2 router) in both directions.</t>

  <t> Route maintenance consists of two operations. In order to
      maintain routes, AODVv2 routers extend route lifetimes upon
      successfully forwarding a packet.  When a data packet is received to
      be forwarded but there is no valid route for the destination,
      then the AODVv2 router of the source of the packet is notified via
      a Route Error (RERR) message.  Each upstream router that receives
      the RERR marks the route as Invalid.  Before such an upstream AODVv2
      router could forward a packet to the same destination, it would have
      to perform route discovery again for that destination. RERR messages
      are also used to notify upstream routers when routes break (say,
      due to loss of a link to a neighbor).</t>

  <t> AODVv2 uses sequence numbers to assure loop freedom
      <xref target="Perkins99"/>, similarly to AODV. Sequence numbers enable
      AODVv2 routers to determine the temporal order of AODVv2 route discovery
      messages, thereby avoiding use of stale routing information.</t>

  <t> See <xref target="represent"/> for the mapping of AODVv2 data elements
      to RFC 5444 Address Block, Address TLV, and Message TLV formats.
      Security for authentication of AODVv2 routers, and/or encryption
      of traffic is dealt with by the underlying transport mechanism (e.g.,
      by using the techniques for Authentication, Integrity, and
      Confidentiality documented in <xref target="RFC5444"/>).</t>

</section>

<section title="Terminology">

  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in <xref target="RFC2119"/>. In addition, this document
      uses terminology from <xref target="RFC5444"/>, and defines the
      following terms:
  <list style="hanging">

  <t hangText="Adjacency"><vspace/>
     A bi-directional relationship between neighboring AODVv2 routers for
     the purpose of exchanging routing information.  Not every pair of
     neighboring routers will necessarily form an adjacency.  Monitoring
     of adjacencies where packets are being forwarded is required (see
     <xref target="blacklists"/>).</t>

  <t hangText="AckReq"><vspace/>
     Request for acknowledgement (of an RREP message).</t>

  <t hangText="AODVv2 Router"><vspace/>
     An IP addressable device in the ad-hoc network that performs the AODVv2
     protocol operations specified in this document.</t>

  <t hangText="Current_Time"><vspace/>
     The current time as maintained by the AODVv2 router.
     <!-- [JPD] Need to have a discussion of time somewhere in the text.
     If no security, only need locally scoped time. Add security, and you
     need globally scoped time to support SSL etc -->
     <!-- CEP: It would be wrong to require NTP for ad hoc networks -->
     <!-- JPD: Completely agree, but to maintain security should we say that
     some method of acquiring time either locally (eg from GPS) or remotely
     (eg NTP or tlsdate) is necessary? I think it would be wrong to mandate
     a particular method but I believe we need to say something --> </t>

  <t hangText="Data Element"><vspace/>
     A named object used within AODVv2 protocol messages</t>

  <t hangText="Disregard"><vspace/>
     Ignore for further processing.
     <!-- CEP: Issue number goes here
         , and discard unless it is
     required to keep the message in the packet for purposes
     of authentication.   --> </t>
  <!-- CEP: Look for the string "CEP" and insert Issue #s as needed... -->

  <!-- downstream never appears in the text, and there was a complaint about it.
  <t hangText="downstream"><vspace/>
     In the direction from OrigAddr to TargAddr.</t>
     -->

  <t hangText="Handling Router (HandlingRtr)"><vspace/>HandlingRtr denotes
    the AODVv2 router receiving and handling an AODVv2 message.</t>

  <t hangText="Invalid route"><vspace/>
    A route that cannot be used for forwarding.</t>

  <t hangText="MANET"><vspace/>
    A Mobile Ad Hoc Network as defined in <xref target="RFC2501"/>.</t>

  <t hangText="MetricList"><vspace/>
    The metrics associated with the addresses in an AddressList.</t>

  <t hangText="Node"><vspace/>
    An IP addressable device in the ad-hoc network.  A node may be an AODVv2
    router, or it may be a device in the network that does not perform any
    AODVv2 protocol operations.  All nodes in this document are either
    AODVv2 Routers or else Router Clients.</t>

  <t hangText="OrigAddr"><vspace/> An IP address of the Originating Node
    used as a data element within AODVv2 messages.</t>

  <t hangText="OrigAddrMetric"><vspace/>The metric associated with
    the route to OrigAddr.</t>

  <t hangText="OrigSeqNum"><vspace/>The Sequence Number maintained
    by OrigNode for OrigAddr.</t>

  <t hangText="Originating Node (OrigNode)"><vspace/>
    The Originating Node is the node that launched the application
    requiring communication with the Target Address.  If OrigNode is a
    Router Client, its AODVv2 router (RREQ_Gen) has the
    responsibility to generate a AODVv2 RREQ message on behalf of
    OrigNode as necessary to discover a route.</t>
    <!-- [JPD] "its AODV Router" implies only one router per
          set of router clients -->
    <!-- [CEP] Yes, that is correct; no multihoming yet -->

  <t hangText="PktSource"><vspace/>
    The source address of a packet sent to an unreachable address.</t>

  <t hangText="PrefixLengthList"><vspace/>
    The prefix lengths associated with addresses in an AddressList.</t>

  <t hangText="Reactive"><vspace/> A protocol operation is called "reactive"
    if it is performed only in reaction to specific events.  As used in
    this document, "reactive" is synonymous with "on-demand".  </t>
    <!-- word "essentially" deleted, either synonymous or not -->
    <!-- [CEP] Well, O.K., but no two words are absolutely synonymous. -->

  <t hangText="Routable Unicast IP Address"><vspace/>
    A routable unicast IP address is a unicast IP address that is scoped
    sufficiently to be forwarded by a router.  Globally-scoped unicast IP
    addresses and Unique Local Addresses (ULAs).<xref target="RFC4193"/>
    <!-- [JPD] ULAs are NOT globally routable -->
    <!-- [CEP] That is true, but they *are* routable unicast addresses -->
    are examples of routable unicast IP addresses.</t>
    <!-- [CEP] Can a node determine whether an address is multihop-capable? -->

  <t hangText="Route Error (RERR)"><vspace/>
    A RERR message is used to indicate that an AODVv2 router does not
    have a route toward one or more particular destinations.
  </t>

  <t hangText="Route Reply (RREP)"><vspace/>
    A RREP message is used to establish a route between <!-- RREQ -->
    the Target Address and the Originating Address, at all the AODVv2
    routers between them.</t>

  <t hangText="Route Request (RREQ)"><vspace/>
    An AODVv2 router uses a RREQ message to discover a valid route
    to a particular destination address, called the Target Address.
    An AODVv2 router processing a RREQ receives routing information
    for the Originating Address.</t>

  <t hangText="Router Client"><vspace/>A node that requires
    the services of an AODVv2 router for route discovery and
    maintenance.  An AODVv2 router is always its own client,
    so that its list of client IP addresses is never empty.</t>

  <t hangText="Router Interface"><vspace/>An interface supporting the
    transmission or reception of Router Messages.</t>

  <t hangText="RREP Generating Router (RREP_Gen)"><vspace/>
    The RREP Generating Router is the AODVv2 router that serves TargNode.
    RREP_Gen generates the RREP message to advertise a route towards
    TargAddr from OrigAddr.</t>

  <t hangText="RREQ Generating Router (RREQ_Gen)"><vspace/>
    The RREQ Generating Router is the AODVv2 router that serves OrigNode.
    RREQ_Gen generates the RREQ message to discover a route for TargAddr.</t>

  <t hangText="Sequence Number (SeqNum)"><vspace/>
    A Sequence Number is an unsigned integer maintained by an AODVv2 router to
    avoid re-use of stale messages.  The router associates SeqNum with an IP
    address of one or more of its network interfaces.  The value zero (0) is
    reserved
    to indicate that the Sequence Number for an address is unknown.</t>

  <t hangText="SeqNumList"><vspace/>
    The list of Sequence Numbers associated with addresses in an AddressList,
    used in RERR messages.
  </t>

  <t hangText="TargAddr"><vspace/> An IP address of the Target Node
    used as a data element within AODVv2 messages.</t>

  <t hangText="TargAddrMetric"><vspace/>The metric associated with
    the route to TargAddr.</t>

  <t hangText="TargSeqNum"><vspace/> The Sequence Number maintained
    by TargNode for TargAddr.</t>

  <t hangText="Target Node (TargNode)"><vspace/>
    The node hosting the IP address towards which a route is needed.</t>

  <t hangText="Type-Length-Value structure (TLV)"><vspace/>
    A generic way to represent information, for example as used
    in <xref target="RFC5444"/>.</t>

  <t hangText="Unreachable Address"><vspace/>
    An address for which a valid route is not known.</t>

  <t hangText="upstream"><vspace/>
    In the direction from TargAddr to OrigAddr.</t>

  <t hangText="Valid route"><vspace/>
    A route that can be used for forwarding.</t>

  <t hangText="ValidityTime"><vspace/> The duration of time for which a
    route should be considered to be a valid route.</t>

  </list></t>
  <t><vspace blankLines="19"/></t>
</section>

<section anchor="notation" title="Data Elements and Notational Conventions">
  <t>This document uses the Data Elements and conventions found in
     <xref target="data-elements"/> and <xref target="conventions"/>.</t>

  <texttable anchor="data-elements">
                <ttcol align="left" width="20%">Data Elements</ttcol>
                <ttcol align="left">Meaning</ttcol>
  <c>msg_hop_limit</c>	<c>Number of hops allowable for the message</c>
  <c>msg_hop_count</c>	<c>Number of hops traversed so far by the message</c>
  <c>AckReq</c>		<c>Acknowledgement Requested for RREP</c>
  <c>MetricType</c>	<c>The metric type for values in MetricList</c>
  <c>PktSource</c>	<c>Source address of a data packet</c>
  <c>AddressList</c>	<c>A list of IP addresses</c>
  <c>OrigAddr</c>	<c>IP address of the Originating Node</c>
  <c>TargAddr</c>	<c>IP address of the Target Node</c>
  <c>UnreachableAddress</c>	<c>An unreachable IP address</c>
  <c>PrefixLengthList</c>
    <c>Routing prefixes associated with addresses in AddressList</c>
  <c>SeqNum</c>			<c>Sequence Number, used in RERR messages</c>
  <c>SeqNumList</c>		<c>A list of SeqNums</c>
  <c>OrigSeqNum</c>		<c>Originating Node Sequence Number</c>
  <c>TargSeqNum</c>		<c>Target Node Sequence Number</c>
  <c>MetricList</c>
	<c>Metric values for routes to addresses in AddressList</c>
  <c>OrigAddrMetric</c>		<c>Metric value for route to OrigAddr</c>
  <c>TargAddrMetric</c>		<c>Metric value for route to TargAddr</c>
  <c>ValidityTime</c>		<c>Included in ValidityTimeList</c>
  <c>ValidityTimeList</c>	<c>ValidityTime values for routes
	  				to Addresses in AddressList</c>
  </texttable>

  <texttable anchor="conventions">
       <ttcol align="left" width="25%">Notation</ttcol>
       <ttcol align="left">Meaning</ttcol>
  <c>Route[Address]</c>	<c>A route table entry towards Address</c>
  <c>Route[Address].{field}</c> <c>A field in such a route table entry</c>
  <c> -- </c> <!--  Types of Nodes  --> <c> -- </c>
  <c>RREQ_Gen</c>	<c>AODVv2 router originating an RREQ</c>
  <c>RREP_Gen</c>	<c>AODVv2 router responding to an RREQ</c>
  <c>RERR_Gen</c>	<c>AODVv2 router originating an RERR</c>
  <c>RteMsg</c>		<c>Either RREQ or RREP</c>
  <c>RteMsg.{field}</c>	<c>Field in RREQ or RREP</c>
  <c>AdvRte</c>		<c>A route advertised in an incoming RteMsg</c>
  <c>HandlingRtr</c>	<c>Handling Router</c>
  </texttable>

</section>

<section anchor="apply" title="Applicability Statement">
  <!--
     The nets do not have to be mobile, and AODVv2 may be applicable
     in low power lossy sensor networks.
     -->
  <t> The AODVv2 routing protocol is a reactive routing protocol designed for
      stub (i.e., non-transit) or disconnected (i.e., from the Internet) mobile
      ad hoc networks (MANETs).  AODVv2 handles a wide variety of mobility
      patterns by determining routes on-demand.  AODVv2 also handles a wide
      variety of traffic patterns. In networks with a large number of routers,
      AODVv2 is best suited for relatively sparse traffic scenarios where any
      particular router forwards packets to only a small percentage of the
      AODVv2 routers in the network, due to the on-demand nature of route
      discovery and route maintenance.  AODVv2 supports routers with multiple
      interfaces, as long as each interface has its own (unicast routeable)
      IP address; the set of all network interfaces supporting AODVv2 is
      administratively configured in a list (namely, AODVv2_INTERFACES). </t>

  <t> Ad Hoc networks have been deployed in many circumstances,
      including for emergency and disaster relief.  In those
      circumstances, it is sometimes the case that the simple
      ability to communicate is much more important than being
      assured of secure operations.  AODVv2 is very well suited
      for such reactive scenarios. For other ad hoc networking applications,
      in which insecure operation could negate the value of establishing
      communication paths, it is important for neighboring AODVv2 nodes to
      establish security associations with one another.</t>

  <t> Although AODVv2 is closely related to AODV
      <xref target="RFC3561"/>, and shares some features of DSR
      <xref target="RFC4728"/>, AODVv2 is not interoperable with
      either of those other two protocols.</t>

<!-- Issue #22 -->
  <t> AODVv2 is applicable to memory constrained devices, since only a little
      routing state is maintained in each AODVv2 router.  Routes that are not
      needed for forwarding data do not have to be maintained, in contrast to
      proactive routing protocols that require routing information to all
      routers within the MANET be maintained.</t>

  <t> In addition to routing for its own local applications, each AODVv2 router
      can also route on behalf of other non-routing nodes (in this document,
      "Router Clients") that are directly reachable via its network interfaces.
      Each AODVv2 router,
      if serving router clients other than itself, SHOULD be configured with
      information about the IP addresses of its clients, using any suitable
      method.  In the initial state, no AODVv2 router is required to have
      information about the relationship between any other AODVv2 router and
      its Router Clients (see <xref target="clients"/>). </t>

  <t> The coordination among multiple AODVv2 routers to distribute
      routing information correctly for a shared address (i.e. an address
      that is advertised and can be reached via multiple AODVv2 routers) is
      not described in this document. The AODVv2 router operation of shifting
      responsibility for a routing client from one AODVv2 router to
      another is described in <xref target="change_address_location"/>.
      Address assignment procedures are entirely out of scope for AODVv2.
      A Router Client SHOULD NOT
      be served by more than one AODVv2 router at any one time.</t>

  <t>AODVv2 routers perform route discovery to find a route toward a
      particular destination.  AODVv2 routers MUST must be
      configured to respond to RREQs for themselves and their clients.
      <!-- [JPD] "certain set of addresses? Which ones, described where? -->
      <!-- [CEP]: themselves and their clients... -->
      When AODVv2 is the only protocol interacting with the forwarding
      table, AODVv2 MAY be configured to perform route discovery for
      all unknown unicast destinations.</t>

  <t> By default, AODVv2 only supports bidirectional links.
      In the case of possible unidirectional links, blacklists
      (see <xref target="blacklists"/>) SHOULD be used, or other means (e.g.
      adjacency establishment with only neighboring routers that have
      bidirectional communication as indicated by NHDP <xref target="RFC6130"/>)
      of assuring and monitoring bi-directionality are recommended.
      <!-- If the text is deleted, the specification is suddenly wrong,
           because implementations that use other methods do not need to
           keep blacklists -->
      Otherwise, persistent packet loss or persistent protocol failures
      could occur.
      <!--  The cost of bidirectional link L (denoted Cost(L)) may depend upon
            the direction across the link for which the cost is measured. -->
      If received over a link that is unidirectional, metric information from
      incoming AODVv2 messages MUST NOT be used for route table updates.</t>

<!-- CEP : this can be deleted -->
  <t> The routing algorithm in AODVv2 may be operated at layers other
      than the network layer, using layer-appropriate addresses.
      The routing algorithm makes use of some persistent state; if there
      is no persistent storage available for this state, recovery can impose
      a performance penalty (e.g., in case of AODVv2 router reboots).</t>

</section>

<!-- ============================================================= -->

<section anchor="MsgXmit" title="AODVv2 Message Transmission">

  <t> In its default mode of operation, AODVv2 sends messages using the
      parameters for port number and IP protocol specified in
      <xref target="RFC5498"/>.  Unless otherwise specified, the address for
      AODVv2 multicast messages (for example, RREQ or RERR) is the link-local
      multicast address LL-MANET-Routers <xref target="RFC5498"/>.
      All AODVv2 routers      MUST    <!--  MUST  [CEP] -->
      subscribe to LL-MANET-Routers <xref target="RFC5498"/> to receive AODVv2
      messages.  Implementations are free to choose their own heuristics for
      reducing multicast overhead. Some methods for doing so are described in
      <xref target="RFC6621"/>.  AODVv2 does not specify which method should be
      used to restrict the set of AODVv2 routers that have the responsibility
      to regenerate multicast packets.  Note that multicast packets MAY be sent
      via unicast. For example, this may occur for certain link-types
      (non-broadcast media), for manually configured router adjacencies,
      or in order to improve robustness.
  </t>

  <t> When multiple interfaces are available, a node transmitting
      a multicast packet to LL-MANET-Routers MUST send the packet on
      all interfaces that have been configured for AODVv2 operation.
      Similarly, AODVv2 routers MUST subscribe to LL-MANET-Routers on
      all their AODVv2 interfaces.</t>

  <t> The IPv4 TTL (IPv6 Hop Limit) field for all packets
      containing AODVv2 messages is set to 255. If a packet is
      received with a value other than 255, any AODVv2 message
      contained in the packet MUST be disregarded by AODVv2.
      This mechanism, known as "The Generalized TTL Security Mechanism"
      (GTSM) <xref target="RFC5082"/> helps to assure that packets
      have not traversed any intermediate routers.</t>

  <t> IP packets containing AODVv2 protocol messages SHOULD be
      given priority queuing and channel access.</t>

</section>

<!-- ============================================================= -->
<section title="Data Structures">

  <section anchor="rte" title="Route Table Entry">
  <t>The route table entry is a conceptual data structure.  Implementations
     MAY use any internal representation so long as it provides access to the
     information specified below.</t>

  <t>A route table entry has the following fields:
  <list style="hanging">
    <t hangText="Route.Address"><vspace/>
      An address or address prefix of a node</t>

    <t hangText="Route.PrefixLength"><vspace/>
      The length of the address or prefix.  If the value of Route.PrefixLength
      is less than the length of Route.Address, the route can be thought of as
      a route to the subnet on which Route.Address resides.  A PrefixLength is
      stored for every route in the route table.</t>

    <t hangText="Route.SeqNum"><vspace/>
      The Sequence Number associated with Route.Address, as obtained from the
      last packet that successfully updated this route table entry.</t>

    <!-- CEP: The neighbor might have more than one IP address -->
    <t hangText="Route.NextHop"><vspace/>
      The IP address of the adjacent AODVv2 router used for the path toward
      the Route.Address</t>

    <t hangText="Route.NextHopInterface"><vspace/>
      The interface used to send packets toward Route.Address</t>

    <t hangText="Route.LastUsed"><vspace/>
      The time that this route was last used to forward a packet</t>

    <t hangText="Route.LastSeqNum"><vspace/>
      The time that the destination SeqNum for this route was last updated</t>

    <t hangText="Route.ExpirationTime"><vspace/>
      The time at which this route must be marked as Invalid</t>

    <t hangText="Route.MetricType"><vspace/>
      The type of the metric for the route towards Route.Address</t>

    <t hangText="Route.Metric"><vspace/>
      The cost of the route towards Route.Address expressed in units
      consistent with Route.MetricType</t>

    <t hangText="Route.State"><vspace/>
      The last *known* state (one of Active, Idle, or Invalid) of the route</t>

    <t hangText="Route.Timed"><vspace/>
      TRUE if the route was specified to have a ValidityTime</t>

    <!-- [JPD] why are route precursors optional? -->
    <!-- [CEP] They should be "SHOULD" but don't affect interoperability -->
    <t hangText="Route.Precursors (optional)"><vspace/>
      A list of upstream neighbors using the route</t>

  </list></t>

  <!-- [CEP]: If these are definitional, then the operational details
       should be located elsewhere, I think.  They were just below. -->
  <!-- The route's state determines the
    operations that can be performed
    on the route table entry.   -->
  <t>A route table entry (i.e., a route) is in one of the
    following states:
  <list style="hanging">
  <t hangText="Active"><vspace/>
    An Active route is in current use for forwarding packets.  An Active
    route is maintained continuously by AODVv2 and is considered to remain
    active as long as it is used at least once during every ACTIVE_INTERVAL,
    or if the Route.Timed flag is true.  When a route that is not a timed
    route is no longer active the route becomes an Idle route.
  </t>
  <t hangText="Idle"><vspace/>
    An Idle route can be used for forwarding packets, even though it is not
    in current use.  If an Idle route is used to forward a packet, it becomes
    an Active route once again.  After an Idle route remains idle for
    MAX_IDLETIME, it becomes an Invalid route.
  </t>
  <t hangText="Invalid"><vspace/> A route marked as Invalid cannot be used
    for forwarding, but the sequence number information MAY be maintained
    until the destination sequence number has not had any updates for
    MAX_SEQNUM_LIFETIME; after that time, old sequence number information may
    no longer be valid and the Invalid route MUST be expunged.
  </t>

  </list> </t>

  <t>MAX_SEQNUM_LIFETIME is the time after a reboot during which an
     AODVv2 router MUST NOT respond to any routing messages that require
     information about its Sequence Number.  Thus, if all other AODVv2
     routers expunge routes to the rebooted router after that time
     interval, the rebooted AODVv2 router's sequence number will not
     be considered stale by any other AODVv2 router in the MANET.
  </t>
  <t>The invalidation of a Timed route is controlled by the
     ExpirationTime time of the route table entry (instead of
     MAX_IDLETIME).  Until that time, a Timed route can be used
     for forwarding packets.  A route is indicated to be a Timed
     route by the setting of the Timed flag in the route table
     entry.  Afterwards, the route MAY be expunged; otherwise the
     route must be must be marked as Invalid.
  </t>
      </section>

  <section title="Next-hop Router Adjacency Monitoring and Blacklists"
  	   anchor="blacklists">

  <t> Neighboring routers MAY form an adjacency based on AODVv2 messages,
      other protocols (e.g. NDP <xref target="RFC4861"/> or NHDP
      <xref target="RFC6130"/>), or manual configuration.  Loss of a routing
      adjacency may also be indicated similarly.  AODVv2 routers SHOULD
      monitor connectivity to adjacent routers along active routes.
      In the absence of other information about bidirectional connectivity,
      the default approach for AODVv2 routers to monitor connectivity to
      neighboring AODVv2 routers is to include the AckReq data element in
      RREP messages, and send RREP_Ack messages to fulfill the requests
      (see Sections 9.2 and 9.4). However, when routers perform other
      operations such as those from the list below, these can also be
      used as indications of connectivity.
      <list style="symbols">
        <t> Neighborhood discovery <xref target="RFC6130"/>, if
            that protocol is implemented by its neighbors </t>
        <t> Route timeout </t>
        <t> Lower layer trigger that a link is broken </t>
        <t> TCP timeouts </t>
        <t> Promiscuous listening </t>
        <t> Other monitoring mechanisms or heuristics </t>
      </list>
  </t>


      <!-- [CEP]: to discuss MUST versus MAY here... -->
<!--  CEP: TODO:  Should specify that repeated RREQs deserve more attention

  <t> To avoid repeated failure of Route Discovery, an AODVv2 router
      (HandlingRtr) handling a unicast RREP message MUST determine bidirectional
      connectivity towards RREQ_Gen. If not already determined by the
      abovementioned monitoring methods, connectivity MAY be determined
      by including the
      Acknowledgement Request (AckReq) data element in the RREP. In reply
      to an AckReq, an RREP_Ack message message MUST be sent.  If the
      verification is not received within RREP_Ack_SENT_TIMEOUT, HandlingRtr
      MUST put the upstream neighbor in the blacklist.</t> -->

  <t> For example, receipt of a Neighborhood Discovery message would signal
      a connection to the sender. In this case, the AODVv2 router doesn't need
      to request an acknowledgement in the RREP. Similarly, if AODVv2 received
      notification of a timeout, this may possibly be due to a disconnection,
      and the AODVv2 router SHOULD attempt to verify connectivity by
      including AckReq data element when sending a RREP to that neighbor. </t>

  <t> When a link to a neighbor is determined to be unidirectional, either
      by failure to respond with a RREP_Ack as requested, or by some other
      means, the neighbor MUST be placed in a blacklist.  However, the
      blacklisted neighbor SHOULD NOT be permanently blacklisted; after a
      certain time (MAX_BLACKLIST_TIME), it SHOULD once again be considered
      as a viable neighbor for route discovery operations. </t>

  <t> For this purpose, a list of blacklisted routers along with
      their time of removal SHOULD be maintained:
      <list style="hanging">
      <t hangText="Blacklist.Router"><vspace/>An IP address of the
         router that did not verify bidirectional connectivity.  </t>
      <t hangText="Blacklist.RemoveTime"><vspace/>The time at which
         Blacklist.Router MAY be removed from the blacklist.  </t>
      </list>
      RREQs received from a blacklisted router, or any router over a link
      that is known to be incoming-only, MUST be disregarded.
  </t>

  </section> <!-- title="Next-hop Router Adjacency Monitoring and Blacklists"
  	   			anchor="blacklists" -->

  <section anchor="clients" title="Router Clients and Client Networks">

  <t> An AODVv2 router may offer routing services to other nodes that are not
      AODVv2 routers; such nodes are called Router Clients in this document.
        <!-- [JPD] not sure what the following text is doing here, perhaps
        should be relocated to section on Sequence Numbers. .... "AODVv2
        defines the Sequence Number to be the same for the AODVv2 router
        and each of its clients." -->
        <!-- [CEP]: it was here because it's about clients...?  But if
       we don't need it at all, it's O.K. with me to delete -->
  </t>

  <t> For this purpose, CLIENT_ADDRESSES must be configured on each
      AODVv2 router with the following information:
      <list style="hanging">
      <t hangText="Client IP address"><vspace/>The IP address of the
         node that requires routing service from the AODVv2 router. </t>
      <t hangText="Client Prefix Length"><vspace/>The length of the
       routing prefix associated with the client IP address.  </t>
      </list>
  </t>

  <t>
     The list of Routing Clients for an AODVv2 router is never empty, since
     an AODVv2 router is always its own client as well.  If the Client Prefix
     Length is not the full length of the Client IP address, then the prefix
     defines a Client Network.  If an AODVv2 router is configured to serve a
     Client Network, then the AODVv2 router MUST serve every node that has an
     address within the range defined by the routing prefix of the Client
     Network.
  </t>
<!-- [JPD] Question: does the built-in Route Client always have to
           have a different IP address to the Router itself? -->
<!-- [CEP]: No, in fact I never imagined that the IP addresses
          would be different -->
  </section> <!-- anchor="clients" title="Router Clients and Client Networks"-->

<!-- =================== Sequence Numbers ========================== -->

  <section anchor="seqnum" title="Sequence Numbers">

  <t> Sequence Numbers allow AODVv2 routers to evaluate the freshness of
      routing information.  Each AODVv2 router in the network MUST maintain
      its own sequence number (SeqNum).  Each RREQ and RREP generated by
      an AODVv2 router includes its SeqNum.  Each AODVv2 router MUST ensure
      that its SeqNum is monotonically increasing. The router can
      ensure this by incrementing SeqNum whenever it generates RREQ or RREP .
   </t>

   <t>
      A router receiving a RREQ or RREP message uses the Sequence Number in
      the message to determine the freshness of a route update: if a new
      Sequence Number in the message is lower than the one stored in the route
      table, the stored information for that route is considered stale.
   </t>

   <t>
      As a consequence, loop freedom is assured.
   </t>

   <t>
      If the router has multiple network interfaces, it can use the same
      SeqNum for the IP addresses of all of them, or it can assign different
      SeqNums for use with different IP addresses.  However, the router MUST
      NOT use multiple SeqNums for any particular IP address.  A Router Client
      has the same SeqNum as the IP address of the network interface that the
      AODVv2 router uses to forward packets to that Router Client.  Similarly,
      a route to a subnet has the same SeqNum as the IP address of the network
      interface that the AODVv2 router uses to forward packets to that subnet.
      The Sequence Number fulfills the same role as the
      "Destination Sequence Number" of DSDV <xref target="Perkins94"/>, and
      as the AODV Sequence Number in RFC 3561<xref target="RFC3561"/>.
   </t>

  <!--  TODO??: enable Seq# == 0  -->
  <t> An AODVv2 router increments its SeqNum as follows.  Most of the time,
      SeqNum is incremented by simply adding one (1).  But when the SeqNum
      has the value of the largest possible number representable as a 16-bit
      unsigned integer (i.e., 65,535), it MUST be incremented by setting to
      one (1).  In other words, the sequence number after 65,535 is 1.</t>

  <t> An AODVv2 router SHOULD maintain its SeqNum in persistent storage.
      If an AODVv2 router's SeqNum is lost, it MUST take the following
      actions to avoid the danger of routing loops.  First, the AODVv2
      router MUST set Route.State := Invalid for each entry.  Furthermore
      the AODVv2 router MUST wait for at least MAX_SEQNUM_LIFETIME before
      transmitting or regenerating any AODVv2 RREQ or RREP messages.
       <!-- TODO:  CEP:  What about relaying RREQ? -->
       <!-- TODO:  CEP:  I hope this part will change as per Vicky. -->
      If an AODVv2 protocol message is received during this waiting period,
      the AODVv2 router SHOULD perform normal route table entry updates, but
      not forward the message to other nodes.  If, during this waiting period,
      a data packet is received to be forwarded to another destination that
      is not among the router's Clients, then the AODVv2 router MUST transmit
      a RERR message indicating that no route is available.  However, packets
      destined to a Client are forwarded as usual.  At the end of the waiting
      period the AODVv2 router sets its SeqNum to one (1) and begins
      performing AODVv2 protocol operations again.</t>
       <!-- TODO:  CEP:  Actually, could forward...? -->
       <!-- TODO:  CEP:  Actually, usual RERR rules? -->
  </section> <!--  section anchor="seqnum" title="Sequence Numbers"  -->

  <section anchor="supp-tbl" title="Table for Multicast RteMsgs">
  <t>
    Two multicast RteMsgs (i.e., RREQ or RREP) are considered to be "comparable"
    if they have the same Message Type, OrigAddr, TargAddr, and MetricType.
    When RteMsgs are flooded in a MANET, an AODVv2 router may well receive
    such comparable RteMsgs from its neighbors.  A router, after receiving a
    RteMsg, MUST check against previous RteMsgs to assure that its response
    message would contain information that is not redundant.  Otherwise,
    multicast RteMsgs are likely to be regenerated repeatedly with almost no
    additional benefit, but generating a great deal of unnecessary signaling
    traffic and interference.  See <xref target="suppress"/> regarding
    suppression of redundant RteMsgs.
  </t>

  <t>
    To avoid transmission of redundant RteMsgs, while still enabling
    the proper handling of earlier RteMsgs that may have somehow been
    delayed in the network, each AODVv2 router keeps a list of certain
    information about recently received RteMsgs.  This list is called
    the AODVv2 Multicast RteMsg Table -- or, more briefly, the RteMsg Table.
  </t>
  <t>
    Each entry in the RteMsg Table has the following fields:
          <list style="symbols">
      <t>Message Type (either RREQ or RREP)</t>
      <t>OrigAddr</t>
      <t>TargAddr</t>
      <t>OrigSeqNum (if present)</t>
      <t>TargSeqNum (if present)</t>
      <t>MetricType</t>
      <t>Timestamp (Current_Time at the time the entry is updated)</t>
    </list>

    The RteMsg Table is maintained so that no two entries in the RteMsg Table
    are comparable -- that is, all RteMsgs represented in the RteMsg Table
    either have  different Message Types, different OrigAddr, different
    TargAddr, or different metric types.  If two RteMsgs have the same Message
    Type, MetricType, OrigAddr, and
    TargAddr, the information from the one with the older Sequence Number
    is not needed in the table; in case they have the same Sequence Number,
    <!-- CEP: the last phrase is ambiguous for RREQ with TargNode SeqNum -->
    the one with the greater Metric value is not needed; in case they have
    the same Metric as well, it does not matter which table entry is
    maintained.  Whenever a RteMsg Table entry is updated, its Timestamp
    field MUST also set to be the Current_Time.
  </t>

  </section>
      <!-- section anchor="supp-tbl" title="Table for Multicast RteMsgs"  -->

</section>

<section anchor="metrics" title="Metrics">

  <t> Metrics measure a cost or quality associated to a route or a link.
      They can account for various characteristics such as latency, delay,
      financial, energy, etc.  A metric value is included in each routing
      table entry.  Determining whether to use incoming information about
      a route requires comparing metric values. Whenever an AODV router
      receives metric information in an incoming message, the received
      value of the metric is as measured by the neighbor router, and
      does not reflect the cost of traversing the link to that neighbor.</t>

  <t> Each metric has a MetricType, which is allocated by IANA as specified
      in <xref target="RFC6551"/>.  Apart from its default metric type as
      detailed in <xref target="default_metric"/>, AODVv2 enables the use of
      monotonically increasing metrics, whose data type depends on the metric
      used.  Using non-default metrics in a RteMsg requires the inclusion
      of the MetricType data element.  Routes are looked up according to metric
      type, and intermediate routers handling a RteMsg assign
      the same metric type to all metric information in the RteMsg.</t>

  <t>
      For each type of metric, a maximum value is defined, denoted
      MAX_METRIC[i] where 'i' is the MetricType.  AODVv2 cannot store
      routes in its route table that cost more than MAX_METRIC[i].</t>


  <section anchor="cost" title="The Cost() function">

  <t> In order to simplify the description of storing accumulated
      route costs in the route table, a Cost() function is defined.
      This function returns the Cost of traversing a Route ('Cost(R)')
      or a Link ('Cost(L)').  Cost(L) for DEFAULT_METRIC_TYPE is specified
      in <xref target="default_metric"/>.  The Cost() function for other
      metrics is beyond the scope of this document.</t>

  </section> <!-- section anchor="cost" title="The Cost() function" -->

  <section anchor="loopfree" title="The LoopFree() function">

  <t> Since determining loop freedom is known to depend on comparing the
      Cost(R1) of advertised route update information to the Cost(R2) of an
      existing stored route using the same metric type, AODVv2 invokes a
      function called "LoopFree(R1, R2)".  LoopFree(R1, R2) returns TRUE when
      R1 is guaranteed to not rely on the route R2, i.e. R2 is not a
      subroute of the route R1.  An AODVv2 router invokes LoopFree() to
      compare an advertised route to a stored route. The advertised
      route is referred to as AdvRte and is used as parameter R1. The
      stored route is referred to as Route and is used as parameter R2.
  </t>

  </section> <!--section anchor="loopfree" title="The LoopFree() function" -->

  <section anchor="default_metric" title="Default Metric type">

    <t> The default MetricType (DEFAULT_METRIC_TYPE) is HopCount (but see
        <xref target="alternate"/>). HopCount is the only metric
        described in detail in this document. For the HopCount metric, Cost(L)
        is always 1, and Cost(R) is the hop count between the router
        and the destination.
    </t>
    <t>
        MAX_METRIC[DEFAULT_METRIC_TYPE] is defined to be MAX_HOPCOUNT.
        MAX_HOPCOUNT MUST be larger than the AODVv2 network diameter.
        Otherwise, AODVv2 protocol messages may not reach their
        intended destinations.
    </t>
    <t> Using MetricType DEFAULT_METRIC_TYPE, LoopFree (AdvRte, Route)
        is TRUE when Cost(AdvRte) &le; Cost(Route). The specification of
        Cost(R) and LoopFree(AdvRte, Route) for metric types other than
        DEFAULT_METRIC_TYPE is beyond the scope of this document.
    </t>
  </section><!-- section anchor="default_metric" title="Default Metric type" -->

  <section anchor="alternate" title="Alternate Metrics">
  <t> Some applications may require metric information other than HopCount,
      which has traditionally been the default metric associated with routes
      in MANET.  It is well known that reliance on HopCount can cause selection
      of the worst possible route in some situations.  For this reason,
      AODVv2 enables route selection based on metric information other than
      HopCount -- in other words, based on "alternate metrics".
  </t>
  <t> The range and data type of each such alternate metric may be
      different. For instance, the data type might be integers, or
      floating point numbers, or restricted subsets thereof.
      It is out of the scope of this document to specify for alternate
      metrics the Cost(L) and Cost(R) functions, or their return type.
      Where necessary these should take into account any differences in the
      link cost in each direction.  </t>
  </section> <!--anchor="alternate" title="Alternate Metrics"-->
</section>   <!-- section anchor="metrics" title="Metrics"  -->


<section anchor="aodv_ops" title="AODVv2 Protocol Operations">

<t>
    In this section, operations are specified for updating the route table
    using information within AODVv2 RteMsgs (either RREQ or RREP),
    and due to timeouts.  AdvRte is the route advertised by the RteMsg.
    RteMsgs include IP addresses as well as possibly the SeqNum and the
    prefix lengths associated with those IP addresses.  The AdvRte also
    includes the metric measured from the neighbor transmitting the RteMsg
    to the IP address originating the route update.
    <!--  A RREQ message advertises a route to OrigAddr, and
          a RREP message analogously advertises a route to TargAddr.  -->
    All SeqNum comparisons use signed 16-bit arithmetic.</t>

  <section anchor="test" title="Evaluating Incoming Routing Information">

  <t> After determining that the incoming information is correctly formatted
      and contains values in the correct ranges, the AODVv2 router will use
      the information to update local routing information if possible. This
      section explains how to determine whether the incoming information
      should be used to update the route table, and how to perform the update.
  </t>

  <t> The incoming RteMsg may be a RREQ or a RREP. If it is a RREQ, it
      contains information about a route to OrigAddr. Prefix length information
      in a RREQ, if present, describes the subnet on which OrigAddr resides.
      If it is a RREP, it contains information about a route to TargAddr.
      AdvRte is used to denote the route information
      contained in the RteMsg. AdvRte has the following properties:
     <list style="symbols">
     <t>AdvRte.Address = OrigAddr (in RREQ) or TargAddr (in RREP).</t>

     <t>AdvRte.SeqNum = OrigSeqNum (in RREQ) or TargSeqNum (in RREP).</t>

     <t>AdvRte.MetricType = RteMsg.MetricType, if present,
        else DEFAULT_METRIC_TYPE.</t>

     <t>AdvRte.Metric = RteMsg.Metric.</t>

     <t>AdvRte.Cost = AdvRte.Metric + Cost(L) according to the indicated
        MetricType, where L is the link from the advertising router.</t>

     <t>AdvRte.ValidityTime = ValidityTime in the RteMsg, if present.</t>
     </list>

     In the description below, Route denotes the stored routing table
     entry and HandlingRtr is the router receiving the RteMsg.  HandlingRtr
     MUST process the incoming information as follows.  If the routing table
     does not contain an entry matching AdvRte's Address and MetricType,
     <!--  and PrefixLength?  -->
	create a new route table entry according to the procedure in
	<xref target="update_rte"/>.
     Otherwise determine whether or not to use AdvRte for updating the route
     entry (Route) matching the AdvRte's Address and MetricType as follows:
     <list style="numbers">

<!--  [VM: the considerations here are similar as for RERR I believe]?  -->
<!--  and PrefixLength?  -->

  <t>Check whether AdvRte is stale (AdvRte.SeqNum &lt; Route.SeqNum).
     <list style="symbols">
	<t> If AdvRte's sequence number is newer, HandlingRtr MUST use AdvRte
	    to update the Route.</t>
        <t> If stale, using the incoming information might result in a routing
            loops. In this case the HandlingRtr MUST NOT use AdvRte
	    to update the Route.</t>
    	<t> If the SeqNums are equal, continue checking as below.
	    </t>
     </list></t>

  <t>Check whether AdvRte advertises a more costly route
        (AdvRte.Cost >= Route.Metric).
        <list style="symbols">
        <t> If the advertised route's cost is the same or greater than the
            stored route, and the stored route is valid, the incoming
            information does not offer any improvement and SHOULD
            NOT be used to update the stored route table entry.</t>
	<t> If the advertised route's cost is lower than the stored route,
	    AdvRte offers improvement and SHOULD be used to update
	    the stored route table entry.</t>
        <t> If the advertised route's cost is the same or greater than the
            stored route, but the stored route's state is Invalid, continue
            processing to see whether there is a danger of a routing loop.
            </t>
            <!-- CEP: will go Active if used... -->
      </list></t>

  <t>Check whether the information is safe against loops
       (LoopFree (AdvRte, Route) == TRUE).
       <list style="symbols">
       <t> If LoopFree (see <xref target="loopfree"/>) returns false, using the
           incoming information might cause a routing loop.  AdvRte MUST NOT
           be used to update the stored route table entry. </t>
       </list></t>

  <t>If the advertised route can be used to update the route table entry,
        follow the procedure in <xref target="update_rte"/>.</t>

  </list>

     The above conditions about whether to use AdvRte for updating an
     existing route table entry correspond to the following logic:
     <figure>
   <artwork><![CDATA[
   (AdvRte.SeqNum > Route.SeqNum) OR
     ((AdvRte.SeqNum == Route.SeqNum) AND
          [((Route.State == Invalid) && LoopFree (AdvRte, Route)) OR
            (AdvRte.Cost < Route.Metric)                         ])
  ]]></artwork>
     </figure>

     To briefly summarize, AdvRte must satisfy the following conditions
     compared to the existing route table entry before it can be used:
     <list style="symbols">
        <t>AdvRte is more recent,
		    (i.e., AdvRte.SeqNum &gt; Route.SeqNum) OR</t>
	<t>AdvRte is not stale and can safely restore an invalid route
		(i.e. LoopFree (AdvRte, Route) == TRUE), OR</t>
        <t>AdvRte is not stale and is less costly.</t>
        </list>
  </t>

  <t> If the route has been updated based on information in a received RREQ,
      the AODVv2 router MAY force regeneration of the RREQ, to ensure the most
      recent information is propagated to other routers, but it MAY suppress
      this to avoid extra control traffic.</t>

  </section>

  <section anchor="update_rte"
      title="Applying Route Updates To Route Table Entries">
  <t> To apply the route update, a route table entry for AdvRte.Address is
      either found to already exist in the route table, or else a new route
      table entry for AdvRte.Address is created and inserted into the route
      table.  If the route table entry had to be created, or if the state is
      Invalid, the state is set to be Idle.  The fields of route table entry
      are assigned as follows:
  <list style="symbols">
    <t>If AdvRte.PrefixLength exists, then Route.PrefixLength :=
       AdvRte.PrefixLength.  Otherwise, Route.PrefixLength :=
       maximum length for address family (either 32 or 128).</t>
    <t>Route.SeqNum := AdvRte.SeqNum</t>
    <t>Route.NextHop := IP.SourceAddress (i.e., the address from which the
       RteMsg was received)</t>
    <t>Route.NextHopInterface is set to the interface on which
       RteMsg was received</t>
    <t>Route.MetricType := AdvRte.MetricType</t>
    <t>Route.Metric := AdvRte.Cost</t>
    <t>Route.LastUsed := Current_Time</t>
    <t>Route.LastSeqnum := Current_Time</t>
    <t>If RteMsg.ValidityTime is included, then
	    <vspace/>
      Route.ExpirationTime := Current_Time + RteMsg.ValidityTime and
      Route.Timed := TRUE.
      Otherwise, Route.Timed := FALSE and Route.ExpirationTime := MAXTIME.
      </t>
   </list>
  </t>

  <t>With these assignments to the route table entry, a route has been
     made available, and the route can be used to send any buffered data
     packets (and subsequently to forward any incoming data packets) for
     Route.Address. An updated route entry also fulfills any outstanding
     route discovery (RREQ) attempts for Route.Address. Any retry timers
     for the RREQ SHOULD be cancelled.</t>
  </section>

  <section anchor="route_maint" title="Route Maintenance">

  <t> AODVv2 routers attempt to maintain active routes.  Before using a
      route to forward a packet, an AODVv2 router MUST check the status
      of the route as specified in <xref target="timeout"/>.  If the route
      has been marked as Invalid, it cannot be used for forwarding.
      Otherwise, set Route.LastUsed := Current_Time, Route.State := Active,
      and forward the packet to the route's next hop.  .</t>

  <t> When a routing problem is encountered, an AODVv2 router (denoted
      RERR_Gen) sends the RERR to quickly notify upstream routers.
      Two kinds of routing problems can trigger generation of a RERR
      message.  The first happens when the router receives a packet
      but does not have a valid route for the destination of the packet.
      The second case happens immediately upon detection of a broken
      link (see <xref target="blacklists"/>) for an valid route. </t>

  <t> Optionally, if a precursor list is maintained for the route, see
      <xref target="precursor"/> for precursor lifetime operations. </t>

  </section>

  <section anchor="timeout" title="Route Table Entry Timeouts">

  <t>During normal operation, AODVv2 does not require any explicit timeouts
     to manage the lifetime of a route.  At any time, any route table entry
     can be examined and then either expunged or marked as Invalid according
     to the following rules.</t>

  <t>The following rules are used to manage the state of route table entries:
  <list style="symbols">

  <t> If Current_Time &gt; Route.ExpirationTime, set Route.State := Invalid.</t>
  <t> If (Current_Time - Route.LastUsed) &gt; (ACTIVE_INTERVAL + MAX_IDLETIME),
        and if (Route.Timed == FALSE), set Route.State := Invalid.</t>
  <t> If (Current_Time - Route.LastUsed) &gt; ACTIVE_INTERVAL, and if
        (Route.Timed == FALSE), set Route.State := Idle.</t>

  <t> If (Current_Time - Route.LastSeqNum &gt; MAX_SEQNUM_LIFETIME), and the
      route is Invalid, the route table entry MUST be expunged.  If the route
      is not invalid and MAX_SEQNUM_LIFETIME has expired, the SeqNum
      information should be removed from the route, to avoid problems
      with boot sequence and lost SeqNum behaviour.</t>
     <!-- JPD: Is this a security vulnerability if a faulty
          or malicious router sets a short validity time?

          CEP: I don't think it affects authenticity, but it could be a form of
          denial of service.  In that case, it's no worse than if the malicious
          router simply refuses to route the packets it has agreed to route. -->
  </list>

  Memory constrained devices MAY choose to expunge routes from the AODVv2
  route table at other times, but MUST adhere to the following rules:

  <list style="symbols">
  <t> An Active route MUST NOT be expunged.</t>
  <t> An Idle route SHOULD NOT be expunged.</t>
  <t> Any Invalid route MAY be expunged (least recently used first).</t>
  </list>

  If precursor lists are maintained for the route (as described in
  <xref target="precursor"/>) then the precursor lists must also be
  expunged at the same time that the route itself is expunged.
  </t>
  </section>

  <section anchor="route_discovery"
        title="Route Discovery, Retries and Buffering">
  <t>AODVv2 message types RREQ and RREP are together known as Routing
    Messages (RteMsgs) and are used to discover a route between
    an Originating and Target Address, denoted by OrigAddr and
    TargAddr.  The constructed route is bidirectional, enabling
    packets to flow between OrigAddr and TargAddr.  RREQ and RREP
    have similar information and function, but have some
    differences in their rules for handling. When a node receives
    a RREQ or a RREP, the node then creates or updates a route to
    the OrigAddr or the TargAddr respectively (see <xref target="test"/>).
    The main difference between the two messages is that, by default, RREQ
    messages are multicast to solicit a RREP, whereas RREP is unicast as a
    response to RREQ.</t>

    <t>When an AODVv2 router needs to forward a data packet from a node
      (with IP address OrigAddr) in its set of router clients, and it
    does not have a forwarding route toward the packet's IP
    destination address (TargAddr), the AODVv2 router
    (RREQ_Gen) generates a
    RREQ (as described in <xref target="RREQ_gen"/>) to
    discover a route toward TargAddr.  Subsequently RREQ_Gen awaits
    reception of an RREP message (see <xref target="RREP_gen"/>)
    or other route table update (see <xref target="update_rte"/>)
    to establish a route toward TargAddr.
<!-- CEP: Issue # to be generated for moving DestOnly to the irrep draft...
    Optionally, RREQ_Gen MAY specify that only the router serving
    TargAddr is allowed to generate an RREP message, by including
    the DestOnly data element (see <xref target="RREQ_gen" />).
  -->
    The RREQ message contains routing information to enable RREQ recipients
    to route packets one hop towards the OrigAddr, and the RREP message
    contains routing information to enable RREP recipients to route packets
    one hop towards the TargAddr.</t>

  <t>After issuing a RREQ, as described above RREQ_Gen awaits a
    RREP providing a bidirectional route toward the Target Address.
    If the RREP is not received within RREQ_WAIT_TIME, RREQ_Gen MAY retry
    the Route Discovery by generating another RREQ.  Route
    Discovery SHOULD be considered to have failed after
    DISCOVERY_ATTEMPTS_MAX and the corresponding
    wait time for a RREP response to the final RREQ.
    After the attempted Route Discovery has failed, RREQ_Gen
    MUST wait at least RREQ_HOLDDOWN_TIME before attempting
    another Route Discovery to the same destination.
  </t>

  <t>To reduce congestion in a network, repeated attempts at
     route discovery for a particular Target Address SHOULD utilize a
     binary exponential backoff.</t>

  <t>Data packets awaiting a route SHOULD be buffered by RREQ_Gen.  This
     buffer SHOULD have a fixed limited size (BUFFER_SIZE_PACKETS or
     BUFFER_SIZE_BYTES).  Determining which packets to discard first is a
     matter of policy at each AODVv2 router; in the absence of policy
     constraints, by default older data packets SHOULD be discarded first.
     Buffering of data packets can have both positive and negative effects
     (albeit usually positive).  Nodes without sufficient memory available for
     buffering SHOULD be configured to disable buffering by configuring
     BUFFER_SIZE_PACKETS = 0 and BUFFER_SIZE_BYTES = 0.  This will affect the
     latency required for launching TCP applications to new destinations.</t>

  <t> If a route discovery attempt has failed (i.e., DISCOVERY_ATTEMPTS_MAX
      attempts have been made without receiving a RREP) to find a route toward
      the Target Address, any data packets buffered for the corresponding
      Target Address MUST BE dropped and a Destination Unreachable ICMP message
      (Type 3) SHOULD be delivered to the source of the data packet.  The code
      for the ICMP message is 1 (Host unreachable error).  If RREQ_Gen is not
      the source (OrigNode), then the ICMP is sent to OrigAddr.</t>
  </section>

  <section anchor="suppress" title="Suppressing Redundant RteMsgs">

  <t> When RREQ messages are flooded in a MANET, an AODVv2 router may receive
      similar RREQ messages from more than one of its neighbours. To avoid
      processing and transmission associated with redundant RteMsgs,
      while still enabling proper handling of earlier RteMsgs that may
      have somehow been delayed in the network, it is necessary for each
      AODVv2 router store information about RteMsgs which it has recently
      received (see the RteMsg table defined in <xref target="supp-tbl"/>).
  </t>
  <t> When a RREQ is received, it is checked against the RteMsg Table to see
      if it contains redundant information. If so it does not need to be
      processed.
  </t>
  <t>For RREQ messages, the process for comparison is as follows:
      <list style="symbols">
      <t> Look for a "comparable" entry in the RteMsg Table with the same
          MsgType, OrigAddr, TargAddr, and MetricType. </t>

      <t> If there is none, create an entry to store information about the
          received RREQ, and continue to regenerate the RREQ.</t>

      <t> If there is an entry, and it has a lower SeqNum for OrigAddr
          than the received RREQ, update it using the new RREQ and continue
          to regenerate the RREQ.</t>

      <t> If there is an entry and it has a higher SeqNum for OrigAddr than the
          received RREQ, do not replace the entry and do not process the RREQ.
          </t>

      <t> If there is an entry and it has the same SeqNum for OrigAddr and a
          higher Metric than the received RREQ, update it with the new RREQ
          information.</t>

      <t> If there is an entry and it has the same SeqNum for OrigAddr and a
          Metric less than or equal to the received RREQ, do not replace the
          entry and do not regenerate the RREQ.</t>

      <t> In all cases, update the timestamp field, since other comparable
          RREQs may still be traversing the network.</t>
    </list>
    The process of comparison for optional multicast RREP messages is
    analogous, substituting RREP for RREQ, and TargAddr for OrigAddr.
    Entries in the RteMsg Table MUST be deleted after MAX_SEQNUM_LIFETIME, but
    should be maintained for at least RteMsg_ENTRY_TIME in order to account
    for long-lived RREQs traversing the network.
  </t>
  </section>

</section>

<section anchor="aodv_msgs" title="AODVv2 Protocol Messages">

  <t> This section specifies the data elements and values required in
      AODVv2 protocol messages, namely RREQ, RREP, RERR, and RREP_Ack.</t>

  <t> To avoid congestion, each AODVv2 router's rate of packet/message
      generation SHOULD be limited. The rate and algorithm for limiting
      messages (CONTROL_TRAFFIC_LIMIT) is left to the implementor and
      should be administratively configurable. AODVv2 messages SHOULD be
      discarded in the following order of preference: RREQ, RREP, RERR,
      and finally RREP_Ack.</t>

  <t> See <xref target="represent"/> for the mapping of AODVv2 data elements
      to RFC 5444 Message TLVs, Address Blocks, and Address TLVs.</t>


  <section anchor="RREQ_msgs" title="RREQ Messages">

  <t> RREQ messages are used in Route Discovery operations to request a route
      to a specified Target address.  RREQ messages have the following general
      format:</t>
  <t><figure anchor="RREQ_elem" title="RREQ message structure">
<artwork><![CDATA[
  +-----------------------------------------------------------------+
  |                   msg_hop_limit, msg_hop_count                  |
  +-----------------------------------------------------------------+
  |                      MetricType (optional)                      |
  +-----------------------------------------------------------------+
  |                 AddressList := {OrigAddr, TargAddr}             |
  +-----------------------------------------------------------------+
  | PrefixLengthList := {PrefixLength for OrigAddr, null}(optional) |
  +-----------------------------------------------------------------+
  |                 OrigSeqNum, (optional) TargSeqNum               |
  +-----------------------------------------------------------------+
  |             MetricList := {Metric for OrigAddr, null}           |
  +-----------------------------------------------------------------+
  | ValidityTimeList := {ValidityTime for OrigAddr, null}(optional) |
  +-----------------------------------------------------------------+
]]></artwork>
    </figure></t>

  <t> <list style="hanging">
  <t hangText="RREQ Data Elements">
     <list style="hanging">
     <t hangText="msg_hop_limit"><vspace/>
       The remaining number of hops allowed for dissemination of
       the RREQ message. </t>
     <t hangText="msg_hop_count"><vspace/>
       The number of hops already traversed during dissemination of
       the RREQ message. </t>
     <t hangText="MetricType"><vspace/>
         If MetricType != DEFAULT_METRIC_TYPE, the MetricType element is
         included and defines the MetricType associated with the entries in
         the MetricList.</t>
     <t hangText="AddressList"><vspace/>
       AddressList contains OrigAddr and TargAddr.  </t>
     <t hangText="PrefixLengthList"><vspace/>
       PrefixLengthList contains the length of the prefix for OrigAddr,
       if OrigAddr resides on a Client Network with a prefix length shorter
       than the number of bits of the address family for OrigAddr.</t>
     <t hangText="OrigSeqNum"><vspace/>
       OrigSeqNum or TargSeqNum is REQUIRED and carries the destination
       sequence number associated with OrigNode.</t>
     <t hangText="TargSeqNum"><vspace/>
       TargSeqNum is optional and carries a destination sequence number
       associated with TargNode.  </t>
     <t hangText="MetricList"><vspace/>
       The MetricList data element is REQUIRED, and carries the
       route metric information associated with OrigAddr. </t>
     <t hangText="ValidityTimeList"><vspace/>
       The ValidityTimeList is optional and carries the length of time that
       the sender is willing to offer a route towards OrigAddr.</t>
     </list> </t>
  </list>

      RREQ messages carry information about OrigAddr and TargAddr, as identified
      in the context of the RREQ_Gen.  The OrigSeqNum MUST appear. Both MAY
      appear in the same RREQ when SeqNum is available for both OrigAddr and
      TargAddr.
  </t>

  <t> The OrigSeqNum data element in a RteMsg MUST apply only to OrigAddr.
      The other address in the AddressList is TargAddr. </t>

  <t> If the TargSeqNum data element appears, then it MUST apply only to
      TargAddr.  The other address in the AddressList is OrigAddr.  </t>

  <section anchor="RREQ_gen" title="RREQ Generation">

  <t> Upon receiving an IP packet from one of its Router Clients, it often
      happens that an AODVv2 router has no valid route to the destination.
      In this case the AODVv2 router is responsible for generating a RREQ and
      associated data elements on behalf of its client OrigNode. The router
      is referred to as RREQ_Gen.  Before creating a RREQ, RREQ_Gen should
      check if an RREQ has recently been sent for
      this destination and a response is awaited,
      or if the limit of AODVv2 RREQ retries has been reached. </t>

  <t> In constructing the RREQ, RREQ_Gen uses AddressList, OrigSeqNum,
      MetricList, and optionally MetricType, PrefixLengthList, TargSeqNum,
      and ValidityTime.</t>

  <t> RREQ_Gen follows the steps in this section.  OrigAddr MUST be a unicast
      address.  The order of data elements is illustrated schematically in
      <xref target="RREQ_elem"/>.  RREQ_Gen SHOULD include TargSeqNum,
      if a previous value of the TargAddr's SeqNum is known (e.g.
      from an invalid route table entry using longest-prefix matching).
      If TargSeqNum is not included, AODVv2 routers handling the
      RREQ assume that RREQ_Gen does not have that information.

  <list style="numbers">
  <t>Set msg_hop_limit to MAX_HOPCOUNT.</t>
  <t>Set msg_hop_count to zero, if including it.</t>
  <t>Include the MetricType data element if requesting a route for a non-default
     metric type.</t>
  <t>Set AddressList := {OrigAddr, TargAddr}.</t>
  <t>For the PrefixLengthList:
      <list style="symbols">
      <t>If OrigAddr resides on a subnet of Router Clients,
         set PrefixLengthList := { OrigAddr subnet's prefix, null }.</t>
      <t>Otherwise, the PrefixLengthList is omitted.</t>
     </list> </t>
  <t>For the Sequence Number List:
     <list style="symbols">
	<t>Increment the SeqNum as specified in <xref target="seqnum"/>.</t>
	<t>Set OrigSeqNum to the new value of SeqNum. </t>
	<t>If an Invalid route exists matching TargAddr using longest
	   prefix matching, include TargSeqNum and set it to the sequence
	   number on the Invalid route. Otherwise omit TargSeqNum.</t>
     </list> </t>
  <t>Set MetricList := { Route[OrigAddr].Metric, null }.</t>
  <t>If the RREQ_Gen wishes to limit the time that the route to OrigAddr
     may be used, include the ValidityTime data element.</t>
  </list> </t>

<!-- CEP: Issue # to be generated for moving DestOnly to the irrep draft...
  <t>If RREQ_Gen requires that only the router providing connectivity
     to TargAddr is allowed to generate a RREP, then RREQ_Gen includes
     the "Destination RREP Only" (DestOnly) TLV as part of the RFC 5444
     message header.  This also assures that RREP_Gen increments its
     sequence number.  Otherwise, (if the optional behavior is enabled)
     other AODVv2 routers MAY respond to the RREQ if they have a
     valid route to TargAddr (see <xref target="iRREP" />). </t>

  <t> By default the RREQ message is multicast to LL-MANET-Routers. An example
      RREQ message format is illustrated in <xref target="RREQ-format"/>. </t>
  -->
  </section>

  <section anchor="RREQ_rcv" title="RREQ Reception">

  <t> Upon receiving an RREQ, an AODVv2 router performs the following steps.

  <list style="numbers">
  <t> A router MUST handle RREQs only from neighbors.  RREQs from nodes
      that are not neighbors MUST be disregarded.</t>
  <t> Check whether the sender is on the blacklist of AODVv2 routers
      (see <xref target="blacklists"/>).  If not, continue processing.
      Otherwise, check the Blacklist Remove Time.
      <list style="symbols">
      <t>If Current_Time &lt; Remove Time, ignore this RREQ for
         further processing.</t>
      <t>If Current_Time &ge; Remove Time, remove the Blacklist entry
         and continue processing.</t>
     </list>  </t>
  <t> Verify that the message contains the required data elements:
      msg_hop_limit, OrigAddr, TargAddr, OrigSeqNum, OrigAddrMetric, and
      verify that OrigAddr and TargAddr are valid addresses (routable and
      unicast).  If not, ignore this message for further processing.
  </t>
  <t> If the MetricType data element is present, check that
      the MetricType is known.
      <list style="symbols">
      <t>If not, ignore this RREQ for further processing.</t>
      <t>Otherwise continue processing .</t>
      </list>  </t>
  <t> Verify that OrigAddrMetric &le; {MAX_METRIC[MetricType] - Cost(Link)}.
      <list style="symbols">
      <t>If not, ignore this RREQ for further processing.</t>
      <t>Otherwise continue processing .</t>
      </list>  </t>
  <t>Process the route to OrigAddr as specified in <xref target="test"/>. </t>
  <t> Check if the message is a duplicate or redundant by comparing to
      entries in the RteMsg table as described in <xref target="suppress"/>.
      <list style="symbols">
      <t>If duplicate or redundant, ignore this RREQ for further processing.</t>
      <t>Otherwise save the information in the RteMsg table to identify future
         duplicates and continue processing.</t>
     </list>  </t>
  <t>Check if the TargAddr belongs to one of the Router Clients.
      <list style="symbols">
      <t>If so, generate a RREP as specified in <xref target="RREP_gen"/>.</t>
      <t>Otherwise, continue to RREQ regeneration.</t>
      </list>  </t>
  </list>  </t>
  </section> <!-- anchor="RREQ_rcv" title="RREQ Reception" -->


  <section anchor="RREQ_regen" title="RREQ Regeneration">


  <t>Unless the router is prepared to advertise the new route, it halts
     processing. By sending a RREQ, a router advertises that it will
     forward packets to the OrigAddr contained in the RREQ according to the
     information enclosed. The router MAY choose not to regenerate the RREQ,
     though this could decrease connectivity in the network or result in
     non-optimal paths.
  </t>

  <t>The circumstances under which a router MAY choose not to regenerate
     a RREQ are not specified in this document.  Some examples may
     include the router being heavily loaded and not advertising
     routing for more traffic, or being low on energy and having to reduce
     energy expended for sending AODVv2 messages or packet forwarding.
  </t>

  <t>
     The procedure for RREQ regeneration is as follows:

  <list style="numbers">

  <t>Check the msg_hop_limit.
      <list style="symbols">
      <t>If it is zero, do not regenerate.</t>
      <t>Otherwise, decrement the value by one.</t>
      </list>  </t>

  <t>Check if msg_hop_count is present and greater than or equal to MAX_HOPCOUNT
      <list style="symbols">
      <t>If so, do not regenerate.</t>
      <t>Otherwise, increment msg_hop_count by one.</t>
      </list>  </t>

  <t>Change OrigAddrMetric to match the route table entry for OrigAddr,
     which should match the advertised value in the received RREQ plus
     the cost of the link to the router which forwarded the RREQ.</t>

  <t>If the incoming RREQ contains a ValidityTimeList, it MUST be copied into
     the regenerated RREQ. If not present, and the regenerating router wishes
     to limit the time that its route to OrigAddr may be used, set
     ValidityTimeList := {ValidityTime for OrigAddr, null}.</t>
  </list>  </t>

  <t>If the received RREQ was unicast, the regenerated RREQ can be unicast to
     the next hop address of the route towards TargAddr, if known. Otherwise,
     the RREQ SHOULD be multicast to the LL-MANET-Routers IP and MAC address
     <xref target="RFC5498"/>, <xref target="RFC4291"/>.</t>

  </section> <!-- anchor="RREQ_regen" title="RREQ Regeneration" -->

  </section> <!-- section anchor="RREQ_msgs" title="RREQ Messages"  -->

  <section anchor="RREP_msgs" title="RREP Messages">

  <t>RREP messages are used to offer a route to a target address, and are sent
     in response to a RREQ message.  RREP messages have the following general
     format:</t>
  <t><figure anchor="figRREP" title="RREP message structure">
<artwork><![CDATA[
  +-----------------------------------------------------------------+
  |                   msg_hop_limit, msg_hop_count                  |
  +-----------------------------------------------------------------+
  |             AckReq (optional), MetricType (optional)            |
  +-----------------------------------------------------------------+
  |                 AddressList := {OrigAddr,TargAddr}              |
  +-----------------------------------------------------------------+
  | PrefixLengthList := {null, PrefixLength for TargAddr(optional)} |
  +-----------------------------------------------------------------+
  |                            TargSeqNum                           |
  +-----------------------------------------------------------------+
  |            MetricList := {null, metric for TargAddr}            |
  +-----------------------------------------------------------------+
  | ValidityTimeList := {null, ValidityTime for TargAddr}(optional) |
  +-----------------------------------------------------------------+
]]></artwork>
    </figure></t>

  <t> <list style="hanging">
  <t hangText="RREP Data Elements">
     <list style="hanging">
     <t hangText="msg_hop_limit"><vspace/>
       The remaining number of hops allowed for dissemination of
       the RREP message. </t>
     <t hangText="msg_hop_count"><vspace/>
       The number of hops already traversed during dissemination of
       the RREP message. </t>
     <t hangText="AckReq"><vspace/>
       Acknowledgement Requested by sender (optional). </t>
     <t hangText="MetricType"><vspace/>
       If MetricType != DEFAULT_METRIC_TYPE, the MetricType
       associated with route to TargAddr. </t>
     <t hangText="AddressList"><vspace/>
       AddressList contains OrigAddr and TargAddr.  </t>
     <t hangText="PrefixLengthList"><vspace/>
       PrefixLengthList contains the length of the prefix for TargAddr,
       if TargAddr resides on a Client Network with a prefix length shorter
       than the number of bits of the address family for TargAddr.</t>
     <t hangText="TargSeqNum"><vspace/>
       TargSeqNum is REQUIRED and carries the destination sequence number
       associated with TargNode.  </t>
     <t hangText="MetricList"><vspace/>
       The MetricList data element is REQUIRED, and carries the route metric
       information associated with TargAddr. </t>
     <t hangText="ValidityTimeList"><vspace/>
       The ValidityTimeList is optional and carries the length of time that
       the sender is willing to offer a route towards TargAddr. </t>
     </list> </t>
  </list>

    RREP messages carry information about OrigAddr and TargAddr, as known in
    the context of the RREP_Gen.  The TargSeqNum MUST appear.  It MUST apply
    only to TargAddr.  The other address in the AddressList is OrigAddr.</t>

  <section anchor="RREP_gen" title="RREP Generation">

  <t> This section specifies the generation of an RREP by an AODVv2
      router (RREP_Gen) that provides connectivity for TargAddr, thus
      enabling the establishment of a route between OrigAddr and TargAddr.
      In constructing the RREP, AODVv2 uses AddressList, TargSeqNumber List,
      MetricList, and optionally AckReq, MetricType, PrefixLengthList and/or
      ValidityTimeList.  These elements are then used to create a RFC5444
      message; see <xref target="represent"/> for details.</t>

  <t> The AckReq data element indicates that an acknowledgement to the RREP
      has been requested. If no corresponding RREP_Ack is received within the
      RREP_Ack_SENT_TIMEOUT, the next hop is added to the blacklist as
      discussed in <xref target="blacklists"/>.</t>

  <t> The procedure for RREP generation is as follows:

  <list style="numbers">
  <t> Set msg_hop_limit to the msg_hop_count from the received RREQ message.</t>
  <t> Set msg_hop_count, if including it, to zero.</t>
  <t> Include the AckReq data element if RREP_Ack is requested from the next
      hop (as described in <xref target="blacklists"/>).</t>
  <t> If MetricType is not DEFAULT_METRIC_TYPE, include the MetricType data
      element and set the type accordingly.</t>
  <t> Set the Address List := {OrigAddr, TargAddr}.</t>
  <!-- =========================================================== -->
  <t> For the PrefixLengthList:
      <list style="symbols">
      <t> If TargAddr resides on a subnet of Router Clients,
          set PrefixLengthList := {null, TargAddr subnet's prefix}.</t>
      <t> Otherwise, no PrefixLengthList is needed.</t>
     </list> </t>
  <!-- =========================================================== -->
  <t> For the TargSeqNum:
     <list style="symbols">
	<t> RREP_Gen increments its SeqNum as specified in
					<xref target="seqnum"/>.</t>
	<t> Set TargSeqNum := the new value of SeqNum. </t>
     </list>
     </t>
  <t> Set MetricList := { null, Route[TargAddr].Metric }.</t>
  <t> If the RREP_Gen wishes to limit the time that the route to TargAddr
      may be used, set ValidityTimeList := {null, TargAddr ValidityTime}.</t>
  </list> </t>

  <t> By default, the RREP is sent by unicast to the IP address of the next
      hop of the RREP_Gen's route to OrigAddr. <!-- An example message format
      for RREP is illustrated in <xref target="RREP-format"/>.  --></t>

  </section> <!-- anchor="RREP_gen" title="RREP Generation" -->

  <section anchor="RREP_rcv" title="RREP Reception">

  <t> Upon receiving an RREP, an AODVv2 router performs the following steps.

  <list style="numbers">
  <t> A router MUST handle RREPs only from neighbors.  RREPs from nodes
      that are not neighbors MUST be disregarded.</t>
  <t> Verify that the RREP message contains the required data elements:
      msg_hop_limit, OrigAddr, TargAddr, TargAddrMetric, TargSeqNum, and
      verify that OrigAddr and TargAddr are valid addresses (routable and
      unicast).  If not, ignore this RREP message for further processing.</t>
  <t> If the MetricType data element is present, check that the
      MetricType is known.
      <list style="symbols">
      <t>If not, ignore this RREP for further processing.</t>
      <t>Otherwise continue processing .</t>
      </list>  </t>
  <t> Verify that TargAddrMetric &le; {MAX_METRIC[MetricType] - Cost(Link)}.
      <list style="symbols">
      <t>If not, ignore this RREP for further processing.</t>
      <t>Otherwise continue processing .</t>
      </list>  </t>
  <t>Process the route to TargAddr as specified in <xref target="test"/>. </t>
  <t>If the AckReq data element is present, send a RREP_Ack as specified in
  		<xref target="rrep_ack"/>. </t>
  <t> Check if the message is a duplicate or redundant by comparing to
      entries in the RREP table as described in <xref target="suppress"/>.
      <list style="symbols">
      <t>If duplicate or redundant, ignore this RREP for further processing.</t>
      <t>Otherwise save the information in the RREP table to identify future
         duplicates and continue processing.</t>
     </list>  </t>
  <t>Check if the OrigAddr belongs to one of the Router Clients.
      <list style="symbols">
      <t>If so, the RREP satisfies a previously sent RREQ. Processing is
      	 complete and data can now be forwarded along the route. Any packets
         from OrigAddr that were buffered for later delivery SHOULD be
         transmitted.</t>
      <t>Otherwise, continue to RREP regeneration.</t>
      </list>  </t>
  </list>  </t>
  </section> <!-- anchor="RREP_rcv" title="RREP Reception" -->

  <section anchor="RREP_regen" title="RREP Regeneration">

  <t>Similar to rules for RREQ regeneration, unless the router is prepared
     to advertise the route to TargAddr, it halts processing. By forwarding
     a RREP, a router advertises that it will forward packets to the TargAddr
     contained in the RREP according to the information enclosed. The router
     MAY choose not to regenerate the RREP, for the same reasons as mentioned
     under RREQ regeneration <xref target="RREQ_regen"/>, though this could
     decrease connectivity in the network or result in non-optimal paths.
  </t>

  <t>
      If no valid route exists to OrigAddr, a RERR SHOULD be transmitted
      to TargAddr as specified in <xref target="RERR_gen"/> and the RREP
      should not be regenerated.</t>

  <t> The procedure for RREP regeneration is as follows:
  <list style="numbers">
  <t> Check the msg_hop_limit.
      <list style="symbols">
      <t>If it is zero, do not regenerate.</t>
      <t>Otherwise, decrement the value by one.</t>
      </list>  </t>

  <t> If msg_hop_count is present, then:
      <list style="symbols">
      <t>If msg_hop_count &ge; MAX_HOPCOUNT, do not regenerate.</t>
      <t>Otherwise, increment msg_hop_count by one.</t>
      </list>  </t>

  <t> The RREP SHOULD be unicast to the next hop on the route to OrigAddr.
      If no valid route exists to OrigAddr, a RERR SHOULD be transmitted
      to TargAddr as specified in <xref target="RERR_gen"/>.</t>

  <t> Change TargAddrMetric to match the route table entry for TargAddr,
      which should match the advertised value in the received RREP plus the
      cost of the link to the router which forwarded the RREP.
  </t>

  <t>Include the AckReq data element if this device requires acknowledgement
     of the RREP message.
  </t>

  <t>If the incoming RREP contains a ValidityTimeList, it MUST be copied into
     the regenerated RREP. If not present, and the regenerating router wishes
     to limit the time that its route to TargAddr may be used, set
     ValidityTimeList := {null, ValidityTime for TargAddr}.
  </t>
  </list>
  The RREP SHOULD be unicast to the next hop on the route to OrigAddr.</t>

  </section> <!-- anchor="RREP_regen" title="RREP Regeneration" -->

  </section> <!-- section anchor="RREP_msgs" title="RREP Messages"  -->

<section anchor="RERR_msgs" title="RERR Messages">

  <t> An RERR message is generated by a AODVv2 router (i.e., RERR_Gen)
      in order to notify upstream routers that packets cannot be delivered
      to one or more destinations.
      An RERR message has the following general structure:
  <figure anchor="figRERRstruct" title="RERR message structure">
            <artwork><![CDATA[
  +-----------------------------------------------------------------+
  |                          msg_hop_limit                          |
  +-----------------------------------------------------------------+
  |           PktSource (optional), MetricType (optional)           |
  +-----------------------------------------------------------------+
  |                         RERR AddressList                        |
  +-----------------------------------------------------------------+
  |       PrefixLengthList for UnreachableAddresses (optional)      |
  +-----------------------------------------------------------------+
  |                SeqNumList (one entry per address)               |
  +-----------------------------------------------------------------+
]]>        </artwork> </figure>
    <list style="hanging">
    <t hangText="RERR Data Elements">
    <list style="hanging">
    <t hangText="msg_hop_limit"><vspace/>
      The remaining number of hops allowed for dissemination of
      the RERR message.</t>
    <t hangText="PktSource"><vspace/>
      The IP address of the unreachable destination triggering RERR
      generation.  If this RERR message was triggered by a broken link,
      the PktSource data element is not required. </t>
    <t hangText="MetricType"><vspace/>
      If MetricType != DEFAULT_METRIC_TYPE, the MetricType
      associated with routes affected by a broken link. </t>
    <t hangText="RERR AddressList"><vspace/>
      A list of IP addresses not reachable by the AODVv2 router
      transmitting the RERR. </t>
     <t hangText="PrefixLengthList"><vspace/>
       PrefixLengthList contains the prefix lengths associated
       with the addresses in the RERR AddressList,
       if any of them reside on a Client Network with a prefix length shorter
       than the number of bits of their address family.</t>
    <t hangText="SeqNumList"><vspace/>
      The list of sequence numbers associated with the
      UnreachableAddresses in the RERR AddressList.</t>
    </list>  </t>
  </list>  </t>

  <section anchor="RERR_gen" title="RERR Generation">

  <t> There are two types of events which trigger generation of a RERR message.
      The first is the arrival of a packet for which there is no route to the
      destination address.  This can be a packet forwarded by the routing
      process, or a RREP when there is no route to OrigAddr.  In this case,
      exactly one UnreachableAddress will be included in RERR's
      AddressList
      (either the Destination Address of the IP header from a data packet, or
      the OrigAddr found in the AddressList of an RREP message). RERR_Gen MUST
      <!-- CEP: To reconsider if we re-specify local repair.. -->
      discard the packet or message that triggered generation of the RERR.</t>

  <t> The second type of event happens when a link breaks.  All routes (whether
      valid or not) that use the broken link MUST be marked as Invalid.
      If the broken link was not used by any Active route, no RERR message
      is generated.  Every Invalid route reported in the RERR MUST have the
      same MetricType.  If the broken link affects routes to destinations that
      have different MetricTypes, multiple RERR messages must be generated.</t>

  <t> If an AODVv2 router receives an ICMP packet to or
      from the address of one of its client nodes, it simply forwards the
      ICMP packet, and does not generate any RERR message.</t>

  <t> In constructing the RERR, AODVv2 uses MetricType, AddressList,
      SeqNumList, MetricList, and in some cases PktSource and
      PrefixLengthList.  These elements are then used to create a RFC5444
      message; see <xref target="represent"/> for details.</t>

  <t>The procedure for RERR generation is as follows:
  <list style="numbers">
  <t>Set msg_hop_limit to MAX_HOPCOUNT.</t>
  <t>If the RERR was triggered by an Undeliverable Packet, the PktSource
     data element MUST be included, containing the source IP address of the
     Undeliverable Packet.</t>
  <t>Include the MetricType data element if reporting a Invalid route for a
     non-default metric type.</t>
  <t>For the RERR AddressList:
      <list style="symbols">
      <t>If the RERR was triggered by an undeliverable packet, insert the
         destination IP address of the undeliverable packet, or
         if the packet was a RREP, insert the OrigAddr.</t>
      <t>If the RERR was triggered by a broken link, include the addresses
         of all previously Active routes which are now Invalid, up to the
         limit imposed by the MTU (interface
         "Maximum Transfer Unit") of the physical medium. If there are too
         many such previously Active routes, additional RERR messages should
         be constructed and transmitted to contain the remaining addresses.
         If the configuration option ENABLE_IDLE_IN_RERR is enabled, include
         any previously Idle routes which are now Invalid, as long as the
         packet size of the RERR does not exceed the MTU.</t>
     </list> </t>
  <t>If there are destinations reported in the RERR AddressList that
     have associated subnet prefixes in the route table, insert those prefixes
     in the PrefixLengthList; otherwise, omit the PrefixLengthList.</t>
  <t>If known, the sequence numbers associated with the routes to the
     addresses in the RERR AddressList SHOULD be included in the
     SeqNumList; otherwise, omit the SeqNumList.</t>
  </list> </t>

  <t>If the RERR is sent in response to an Undeliverable Packet:
     <list style="symbols">
     <t>It SHOULD be sent unicast to the next hop towards the source IP
        address of the packet which triggered the RERR.</t>
     <t>Otherwise the RERR MUST be sent to the multicast IP and MAC address
        for LL-MANET-Routers.</t>
     </list> </t>

  <t>If the RERR is sent in response to a broken link:
     <list style="symbols">
     <t>If precursor lists are maintained for the addresses in the
        RERR AddressList (see <xref target="precursor"/>), the RERR
        SHOULD be unicast to the precursors.</t>
     <t>Otherwise the RERR MUST be sent to the multicast IP and MAC address
        for LL-MANET-Routers.</t>
     </list> </t>
  </section> <!-- anchor="RERR_gen" title="RERR Generation"  -->

<!-- NOTE:  CEP:  Verify unicast delivery of IP multicast packets ... -->
<!--
    If the neighbor's IP address is
    unavailable, RERR_Gen MAY attempt layer-2 unicast delivery
    to the multicast address LL-MANET-Routers.
  -->


  <section anchor="RERR_rcv" title="RERR Reception">

  <t>Upon receiving an RERR, the following steps are performed.

  <list style="numbers">
  <t>If the message does not contain the msg_hop_limit and at least one
     UnreachableAddress, do not process the RERR.</t>
  <t> If the MetricType data element is present, check that the MetricType
      is known.
      <list style="symbols">
      <t>If not, ignore this RERR for further processing.</t>
      <t>Otherwise continue processing .</t>
      </list>  </t>
  <t> For each UnreachableAddress,
      <list style="symbols">
      <t>Check that the address is valid (routable and unicast).</t>
      <t>Check that there is a valid route with the same MetricType
         matching the address using longest prefix matching.</t>
      <t>Check that the route's next hop is the sender of the RERR.</t>
      <t>Check that the route's next hop interface is the interface on
         which the RERR was received.</t>
      <t>Check that the Unreachable Address SeqNum is either unknown, or
         is greater than the route's SeqNum.</t>
      <t>If any of the above are false, the UnreachableAddress does not
         need to be advertised in a regenerated RERR.</t>
      <t>If all of the above are true:
         <list style="symbols">
         <t>If the route's prefix length is the same as the UnreachableAddress's
            prefix length, set the route state to Invalid.</t>
         <t>If the prefix length is shorter than the original route, the
            route MUST be expunged from the routing table, since it is a
            sub-route of the larger route which is reported to be Invalid.</t>
         <t>If the prefix length is different, create a new route with the
            UnreachableAddress and its prefix, and set the state to Invalid.</t>
         </list>  </t>
      </list>  </t>
  </list>  </t>
  <t>If there are no UnreachableAddresses which need to be advertised in a
     regenerated RERR, take no further action.</t>
  <t>Otherwise regenerate the RERR as specified in
  	<xref target="RERR_regen"/>. </t>

  </section> <!-- section anchor="RERR_rcv" title="RERR Reception"  -->

  <section anchor="RERR_regen" title="RERR Regeneration">

  <t> The procedure for RERR regeneration is as follows:
  <list style="numbers"> <t>Check the msg_hop_limit.
      <list style="symbols">
      <t>If it is zero, do not regenerate.</t>
      <t>Otherwise, decrement the value by one.</t>
      </list>  </t>
  <t>If the PktSource data element was included in the original RERR, copy it
     into the regenerated RERR.</t>
  <t>If the MetricType data element was included in the original RERR copy it
     into the regenerated RERR.</t>
  <t>For the RERR AddressList, include all UnreachableAddresses which
     have been determined to need regeneration.</t>
  <t>For the PrefixLengthList, insert the prefix lengths
     associated with the addresses in the RERR AddressList.</t>
  <t>For the SeqNumList, include the sequence numbers corresponding to the
       addresses in the RERR AddressList.</t>
  </list>  </t>

  <t>If the original RERR contained the PktSource data element, and a route
     exists to the source address, the regenerated RERR MUST be sent unicast
     to the next hop of the route towards PktSource.
  </t>

  <t>Otherwise, if precursor lists are maintained, the regenerated RERR
     SHOULD be sent to the active precursors of the Invalid routes as
     specified in <xref target="precursor"/>.
  </t>

  <t>Otherwise the regenerated RERR MUST be sent to the multicast IP and MAC
     address for LL-MANET-Routers.
  </t>

  </section> <!-- section anchor="RERR_regen" title="RERR Regeneration"  -->

  </section> <!-- section anchor="RERR_msgs" title="RERR Messages"  -->

 <section anchor="rrep_ack" title="RREP_Ack Messages">

 <t>RREP_Ack is modeled on the RREP_Ack message type from AODV
    <xref target="RFC3561"/>.   RREP_Ack messages have the following general
    format:</t>
  <t><figure anchor="figRREP_Ack" title="RREP_Ack message structure">
<artwork><![CDATA[
  +-----------------------------------------------------------------+
  |                       msg_hop_limit := 1                        |
  +-----------------------------------------------------------------+
]]></artwork>
    </figure></t>

  <t> <list style="hanging">
  <t hangText="RREP_Ack Data Elements">
     <list style="hanging">
     <t hangText="msg_hop_limit"><vspace/>
       The remaining number of hops allowed for dissemination of
       the RREP_Ack message. </t>
<!-- <t hangText="TargSeqNum"><vspace/>
       TargSeqNum as seen in the RREP, to allow matching with the RREP
       at the router requesting the acknowledgement.</t>  -->
     </list> </t>
  </list>

  </t>

  <section anchor="RREP_Ack_gen" title="RREP_Ack Generation">
  <t>This section specifies the generation of an RREP_Ack by an AODVv2
     router. The procedure is as follows:
  <list style="numbers">

  <t>Set msg_hop_limit := 1.</t>
<!--
  <t>Include the SeqNum := TargAddr's SeqNum from the RREP.</t>  -->

  </list> </t>

  <t> The RREP_Ack is sent by unicast to the IP address of router that inserted
      a AckReq data element into a RREP message.  <!-- An example message format
      for RREP_Ack is illustrated in <xref target="RREP_Ack-format"/>.  --> </t>

  </section> <!-- anchor="RREP_Ack_gen" title="RREP_Ack Generation" -->

  <section anchor="RREP_Ack_rcv" title="RREP_Ack Reception">

  <t> Upon receiving an RREP_Ack, an AODVv2 router performs the following steps.

  <list style="numbers">
  <t> A router MUST handle RREP_Acks only from neighbors.  RREP_Acks from nodes
      that are not neighbors MUST be disregarded.</t>

  <t> The router checks whether the sender's IP address is in the blacklist.
      If so, the IP address is deleted from the blacklist. </t>

<!-- CEP: Need to define RREP_Ack_timeout.  To avoid handling extra
     timeouts, should specify that the RREP_Ack_timeout is verified prior
     to sending forwarding RREQs from that neighbor.
     Actually, it would make sense to put the neighbor in the blacklist
     immediately upon sending AckReq...  -->

  <t> The router checks whether an RREP_Ack message was expected from the
  	sending IP address.  <!-- If so, the router checks to make sure that
  	the SeqNum corresponds to TargSeqNum as sent in the RREP
  	that requested the RREP_Ack message.  --> If so, the router records
  	that the required RREP_Ack has been received and cancels the
  	associated timeout.  </t>

  </list>  </t>
  </section> <!-- anchor="RREP_Ack_rcv" title="RREP_Ack Reception" -->

  </section> <!-- anchor="rrep_ack" title="RREP_Ack Messages  -->


</section>

<section anchor="represent"
        title="Representing AODVv2 data elements using RFC 5444">

  <t> AODVv2 specifies that all control plane messages between
      Routers SHOULD use the Generalised Mobile Ad-hoc Network Packet
      and Message Format <xref target="RFC5444"/>, which provides a
      multiplexed transport for multiple protocols.
      AODVv2 therefore specifies Route Messages comprising data elements
      that map to message elements in RFC5444 but, in line with the
      concept of use, does not specify which order the messages
      should be arranged in an RFC5444 packet. An implementation of
      an RFC5444 parser may choose to optimise the content of certain
      message elements to reduce control plane overhead.
      For handling of messages that contain unknown TLV types, the parser
      SHOULD ignore the information for processing, but preserve it
      unmodified for forwarding.</t>

  <t> Here is a brief summary of the RFC 5444 format.
      <list style="hanging">
      <t> A packet formatted according to RFC 5444
          contains zero or more messages. </t>
      <t> A message contains a message header,
          message TLV block, and zero or more address blocks.</t>
      <t> Each address block MAY also have one or more associated TLV blocks;
          each TLV block MAY encode multiple TLVs.
          Each TLV value in an Address TLV block is associated with
          exactly one of the addresses in the address block.</t>
      </list>
      The following table shows how AODVv2 data elements are represented in
      RFC 5444 messages. </t>

  <texttable anchor="DE_to_5444">
		<ttcol align="left" width="34%">Data Element</ttcol>
		<ttcol align="left">RFC 5444 Message Representation</ttcol>
  <c>msg_hop_limit</c>	<c>RFC 5444 Message Header &lt;msg-hop-limit&gt;</c>
  <c>msg_hop_count</c>	<c>RFC 5444 Message Header &lt;msg-hop-count&gt;</c>
  <c>AckReq</c>			<c>Acknowledgement Request Message TLV</c>
  <c>MetricType</c>		<c>The Metric Type Message TLV</c>
  <c>PktSource</c>		<c>The Packet Source Message TLV</c>
  <c>RteMsg AddressList</c>	<c>RFC 5444 Address Block</c>
  <c> - &nbsp; OrigAddr</c>			<c>&nbsp;</c>
  <c> - &nbsp; TargAddr</c>			<c>&nbsp;</c>
  <c> - &nbsp; PrefixLengthList</c>		<c>&nbsp;</c>
  <c>RERR AddressList</c>	<c>RFC 5444 Address Block</c>
  <c> - &nbsp; UnreachableAddress</c>		<c>&nbsp;</c>
  <c> - &nbsp; PrefixLengthList</c>		<c>&nbsp;</c>
  <c>SeqNumList</c>		<c>Sequence Number Address Block TLV</c>
  <c> - &nbsp; SeqNum</c>			<c>&nbsp;</c>
  <c>OrigSeqNum</c>   <c>Originating Node Sequence Number Address Block TLV</c>
  <c>TargSeqNum</c>   <c>Target Node Sequence Number Address Block TLV</c>
  <c>MetricList</c>		<c>Metric Address Block TLV</c>
  <c> - &nbsp; OrigAddrMetric</c>	<c> - corresponds to OrigAddr</c>
  <c> - &nbsp; TargAddrMetric</c>	<c> - corresponds to TargAddr</c>
  <c>ValidityTimeList</c>	<c>VALIDITY_TIME Address Block TLV</c>
  <c> - &nbsp; ValidityTime</c>	<c>&nbsp;</c>

  </texttable> <!-- texttable anchor="DE_to_5444" -->

  <t>
      If a packet contains only a single AODVv2 message and no packet TLVs,
      it need only include a minimal Packet-Header <xref target="RFC5444"/>.
      The length of an address (32 bits for IPv4 and 128 bits for IPv6) inside
      an AODVv2 message is indicated by the msg-addr-length (MAL) in the
      msg-header.  Although the addresses in an Address Block may appear in
      any order, each TLV value in a TLV Block is associated with exactly
      one Address in the Address Block.  So, for instance, the ordering of
      the OrigAddrMetric and TargAddrMetric values in the MetricList is
      determined by the order of OrigAddr and TargAddr in the preceding
      RteMsg Address List.
      See <xref target="msgtlvtypes"/> for more
      information about AODVv2 Message TLVs.   See <xref target="addrtlvspec"/>
      for more information about AODVv2 Address Block TLVs.
  </t>
<!-- Deleted / Issue #28 - - >
  <t> When multiple messages are aggregated into a single packet according
      to RFC 5444 formatting, and the aggregation of messages is also
      authenticated (e.g., with IPsec), and the IP destination is multiple
      hops away, it becomes infeasible to delete individual messages.  In such
      cases, instead of deleting individual messages, they are maintained
      in the aggregation of messages, but simply ignored for further
      processing.  In such cases where individual messages cannot be
      deleted, in this document "disregarded" means "ignored".  Otherwise,
      any such "disregarded" AODVv2 messages SHOULD be deleted from
      the aggregated messages in the RFC 5444 packet.  </t>
< ! - - Deleted / Issue #28 -->
</section> <!-- section anchor="represent"
        	title="Representing AODVv2 data elements using RFC 5444" -->

<section anchor="gateway" title="Simple Internet Attachment">
  <t> Simple Internet attachment means attachment of a stub
      (i.e., non-transit) network of AODVv2 routers to the
      Internet via a single Internet AODVv2 router (called IAR).</t>

  <t> As in any Internet-attached network, AODVv2 routers, and their clients,
      wishing to be reachable from hosts on the Internet MUST have IP addresses
      within the IAR's routable and topologically correct prefix
      (e.g. 191.0.2.0/24).</t>

    <figure anchor="net_top" title="Simple Internet Attachment Example">
      <artwork><![CDATA[
     /-------------------------\
    / +----------------+        \
   /  |  AODVv2 Router |         \
   |  |  191.0.2.2/32  |         |
   |  +----------------+         |            Routable
   |                       +-----+--------+   Prefix
   |                       |   Internet   |  /191.0.2/24
   |                       | AODVv2 Router| /
   |                       |  191.0.2.1   |/      /---------------\
   |                       | serving net  +------+    Internet     \
   |                       |  191.0.2/24  |      \                 /
   |                       +-----+--------+       \---------------/
   |         +----------------+  |
   |         |  AODVv2 Router |  |
   |         |  191.0.2.3/32  |  |
   \         +----------------+  /
    \                           /
     \-------------------------/
]]></artwork>
    </figure>


  <t>When an AODVv2 router within the AODVv2 MANET wants to discover
     a route toward a node on the Internet, it uses the normal AODVv2
     route discovery for that IP Destination Address. The IAR MUST
     respond to RREQ on behalf of all Internet destinations.</t>

  <t>When a packet from a node on the Internet destined for a
     node in the AODVv2 MANET reaches the IAR, if the IAR does not
     have a route toward that destination it will perform normal AODVv2
     route discovery for that destination.</t>

</section> <!-- section anchor="gateway" title="Simple Internet Attachment" -->
<!-- ======================== Optional Features ======================== -->

<section anchor="optional" title="Optional Features">

  <t> Some optional features of AODVv2, associated with AODV,
      are not required by minimal implementations.  These features are
      expected to apply in networks with greater mobility, or
      larger node populations, or requiring reduced latency for
      application launches.  The optional features are as follows:</t>
    <t><list style="symbols">
  <t>Expanding Rings Multicast</t>
  <t>Precursor lists.</t>
  <t>Multicast RREP Response to RREQ</t>
  <t>Intermediate RREPs (iRREPs): Without iRREP, only the
        destination can respond to a RREQ. </t>
  <t>Reporting Multiple UnreachableAddresses: a RERR message can carry more
     than one Unreachable Address for cases when a single link breakage causes
     other destinations to become unreachable from an intermediate router. </t>
     <!-- CEP: issue #40 should be revisited!!  -->
  <t>Message Aggregation Delay.</t>
  </list> </t>

  <section anchor="rings" title="Expanding Rings Multicast">
          <t>For multicast RREQ, msg_hop_limit MAY be set in
          accordance with an expanding ring search as described in
    <xref target="RFC3561"/> to limit the RREQ propagation to a
          subset of the local network and possibly reduce route
          discovery overhead.</t>
    </section>

    <section anchor="precursor" title="Precursor Lists and Notifications">
      <t>This section specifies an interoperable enhancement to AODVv2
        (and possibly other reactive routing protocols) enabling
<!-- Issue #22 -->
        more economical RERR notifications to traffic sources
        upon determination that a route needed to forward such traffic to
       its destination has become Invalid.</t>
<!-- NOTE!  CEP: TODO:  Precursors should NOT be notified if
     Precursor.LastUsed < (MAX_IDLETIME + ACTIVE_INTERVAL)   -->
<!--
    , then for
    the IP.SourceAddress of the packet, Precursor[LastHop].LastUsed := Current_time.
    the packet is forwarded to the route's next hop.
  -->

  <section title="Overview">
  <t> In many circumstances, there can be several sources of traffic
      for a certain destination.  Each such source of traffic
      is known as a "precursor" for the destination, as well as all
      upstream routers between the forwarding AODVv2 router and the
      traffic source.  There is no need to keep track of upstream routers
      any farther away than the next hop.  For each destination, an AODVv2
      router MAY choose to keep track of the upstream neighbors that have
      provided traffic for that destination.</t>

  <t> Moreover, any particular link to an adjacent AODVv2 router may be
      a path component of multiple routes towards various destinations.
      The precursors for all destinations using the next hop across any
      link are collectively known as the precursors for that next hop.</t>

  <t> When an AODVv2 router marks a route as Invalid, the precursors of the
      Invalid route should be notified (using RERR) about the change in
      status of their route to the destination of that Invalid route.</t>

  </section>

  <section anchor="Precursor-Notify" title="Precursor Notification Details">

  <t> During normal operation, each AODVv2 router wishing to maintain
      precursor lists as described above, maintains a precursor table and
      updates the table whenever the node forwards traffic to one of the
      destinations in its route table.  For each precursor in the precursor
      list, a record must be maintained to indicate whether the precursor
      has been used for recent traffic (in other words, whether the precursor
      is an Active precursor).  So, when traffic arrives from a precursor,
      the Current_Time is used to mark the time of last use for the precursor
      list element associated with that precursor.</t>

   <t> When an AODVv2 router detects that a link is broken, then for
       each Active precursor using that next hop, the node MAY notify the
       precursor using either unicast or multicast RERR:
       <list style="hanging">
       <t hangText="unicast RERR to each Active precursor"><vspace/>
       This option is applicable when there are few Active precursors
       compared to the number of neighboring AODVv2 routers.</t>
       <t hangText="multicast RERR to RERR_PRECURSORS"><vspace/>
       RERR_PRECURSORS is, by default, LL-MANET-Routers
       <xref target="RFC5498"/>.  This option is typically
       preferable when there are many precursors,
       since fewer packet transmissions are required.</t>
    </list>

    Each neighbor receiving the RERR MAY then execute the same procedure until
    all upstream routers have received the RERR notification.</t>

    </section>

  </section>

  <section anchor="mcast-to-RREQ" title="Multicast RREP Response to RREQ">

  <t> The RREQ Target Router (RREP_Gen) MAY, as an alternative to unicasting a
      RREP, be configured to use multicast to distribute routing information
      about the route toward TargAddr. RREP_Gen does this as described in
      <xref target="RREP_gen"/>, but multicasting the RREP to LL-MANET-Routers
      <xref target="RFC5498"/>.  Routers receiving the multicast RREP must
      perform RteMsg suppression (see <xref target="suppress"/>).</t>

  <t> Broadcast RREP response to incoming RREQ was originally specified
      to handle unidirectional links, but it is expensive.  Due to the
      significant overhead, AODVv2 routers MUST NOT use multicast RREP
      unless configured to do so by setting the administrative parameter
      USE_MULTICAST_RREP.  This technique can be used to find the best
      return path rather than follow the same path as the RREQ took.</t>
  </section>

  <section anchor="iRREP" title="Intermediate RREP">
  <t> This specification has been published as a separate
      Internet Draft <xref target="I-D.perkins-irrep"/>.  </t>
  </section>

  <section anchor="aggreg" title="Message Aggregation Delay">

  <t> The aggregation of multiple messages into a packet is specified in
      RFC 5444 <xref target="RFC5444"/>.</t>

  <t> Implementations MAY choose to briefly delay transmission of messages
      for the purpose of aggregation (into a single packet) or to improve
      performance by using jitter <xref target="RFC5148"/>.</t>
  </section>

</section>

<!-- =================== Administrative Parameters ===================== -->

<section anchor="param"
      title="Administratively Configurable Parameters and Timer Values">

  <t>AODVv2 uses various configurable parameters of various types:
  <list style="symbols">
    <t>Timers</t>
    <t>Protocol constants</t>
    <t>Administrative (functional) controls</t>
    <t>Other administrative parameters and lists</t>
  </list>
    The tables in the following sections show the parameters along
    their definitions and default values (if any).</t>

  <t>Note: several fields have limited size (bits or bytes). These
     sizes and their encoding may place specific limitations on the values
     that can be set. For example, &lt;msg-hop-count&gt; is a 8-bit
     field and therefore MAX_HOPCOUNT cannot be larger than 255.</t>

  <section anchor="timers" title="Timers">

  <t>AODVv2 requires certain timing information to be associated
     with route table entries.  The default values are as follows:</t>

  <texttable anchor="timer-tbl" title="Timing Parameter Values">
        <ttcol align="center" width="35%">Name</ttcol>
        <ttcol align="left">Default Value</ttcol>
  <c>ACTIVE_INTERVAL</c>	<c>5 second</c>
  <c>MAX_IDLETIME</c>		<c>200 seconds</c>
  <c>MAX_BLACKLIST_TIME</c>	<c>200 seconds</c>
  <c>MAX_SEQNUM_LIFETIME</c>	<c>300 seconds</c>
  <c>RteMsg_ENTRY_TIME</c>	<c>12 seconds</c>
  <c>RREQ_WAIT_TIME</c>		<c>2 seconds</c>
  <c>RREP_Ack_SENT_TIMEOUT</c>	<c>1 second</c>
  <c>RREQ_HOLDDOWN_TIME</c>	<c>10 seconds</c>
  </texttable>

  <t>The above timing parameter values have worked well for small and
     medium well-connected networks with moderate topology changes.
     The timing parameters SHOULD be administratively configurable
     for the network where AODVv2 is used. Ideally, for networks with
     frequent topology changes the AODVv2 parameters should be adjusted
     using either experimentally determined values or dynamic
     adaptation. For example, in networks with infrequent topology
     changes MAX_IDLETIME may be set to a much larger value.</t>

  </section> <!-- section anchor="timers" title="Timers"  -->

  <section anchor="constants" title="Protocol Constants">
    <t>AODVv2 protocol constants typically do not require changes.
           The following table lists these constants, along with their values
           and a reference to the specification describing their use.</t>
    <texttable anchor="const-tbl" title="Parameter Values">
        <ttcol align="left" width="35%">Name</ttcol>
        <ttcol align="left">Default Value</ttcol>
        <ttcol align="left">Description</ttcol>

        <c>DISCOVERY_ATTEMPTS_MAX</c>
        <c>3</c>
        <c><xref target="route_discovery"/></c>

        <c>MAX_HOPCOUNT</c>
        <c>20 hops</c>
        <c><xref target="metrics"/></c>

        <c>MAX_METRIC[i]</c>
        <c>Specified only for HopCount</c>
        <c><xref target="metrics"/></c>

        <c>MAXTIME</c>
        <c>[TBD]</c>
        <c>Maximum expressible clock time <xref target="timeout"/></c>
        <!-- Need to figure out what the time format. -->
    </texttable>

    <t>These values MUST have the same values for all AODVv2 routers in
       the ad hoc network.  If the configured values are different, the
       following consequences may be observed:
    <list style="symbols">
      <t>DISCOVERY_ATTEMPTS_MAX: some nodes are likely to be more successful
         at finding routes, but at the cost of additional control traffic
         for unsuccessful attempts.</t>
      <t>MAX_HOPCOUNT: If some nodes use a value that is too small, they
         would not be able to discover routes to distant addresses.</t>
      <t>MAX_METRIC[DEFAULT_METRIC_TYPE]: MUST always be the maximum
         expressible metric of type DEFAULT_METRIC_TYPE.  No interoperability
         problems due to variations on different nodes, but if a lesser value
         is used, route comparisons may exhibit overly restrictive behavior.</t>
      <t>MAXTIME: Variations on different nodes would not cause problems for
         interoperability.  If a lesser value is used, route state management
         may exhibit overly restrictive behavior.</t>
    </list>
  </t>
  </section> <!-- section anchor="constants" title="Protocol Constants"  -->

  <section anchor="controls" title="Administrative (functional) controls">

  <t>
     The following administrative controls may be used to change the
     operation of the network, by enabling optional behaviors.  These options
     are not required for correct routing behavior, although they may
     potentially reduce AODVv2 protocol messaging in certain situations.
     The default behavior is typically to NOT enable the options.
     Inconsistent settings at different nodes in the network will
     not result in protocol errors.  In the case of inconsistent settings
     for DEFAULT_METRIC_TYPE, inconsistent setting might result in messages
     specifying metric types unknown to some nodes and consequent poor
     performance.
  </t>

  <texttable anchor="suggestedoptions"
      title="Administratively Configured Controls">
        	<ttcol align="center" width="35%">Name</ttcol>
        	<ttcol align="left">Description</ttcol>
  <c>DEFAULT_METRIC_TYPE</c>
	        <c>3 (i.e, Hop Count (see <xref target="RFC6551"/>))</c>
  <c>ENABLE_IDLE_IN_RERR</c>	<c><xref target="RERR_gen"/></c>
  <c>ENABLE_IRREP</c>		<c><xref target="RREQ_gen"/></c>
  <c>USE_MULTICAST_RREP</c>	<c><xref target="mcast-to-RREQ"/></c>
  </texttable>

  </section> <!-- section anchor="controls"
  			title="Administrative (functional) controls" -->

  <section anchor="other" title="Other administrative parameters and lists">
  <t>The following table lists contains AODVv2 parameters which should
         be administratively configured for each node.</t>

  <texttable anchor="admincontrol" title="Other Administrative Parameters">
        <ttcol align="left" width="35%">Name</ttcol>
        <ttcol align="left">Default Value</ttcol>
        <ttcol align="left">Cross Reference</ttcol>

  <c>AODVv2_INTERFACES</c>
     <c/>
     <c><xref target="apply"/></c>
  <c>BUFFER_SIZE_PACKETS</c>
     <c>2</c>
     <c><xref target="route_discovery"/></c>
  <c>BUFFER_SIZE_BYTES</c>
     <c>MAX_PACKET_SIZE [TBD]</c>
     <c><xref target="route_discovery"/></c>
  <c>CLIENT_ADDRESSES</c>
     <c>AODVv2_INTERFACES</c>
     <c><xref target="clients"/></c>
  <c>CONTROL_TRAFFIC_LIMIT</c>
     <c>TBD [50 packets/sec?]</c>
     <c><xref target="aodv_msgs"/></c>

  </texttable>
  </section> <!-- anchor="other"
  			title="Other administrative parameters and lists" -->

</section>

<section anchor="IANA" title="IANA Considerations">
  <t>This section specifies several RFC 5444 message types, message
     tlv-types, and address tlv-types.  Also, a new registry of
     16-bit alternate metric types is specified.</t>

  <section anchor="msgtype" title="AODVv2 Message Types Specification">
    <texttable anchor="msgtypes" title="AODVv2 Message Types">
	<ttcol align="center" width="45%">Name of AODVv2 Message</ttcol>
	<ttcol align="center">Type</ttcol>

    <c>Route Request (RREQ)</c>				<c>10 (TBD)</c>
    <c>Route Reply (RREP)</c>				<c>11 (TBD)</c>
    <c>Route Error (RERR)</c>				<c>12 (TBD)</c>
    <c>Route Reply Acknowledgement (RREP_Ack)</c>	<c>13 (TBD)</c>

    </texttable> <!-- anchor="msgtypes" title="AODVv2 Message Types" -->
  </section> <!--anchor="msgtype" title="AODVv2 Message Types Specification"-->

  <section anchor="msgtlvtypes" title="Message TLV Type Specification">
    <texttable anchor="msgtlvtbl" title="Message TLV Types">
		<ttcol align="left" width="56%">Name of Message TLV</ttcol>
		<ttcol align="center" width="16%">Type</ttcol>
		<ttcol align="center">Length (octets)</ttcol>
		<ttcol align="left">Cross Reference</ttcol>

    <c>AckReq (Acknowledgment Request)</c> <c>10 (TBD)</c>
    <c>0</c>				<c><xref target="blacklists"/></c>

<!-- CEP: DestOnly to be moved to the irrep draft...
    <c>Destination RREP Only (DestOnly)</c>	<c>11</c>
      						##!!## Note renumbering below...
    <c>0</c>		<c><xref target="RREQ_gen"/></c>
  -->

    <c>PktSource (Packet Source)</c>	<c>11 (TBD)</c>
    <c>4 or 16</c>			<c><xref target="RERR_gen"/></c>

    <c>MetricType</c>			<c>12 (TBD)</c>
    <c>1</c>			 	<c><xref target="RERR_msgs"/></c>

    </texttable>
  </section>

  <section anchor="addrtlvspec" title="Address Block TLV Specification">
    <texttable anchor="addrtlvtypes" title="Address Block TLV (AddrTLV) Types">
	<ttcol align="left" width="45%">Name of Address Block TLV</ttcol>
	<ttcol align="center" width="15%">Type</ttcol>
	<ttcol align="left">Length</ttcol>
	<ttcol align="left">Value</ttcol>

    <c>Metric</c>			<c>10 (TBD)</c>
    <c>depends on MetricType</c>	<c><xref target="RREQ_msgs"/></c>

    <c>Sequence Number (SeqNum)</c>	<c>11 (TBD)</c>
    <c>2 octets</c>			<c><xref target="RREQ_msgs"/></c>

    <c>Originating Node Sequence Number (OrigSeqNum)</c>	<c>12 (TBD)</c>
    <c>2 octets</c>			<c><xref target="RREQ_msgs"/></c>

    <c>Target Node Sequence Number (TargSeqNum)</c>	<c>13 (TBD)</c>
    <c>2 octets</c>			<c><xref target="RREQ_msgs"/></c>

    <c>VALIDITY_TIME</c>		<c>1</c>
    <c>1 octet</c>			<c><xref target="RFC5497"/></c>

    </texttable> <!-- texttable anchor="addrtlvtypes"
    			title="Address Block TLV (AddrTLV) Types" -->
  </section><!--anchor="addrtlvspec" title="Address Block TLV Specification"-->

  <section anchor="metric-type" title="MetricType Number Allocation">
  <t>Metric types are identified according to the assignments as specified
        in <xref target="RFC6551"/>.
     The metric type of the Hop Count metric is assigned to
     be 3, in order to maintain compatibility with that existing
     table of values from RFC 6551.
     </t>
    <texttable anchor="metric-tbl" title="Metric Types">
		<ttcol align="center" width="35%">Name of MetricType</ttcol>
		<ttcol align="center">Type</ttcol>
		<ttcol align="center">Metric Size</ttcol>
    <!--
    <c>Reserved</c>		<c>0</c>		<c>Undefined</c>
          -->
    <c>Unallocated</c>		<c>0 -- 2</c>		<c>TBD</c>
    <c>Hop Count</c>		<c>3 - TBD</c>		<c>1 octet</c>
    <c>Unallocated</c>		<c>4 -- 254</c>		<c>TBD</c>
    <c>Reserved</c>		<c>255</c>		<c>Undefined</c>

    </texttable> <!-- texttable anchor="metric-tbl" title="Metric Types" -->
  </section> <!-- anchor="metric-type" title="MetricType Number Allocation" -->
</section> <!-- section anchor="IANA" title="IANA Considerations" -->

<section anchor="Security" title="Security Considerations">

  <t>The objective of the AODVv2 protocol is for each router to
     communicate reachability information about addresses for which it
     is responsible. Positive routing information (i.e. a route
     exists) is distributed via RREQ and RREP messages.  Negative routing
     information (i.e. a route does not exist) is distributed via RERRs.
     AODVv2 routers store the information contained in these messages in
     order to properly forward data packets, and they generally provide
     this information to other AODVv2 routers.</t>

      <!--t>If a router transmits incorrect or false routing information,
      it will likely be stored and propagated.</t-->

      <!--IDC should we remove all mutable fields-->

      <!--IDC Notify Reflection Attack-->

  <t>This section does not mandate any specific security measures. Instead,
     this section describes various security considerations and potential
     avenues to secure AODVv2 routing.  Security for authentication of AODVv2
     routers, and/or encryption of traffic is dealt with by the underlying
     transport mechanism (e.g., by using the techniques for Authentication,
     Integrity, and Confidentiality documented in <xref target="RFC5444"/>).
     The most important security mechanisms for AODVv2
     routing are integrity/authentication and confidentiality. </t>

  <t>In situations where routing information or router identity
      are suspect, integrity and authentication techniques SHOULD be
      applied to AODVv2 messages. In these situations, routing
      information that is distributed over multiple hops SHOULD also
      verify the integrity and identity of information based on
      originator of the routing information. </t>

  <t>A digital signature could be used to identify the source of
      AODVv2 messages and information, along with its authenticity. A
      nonce or timestamp SHOULD also be used to protect against replay
      attacks. S/MIME and OpenPGP are two authentication/integrity
      protocols that could be adapted for this purpose.</t>

  <t>In situations where confidentiality of AODVv2 messages is
      important, cryptographic techniques can be applied.</t>

  <t>In certain situations, for example sending a RREP or RERR, an AODVv2
      router could include proof that it has previously received valid
      routing information to reach the destination, at one point of
      time in the past. In situations where routers are suspected of
      transmitting maliciously erroneous information, the original
      routing information along with its security credentials SHOULD
      be included.</t>

  <t>Note that if multicast is used, any confidentiality and
      integrity algorithms used MUST permit multiple receivers to
      handle the message.</t>

  <t>Routing protocols, however, are prime targets for
      impersonation attacks.  In networks where the node membership is
      not known, it is difficult to determine the occurrence of
      impersonation attacks, and security prevention techniques are
      difficult at best. However, when the network membership is known
      and there is a danger of such attacks, AODVv2 messages must be
      protected by the use of authentication techniques, such as those
      involving generation of unforgeable and cryptographically strong
      message digests or digital signatures. While AODVv2 does not place
      restrictions on the authentication mechanism used for this
      purpose, IPsec Authentication Message (AH) is an appropriate
      choice for cases where the nodes share an appropriate security
      association that enables the use of AH.</t>

  <t>In particular, routing messages SHOULD be authenticated to avoid
      creation of spurious routes to a destination. Otherwise, an
      attacker could masquerade as that destination and maliciously
      deny service to the destination and/or maliciously inspect and
      consume traffic intended for delivery to the destination. RERR
      messages SHOULD be authenticated in order to prevent malicious
      nodes from disrupting routes between communicating
      nodes.</t>

  <t>If the mobile nodes in the ad hoc network have pre-established
      security associations, the purposes for which the security associations
      are created should include that of authorizing the processing of AODVv2
      control packets. Given this understanding, the mobile nodes should be
      able to use the same authentication mechanisms based on their IP
      addresses as they would have used otherwise.</t>

<!--DEREK comments
Some threats to the system could include an injection of RERR message
either by an outside attacker, a rogue router, or a compromised
router.  The TTL check protects against some injection techniques
unless it's injected by an actual rogue or compromised router.

In terms of source identification of a RREQ or RREP you might want to
add a digital signature field (which also requires some nonce or
timestamp to protect against replay attacks).  There's also a question
of how you authorize a router to supply an RREP.  For example a rogue
or compromised router could decide to "advertize" a route by
responding with an RREP even though it's not necessarily the "best"
route or it might not even have a route toward the destination.

When an intermediate router generates an RREP it needs to authenticate
that it has the original route.  Perhaps what needs to happen is that
it includes the original RREP signed by the TargNode in order to prove
that it HAD (at one point in the past) a valid route toward the TargAddr.
This is particularly an issue in generating the RREP on the fly to the
TargAddr from the OrigAddr because there IS no RREP.  In this case
it might want to include the original RREQ from the OrigAddr as the
authentication token.
-->

  <t>
      Most AODVv2 messages are transmitted to the multicast address
      LL-MANET-Routers <xref target="RFC5498"/>.  It is therefore
      required for security that AODVv2 neighbors exchange security
      information that can be used to insert an ICV <xref target="RFC6621"/>
      into the AODVv2 message block <xref target="RFC5444"/>.
      This enables hop-by-hop security.  <!-- Issue #Q which is proper for these
      message types that may have mutable fields.-->  For destination-only
      RREP discovery procedures, AODVv2 routers that share a security
      association SHOULD use the appropriate mechanisms as specified
      in RFC 6621.
      The establishment of these security associations is out of scope
      for this document.</t>

</section>


<section title="Acknowledgments">
  <t>AODVv2 is a descendant of the design of previous MANET on-demand
      protocols, especially AODV <xref target="RFC3561"/> and
      DSR <xref target="RFC4728"/>. Changes to previous MANET
      on-demand protocols stem from research and implementation
      experiences.  Thanks to Elizabeth Belding and Ian Chakeres for their
      long time authorship of AODV.  Additional thanks to
      Derek Atkins,
      Emmanuel Baccelli,
      Abdussalam Baryun,
      Ramon Caceres,
      Thomas Clausen,
      Christopher Dearlove,
      Ulrich Herberg,
      Henner Jakob,
      Luke Klein-Berndt,
      Lars Kristensen,
      Tronje Krop,
      Koojana Kuladinithi,
      Kedar Namjoshi,
      Alexandru Petrescu,
      Henning Rogge,
      Fransisco Ros,
      Pedro Ruiz,
      Christoph Sommer,
      Lotte Steenbrink,
      Romain Thouvenin,
      Richard Trefler,
      Jiazi Yi,
      Seung Yi,
      and
      Cong Yuan,
      for their reviews AODVv2 and DYMO, as well as numerous specification
      suggestions.</t>

</section>
</middle>

<back>
    <references title="Normative References">

      <?rfc include="reference.RFC.2119" ?>
      <?rfc include="reference.RFC.4291" ?>
      <?rfc include="reference.RFC.5082" ?>
      <?rfc include="reference.RFC.5444" ?>
      <?rfc include="reference.RFC.5497" ?>
      <?rfc include="reference.RFC.5498" ?>
      <?rfc include="reference.RFC.6551" ?>

    </references>

    <references title="Informative References">

      <?rfc include="reference.RFC.2501" ?>
      <?rfc include="reference.RFC.3561" ?>
      <?rfc include="reference.RFC.4193" ?>
      <?rfc include="reference.RFC.4728" ?>
      <?rfc include="reference.RFC.4861" ?>
      <?rfc include="reference.RFC.5148" ?>
      <?rfc include="reference.RFC.6130" ?>
      <?rfc include="reference.RFC.6621" ?>
      <?rfc include="reference.I-D.perkins-irrep" ?>

      <reference anchor="Perkins94">
        <front>
          <title>Highly Dynamic Destination-Sequenced Distance-Vector Routing (DSDV) for Mobile Computers</title>

          <author fullname="Charles E. Perkins" initials="C." surname="Perkins">
            <organization>
            IBM, TJ Watson Research Center
            </organization>
          </author>

          <author fullname="Pravin Bhagwat" initials="P." surname="Bhagwat">
            <organization>
            Computer Science Department, University of Maryland
            </organization>
          </author>

          <date month="August" year="1994"/>
        </front>

        <seriesInfo name="Proceedings" value="of the ACM SIGCOMM '94 Conference on Communications Architectures, Protocols and Applications, London, UK, pp. 234-244"/>
      </reference>

      <reference anchor="Perkins99">
        <front>
          <title>Ad hoc On-Demand Distance Vector (AODV) Routing</title>

          <author fullname="Charles E. Perkins" initials="C." surname="Perkins">
            <organization/>
          </author>

          <author fullname="Elizabeth M. Royer" initials="E." surname="Royer">
            <organization>University of California</organization>
          </author>

          <date month="February" year="1999"/>
        </front>

        <seriesInfo name="Proceedings" value="of the 2nd IEEE Workshop on Mobile Computing Systems and Applications, New Orleans, LA, pp. 90-100"/>
      </reference>

<!--
    <?rfc include="reference.I-D.chakeres-manet-manetid" ?>
    <?rfc include="reference.I-D.clausen-lln-loadng" ?>
  -->
    </references>

    <section anchor="algorithms"
        title="Example Algorithms for AODVv2 Protocol Operations">
  <t>The following subsections show example algorithms for protocol
  operations required by AODVv2, including RREQ, RREP, RERR, and
  RREP_Ack.
  </t>

  <t>
  Processing for RREQ, RREP, and RERR messages follows
  the following general outline:
  <list style="numbers">
  <t>Receive incoming message.</t>
  <t>Update route table as appropriate.</t>
  <t>Respond as needed, often regenerating the incoming message with
    updated information.</t>
  </list>

  Once the route table has been updated, the information contained
  there is known to be the most recent available information
  for any fields in the outgoing message.  For this reason, the
  algorithms are written as if outgoing message field values are
  assigned from the route table information, even though it is often
  equally appropriate to use fields from the incoming message.
  </t>

  <t>AODVv2_algorithms:

  <list style="symbols">
  <t> Process_Routing_Info </t>
  <t> Fetch_Route_Table_Entry </t>
  <t> Update_Route_Table_Entry </t>
  <t> Create_Route_Table_Entry </t>
  <t> LoopFree </t>
  <t>   </t>
  <t> Update_Rte_Msg_Table </t>
  <t>   </t>
  <t> Generate_RREQ </t>
  <t> Receive_RREQ </t>
  <t> Regenerate_RREQ </t>
  <t>   </t>
  <t> Generate_RREP </t>
  <t> Receive_RREP </t>
  <t> Regenerate_RREP </t>
  <t>   </t>
  <t> Generate_RERR </t>
  <t> Receive_RERR </t>
  <t> Regenerate_RERR </t>
  <t>   </t>
  <t> Generate_RREP_Ack </t>
  <t> Receive_RREP_Ack </t>
  <t> Timeout RREP_Ack </t>
  </list>
  </t>

  <t>
    The following lists indicate the meaning of the field
    names used in subsequent sections to describe message
    processing for the above algorithms.
  </t>

  <t>RteMsg parameters, where rteMsg can be inRREQ, outRREQ, inRREP or
     outRREP:
  <list style="empty">
  <t> rteMsg.hopLimit </t>
  <t> rteMsg.hopCount </t>
  <t> rteMsg.ackReq (RREP only, optional) </t>
  <t> rteMsg.metricType (optional) </t>
  <t> rteMsg.origAddr </t>
  <t> rteMsg.targAddr </t>
  <t> rteMsg.origPrefixLen (optional) </t>
  <t> rteMsg.targPrefixLen (optional) </t>
  <t> rteMsg.origSeqNum (RREQ only) </t>
  <t> rteMsg.targSeqNum (optional in RREQ) </t>
  <t> rteMsg.origAddrMetric (RREQ only) </t>
  <t> rteMsg.targAddrMetric (RREP only) </t>
  <t> rteMsg.validityTime </t>
  <t> rteMsg.nbrIP </t>
  </list>
  </t>

  <t>AdvRte has the following properties as described in <xref target="test"/>:
  <list style="empty">
  <t> AdvRte.Address = OrigAddr (in a RREQ) or TargAddr (in a RREP) </t>
  <t> AdvRte.PrefixLength = PrefixLength for OrigAddr (in a RREQ)
      or TargAddr (in a RREP), or if not present, the maximum address
      length for the address family of AdvRte.Address </t>
  <t> AdvRte.SeqNum = SeqNum for OrigAddr (in a RREQ) or for TargAddr
      (in a RREP) </t>
  <t> AdvRte.MetricType = RteMsg.MetricType, if present, else
         DEFAULT_METRIC_TYPE </t>
  <t> AdvRte.Metric = RteMsg.Metric </t>
  <t> AdvRte.Cost = AdvRte.Metric + Cost(L) according to the indicated  </t>
  <t> MetricType, where L is the link from the advertising router </t>
  <t> AdvRte.ValidityTime = ValidityTime in the RteMsg, if present </t>
  <t> AdvRte.NextHopIP = IP source of the RteMsg </t>
  <t> AdvRte.NextHopIntf = interface the RteMsg was received on </t>
  <t> AdvRte.HopCount = value from RteMsg header </t>
  <t> AdvRte.HopLimit = value from RteMsg header </t>
  <t> AdvRte.AckReq = true/false whether present in RteMsg (optional
         in RREP) </t>
  </list>
  </t>

  <t>A route table entry has properties as described in <xref target="rte"/>:
  <list style="empty">
  <t> Route.Address </t>
  <t> Route.PrefixLength </t>
  <t> Route.SeqNum </t>
  <t> Route.NextHop </t>
  <t> Route.NextHopInterface </t>
  <t> Route.LastUsed </t>
  <t> Route.LastSeqNum </t>
  <t> Route.ExpirationTime </t>
  <t> Route.MetricType </t>
  <t> Route.Metric </t>
  <t> Route.State </t>
  <t> Route.Timed </t>
  <t> Route.Precursors (optional) </t>
  </list>
<vspace blankLines="27"/>
  </t>

<!-- for cutting and pasting...

<section anchor="" title="">

<t>
<figure>
<artwork>



</artwork>
</figure>
</t>
</section>  <- end of "" subsection  >



     for cutting and pasting...  -->

<section anchor="sub-algorithms"
      title="Subroutines for AODVv2 Operations">

<section anchor="Process_Routing_Info" title="Process_Routing_Info">

<t>
<figure>
<artwork>
  /* Compare incoming route information to stored route, maybe use
     linkMetric: either Cost(inRREQ.netif) or (inRREP.netif) */
  Process_Routing_Info (advRte)
  {
    rte := Fetch_Route_Table_Entry (advRte);
    if (rte exists)
    {
      rte := Create_Route_Table_Entry(advRte);
      return rte;
    }

    if (!LoopFree(advRte, rte))
    {  /* incoming route cannot be guaranteed loop free */
       return null;
    }

    /* rule from 8.1 */
    if (
         (AdvRte.SeqNum > Route.SeqNum)  /* stored route is stale */
           OR
          ((AdvRte.SeqNum == Route.SeqNum)  /* same SeqNum */
            AND
          [((Route.State == Invalid))  /* advRte can repair stored */
            OR
       (AdvRte.Cost &lt; Route.Metric)])) /* advRte is better */
    {
      Update_Route_Table_Entry (rte, advRte);
    }
    return rte;
  }
</artwork>
</figure>
<vspace blankLines="27"/>
</t>
</section>  <!-- end of "Process_Routing_Info" subsection  -->


<section anchor="Fetch_Route_Table_Entry" title="Fetch_Route_Table_Entry">

<t>
<figure>
<artwork>
    /* lookup a route table entry matching an advertised route */
    Fetch_Route_Table_Entry (advRte)
    {
      foreach (rteTableEntry in rteTable)
      {
         if (rteTableEntry.Address == advRte.Address AND
             rteTableEntry.MetricType == advRte.MetricType)
         return rteTableEntry;
      }
      return null;
    }

    /* lookup a route table entry matching address and metric type */
    Fetch_Route_Table_Entry (destination, metricType)
    {
      foreach (rteTableEntry in rteTable)
      {
         if (rteTableEntry.Address == destination AND
             rteTableEntry.MetricType == MetricType)
         return rteTableEntry;
      }
      return null;
    }
</artwork>
</figure>
<vspace blankLines="27"/>
</t>
</section>  <!-- end of "Fetch_Route_Table_Entry" subsection  -->

<section anchor="Update_Route_Table_Entry" title="Update_Route_Table_Entry">

<t>
<figure>
<artwork>
    /* update a route table entry using AdvRte in received RteMsg */
    Update_Route_Table_Entry (rte, advRte);
    {
      rte.SeqNum := advRte.SeqNum;
      rte.NextHop := advRte.NextHopIp;
      rte.NextHopInterface := advRte.NextHopIntf;
      rte.LastUsed := Current_Time;
      rte.LastSeqNum := Current_Time;
      if (validityTime)
      {
         rte.ExpirationTime := Current_Time + advRte.validityTime;
         rte.Timed := true;
      }
      else
      {
         rte.Timed := false;
         rte.ExpirationTime := MAXTIME;
      }

      rte.Metric := advRte.Cost;
      if (rte.State == Invalid)
        rte.State := Idle;
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Update_Route_Table_Entry" subsection  -->

<section anchor="Create_Route_Table_Entry" title="Create_Route_Table_Entry">

<t>
<figure>
<artwork>
  /* Create a route table entry from address and prefix length */
  Create_Route_Table_Entry (address, prefixLength,
                                              seqNum, metricType)
  {
    rte := allocate_memory();
    rte.Address := address;
    rte.PrefixLength := prefixLength;
    rte.SeqNum := seqNum;
    rte.MetricType := metricType;
  }
</artwork>
</figure>
<figure>
<artwork>
  /* Create a route table entry from the advertised route */
  Create_Route_Table_Entry(advRte)
  {
    rte := allocate_memory();

    rte.Address := advRte.Address;
    if (advRte.PrefixLength)
      rte.PrefixLength := advRte.PrefixLength;
    else
      rte.PrefixLength := maxPrefixLenForAddressFamily;

    rte.SeqNum := advRte.SeqNum;
    rte.NextHop := advRte.NextHopIp;
    rte.NextHopInterface := advRte.NextHopIntf;
    rte.LastUsed := Current_Time
    rte.LastSeqnum := Current_Time
    if (validityTime)
    {
      rte.ExpirationTime := Current_Time + advRte.ValidityTime;
      rte.Timed := true;
    }
    else
    {
      rte.Timed := false;
      rte.ExpirationTime := MAXTIME;
    }
    rte.MetricType := advRte.MetricType;
    rte.Metric := advRte.Metric;
    rte.State := Idle;
  }
</artwork>
</figure>
</t>
</section>  <!-- end of "Create_Route_Table_Entry" subsection  -->

<section anchor="LoopFree" title="LoopFree">

<t>
<figure>
<artwork>
    /* return TRUE if the route R2 is LoopFree compared to R1 */
    LoopFree(advRte, rte)
    {
      if (advRte.Cost &lt; rte.Cost)
         return true;
      else
         return false;
    }
</artwork>
</figure>
<vspace blankLines="27"/>
</t>
</section>  <!-- end of "LoopFree" subsection  -->

<section anchor="Fetch_Rte_Msg_Table_Entry" title="Fetch_Rte_Msg_Table_Entry">

<t>
<figure>
<artwork>
    /* Find an entry in the RteMsg table matching the given
       message's msg-type, OrigAddr, TargAddr, MetricType   */
    Fetch_Rte_Msg_Table_Entry (rteMsg)
    {
      foreach (entry in RteMsgTable)
      {
        if (entry.msg-type == rteMsg.msg-type AND
            entry.OrigAddr == rteMsg.OrigAddr AND
            entry.TargAddr == rteMsg.TargAddr AND
            entry.MetricType == rteMsg.MetricType)
        {
          return entry;
        }
      }
      return NULL;
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Fetch_Rte_Msg_Table_Entry" subsection  -->

<section anchor="Update_Rte_Msg_Table" title="Update_Rte_Msg_Table">

<t>
<figure>
<artwork>
    /* update the multicast route message suppression table based
       on the received RteMsg, return true if it was created or
       the SeqNum was updated (i.e. it needs to be regenerated) */
    Update_Rte_Msg_Table(rteMsg)
    {
      /* search for a comparable entry */
      entry := Fetch_Rte_Msg_Table_Entry(rteMsg)

      /* if there is none, create one (see 6.5 and 8.6) */
      if (entry does not exist)
      {
        entry.MessageType := rteMsg.msg_type
        entry.OrigAddr := rteMsg.OrigAddr
        entry.TargAddr := rteMsg.TargAddr
        entry.OrigSeqNum := rteMsg.OrigSeqNum (if present)
        entry.TargSeqNum := rteMsg.TargSeqNum (if present)
        entry.MetricType := rteMsg.MetricType (if present) or
                              DEFAULT_METRIC_TYPE
        entry.Timestamp := Current_Time
        return true;
      }
</artwork>
</figure>
<figure>
<artwork>
      /* if current entry is stale */
      if ( (rteMsg.msg-type == RREQ AND
                        entry.OrigSeqNum &lt; rteMsg.OrigSeqNum)
           OR
           (rteMsg.msg-type == RREP AND
                        entry.TargSeqNum &lt; rteMsg.TargSeqNum))
      {
        entry.OrigSeqNum := rteMsg.OrigSeqNum (if present)
        entry.TargSeqNum := rteMsg.TargSeqNum (if present)
        entry.Timestamp := Current_Time
        return true;
      }

      /* if received rteMsg is stale */
      if ( (rteMsg.msg-type == RREQ AND
                        entry.OrigSeqNum > rteMsg.OrigSeqNum)
           OR
           (rteMsg.msg-type == RREP AND
                        entry.TargSeqNum > rteMsg.TargSeqNum))
      {
        entry.Timestamp := Current_Time
        return false;
      }

      /* if same SeqNum but rteMsg has lower metric */
      if (entry.Metric > rteMsg.Metric)
        entry.Metric := rteMsg.Metric

      entry.Timestamp := Current_Time
      return false;
    }
</artwork>
</figure>
<vspace blankLines="27"/>
</t>
</section>  <!-- end of "Update_Rte_Msg_Table" subsection  -->

<section anchor="Build_RFC_5444_message_header"
      title="Build_RFC_5444_message_header">

<t>
<figure>
<artwork>
   /* This pseudocode shows possible RFC 5444 actions, and
      would not be performed by the AODVv2 implementation.
      It is shown only to provide more understanding about
      the AODVv2 message that will be constructed by RFC 5444 */
   Build_RFC_5444_message_header (msgType, Flags,
                 AddrFamily, Size, hopLimit, hopCount, tlvLength)
   {
      /* Build RFC 5444 message header fields */
      msg-type := msgType
      MF (Message Flags) := Flags
      MAL (Message Address Length) := 3 for IPv4, 15 for IPv6
      msg-size := Size (octets - counting MsgHdr, AddrBlk, AddrTLVs)
      msg-hop-limit := hopLimit
      if (hopCount != 0)    /* hopCount == 0 means do not include */
        msg-hop-count := hopCount
      msg.tlvs-length := tlvLength
   }
</artwork>
</figure>
</t>
</section> <!-- end of "Build_RFC_5444_message_header" subsection  -->
</section>  <!-- end of "Subroutines for AODVv2 Operations" -->

<section anchor="rreq-algorithms"
  title="Example Algorithms for AODVv2 RREQ Operations">

<section anchor="Generate_RREQ" title="Generate_RREQ">

<t>
<figure>
<artwork>
    Generate_RREQ
    {
      /* Increment sequence number */
      mySeqNum := (1 + mySeqNum) /* from nonvolatile storage */

      /* Marshall parameters */
      outRREQ.hopLimit := MAX_HOPCOUNT   /* RFC 5444 */
      outRREQ.hopCount := (if included) 0
      outRREQ.metricType := if not DEFAULT_METRIC_TYPE,
                              metric type needed by application
      outRREQ.origAddr := IP address of Router Client which generated
                              the packet to be forwarded
      outRREQ.targAddr := destination IP address in
                              the packet to be forwarded
      outRREQ.origPrefixLen := if included, the prefix length
                              associated with the Router Client
      outRREQ.origSeqNum := mySeqNum
      outRREQ.targSeqNum := if known from route table,
                              target sequence number
      outRREQ.origAddrMetric := 0 (default) or
                                    MIN_METRIC(outRREQ.metricType)
      outRREQ.validityTime := if included, the validity time
                              for route to OrigAddr

      if (outRREQ.metricType != DEFAULT_METRIC_TYPE)
      { /* Build MetricType Message TLV */
        metricMsgTlv.value := outRREQ.metricType
      }

      /* Build Address Blk */
      AddrBlk := outRREQ.origAddr and outRREQ.targAddr addresses
            /* using prefix length information from
               outRREQ.origPrefixLen if necessary */

      /* Include each available Sequence Number in appropriate
         Address Block TLV */
      /* OrigSeqNum Address Block TLV */
      origSeqNumAddrBlkTlv.value := outRREQ.origSeqNum

      /* TargSeqNum Address Block TLV */
      if (outRREQ.targSeqNum is known)
      {
        targSeqNumAddrBlkTlv.value := outRREQ.targSeqNum
      }

      /* Build Metric Address Block TLV */
      metricAddrBlkTlv.value := outRREQ.origAddrMetric

      if (outRREQ.validityTime is required)
      {
        /* Build VALIDITY_TIME Address Block TLV */
        VALIDITY_TIMEAddrBlkTlv.value := outRREQ.validityTime
      }

      /* multicast RFC 5444 message to LL-MANET-Routers */
    }
</artwork>
</figure>
</t>

</section>  <!-- end of "Generate_RREQ" subsection -->

<section anchor="Receive_RREQ " title="Receive_RREQ ">

<t>
<figure>
<artwork>
   Receive_RREQ (inRREQ)
   {
     if (inRREQ.nbrIP present in blacklist) {
          if (blacklist_expiration_time &lt; current_time)
             return;   /* don't process or regenerate RREQ... */
          else
            remove nbrIP from blacklist;
        }
     if (inRREQ does not contain msg_hop_limit, OrigAddr,
                             TargAddr, OrigSeqNum, OrigAddrMetric)
          return;

     if (inRREQ.origAddr and inRREQ.targAddr are not valid
                             routable and unicast addresses)
          return;

     if (inRREQ.metricType is present but an unknown value)
          return;

     if (inRREQ.origAddrMetric >
                       MAX_METRIC[inRREQ.metricType] - Cost(Link)
          return;

     /* Extract inRREQ values */
     advRte.Address = inRREQ.origAddr
     advRte.PrefixLength = inRREQ.origPrefixLen (if present),
                             or the maximum address length for the
                             address family of advRte.Address
     advRte.SeqNum = inRREQ.origSeqNum
     advRte.MetricType = inRREQ.metricType (if present),
                               else DEFAULT_METRIC_TYPE
     advRte.Metric = inRREQ.origAddrMetric
     advRte.Cost = inRREQ.origAddrMetric + Cost(L)
                    according to the indicated MetricType, where
                    L is the link from the advertising router
     advRte.ValidityTime = inRREQ.validityTime (if present)
     advRte.NextHopIP = inRREQ.nbrIP
     advRte.NextHopIntf = interface the RteMsg was received on
     advRte.HopCount = inRREQ.hopCount
     advRte.HopLimit = inRREQ.hopLimit

     rte = Process_Routing_Info (advRte)

     /* update the RteMsgTableand determine if the RREQ needs
        to be regenerated */
     regenerate = Update_Rte_Msg_Table(inRREQ)

     if (inRREQ.targAddr is in Router Client list)
        Generate_RREP(inRREQ, rte)
     else if (regenerate)
        Regenerate_RREQ(inRREQ, rte)
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Receive_RREQ " subsection -->


<section anchor="Regenerate_RREQ " title="Regenerate_RREQ ">

<t>
<figure>
<artwork>
    Regenerate_RREQ (inRREQ, rte) /* called from receive_RREQ(),
                                rte is the route to OrigAddr */
    {
      outRREQ.hopLimit := inRREQ.hopLimit - 1
      if (outRREQ.hopLimit == 0)
        return; /* don't regenerate */

      if (inRREQ.hopCount exists)
      {
        if (inRREQ.hopCount >= MAX_HOPCOUNT)
          return; /* don't regenerate */
        outRREQ.hopCount := inRREQ.hopCount + 1
      }

      /* Marshall parameters */
      outRREQ.metricType := rte.MetricType
      outRREQ.origAddr := rte.Address
      outRREQ.targAddr := inRREQ.targAddr
      outRREQ.origPrefixLen := rte.PrefixLength
                              (if not equal to address length)
      outRREQ.origSeqNum := rte.SeqNum
      outRREQ.targSeqNum := inRREQ.targSeqNum /* if present */
      outRREQ.origAddrMetric := rte.Metric
      outRREQ.validityTime := rte.ValidityTime or length of time
                 HandlingRtr wishes to advertise route to OrigAddr

      if (outRREQ.metricType != DEFAULT_METRIC_TYPE)
      { /* Build MetricType Message TLV */
        metricMsgTlv.value := outRREQ.metricType
      }

      /* Build Address Block */
      AddrBlk := outRREQ.origAddr and outRREQ.targAddr addresses
           using prefix length information from outRREQ.origPrefixLen
           if necessary

      /* Include available Sequence Numbers in Address Block TLV */
      /* OrigSeqNum Address Block TLV */
      origSeqNumAddrBlkTlv.value := outRREQ.origSeqNum

      /* TargSeqNum Address Block TLV */
      if (outRREQ.targSeqNum is known) {
        targSeqNumAddrBlkTlv.value := outRREQ.targSeqNum
      }

      /* Build Metric Address Block TLV */
      metricAddrBlkTlv.value = outRREQ.origAddrMetric

      if (outRREQ.validityTime is required)
      {
        /* Build VALIDITY_TIME Address Block TLV */
        VALIDITY_TIMEAddrBlkTlv.value = outRREQ.validityTime
      }
      Build_RFC_5444_message_header (RREQ, 4, IPv4 or IPv6, NN,
                outRREQ.hopLimit, outRREQ.hopCount, tlvLength)

      /* multicast RFC 5444 message to LL-MANET-Routers, or if
         inRREQ was unicast the message can be unicast to the next
         hop on the route to TargAddr, if known */
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Regenerate_RREQ " subsection -->

</section>  <!-- end of "RREQ Algorithms" subsection -->

<section anchor="rrep-algorithms"
  title="Example Algorithms for AODVv2 RREP Operations">


<section anchor="Generate_RREP " title="Generate_RREP ">

<t>
<figure>
<artwork>
    Generate_RREP(inRREQ, rte)
    {
      /* Increment Sequence Number */
      mySeqNum := (1 + mySeqNum) /* from nonvolatile storage */

      /* Marshall parameters */
      outRREP.hopLimit := inRREQ.hopCount
      outRREP.hopCount := 0
      /* Include the AckReq when:
         - previous RREP does not seem to enable any data flow, OR
         - when RREQ is received from same OrigAddr after RREP was
           unicast to rte.nextHop
      */
      outRREP.ackReq := if included, TRUE otherwise FALSE

      if (rte.metricType != DEFAULT_METRIC_TYPE)
           outRREP.metricType := rte.metricType
      outRREP.origAddr := rte.Address
      outRREP.targAddr := inRREQ.targAddr
      outRREP.targPrefixLen := rte.PrefixLength
                             (if not equal to address length)
      outRREP.targSeqNum := mySeqNum
      outRREP.targAddrMetric := 0 (default) or
                                MIN_METRIC(rte.metricType)
      outRREP.validityTime := (if included) the validity time
                             for route to TargAddr

      if (outRREP.ackReq == TRUE)
      {
         /* include AckReq Message TLV */
      }

      if (outRREP.metricType != DEFAULT_METRIC_TYPE)
      { /* Build MetricType Message TLV */
        metricMsgTlv.value := outRREP.metricType
      }

      /* Build Address Block */
      AddrBlk := outRREP.origAddr and outRREP.targAddr addresses
           using prefix length information from outRREP.targPrefixLen
           if necessary

      /* TargSeqNum Address Block TLV */
      targSeqNumAddrBlkTlv.value := outRREP.targSeqNum

      /* Build Metric Address Block TLV containing TargAddr metric */
      metricAddrBlkTlv.value := outRREP.targAddrMetric

      if (outRREP.validityTime is required)
      {
        /* Build VALIDITY_TIME Address Block TLV */
        VALIDITY_TIMEAddrBlkTlv.value = outRREP.validityTime
      }

      Build_RFC_5444_message_header (RREP, 4, IPv4 or IPv6, NN,
                outRREP.hopLimit, outRREQ.hopCount, tlvLength)
      /* unicast RFC 5444 message to rte[OrigAddr].NextHop */
    }
</artwork>
</figure>

<!-- vspace blankLines="17"/  -->

</t>

</section>  <!-- end of "Generate_RREP " subsection -->

<section anchor="Receive_RREP" title="Receive_RREP">

<t>
<figure>
<artwork>
    Receive_RREP (inRREP)
    {
      if (inRREP.nbrIP present in blacklist) {
        if (blacklist_expiration_time &lt; current_time)
           return;   /* don't process or regenerate RREQ... */
        else
           remove nbrIP from blacklist;
        }

      if (inRREP does not contain msg_hop_limit, OrigAddr,
                        TargAddr, TargSeqNum, TargAddrMetric)
        return;

      if (inRREP.origAddr and inRREQ.targAddr are not
                        valid routable and unicast addresses)
        return;

      if (inRREP.metricType is present but an unknown value)
        return;
      if (inRREP.targAddrMetric >
                            MAX_METRIC[MetricType] - Cost(Link)
        return;

      /* Extract inRREP values */
      advRte.Address := inRREP.targAddr
      advRte.PrefixLength := inRREP.targPrefixLen f present), or the
        maximum address length for address family of advRte.Address
      advRte.SeqNum := inRREP.targSeqNum
      advRte.MetricType := inRREP.metricType (if present),
              else DEFAULT_METRIC_TYPE
      advRte.Metric := inRREP.targAddrMetric
      advRte.Cost := inRREP.targAddrMetric + Cost(L) according to
       inRREP's MetricType. L is the link from the advertising router
      advRte.ValidityTime := inRREP.validityTime (if present)
      advRte.NextHopIP := inRREP.nbrIP
      advRte.NextHopIntf := interface the RteMsg was received on
      advRte.HopCount := inRREP.hopCount
      advRte.HopLimit := inRREP.hopLimit (if included)

      rte := Process_Routing_Info (advRte)

      if (inRREP includes AckReq data element)
        Generate_RREP_Ack(inRREP)

      /* update the RteMsgTable and determine if the RREP needs
         to be regenerated */
      regenerate := Update_Rte_Msg_Table(inRREP)

      if (inRREP.targAddr is in the Router Client list)
        send_buffered_packets(rte)    /* start to use the route */
      else if (regenerate)
        Regenerate_RREP(inRREP, rte)
    }
</artwork>
</figure>

<vspace blankLines="27"/>

</t>
</section>  <!-- end of "Receive_RREP" subsection -->

<section anchor="Regenerate_RREP" title="Regenerate_RREP">

<t>
<figure>
<artwork>
    Regenerate_RREP(inRREP, rte)
    {
      if (rte does not exist)
      {
        Generate_RERR(inRREP)
        return;
      }

      outRREP.hopLimit := inRREP.hopLimit - 1
      if (outRREP.hopLimit == 0) /* don't regenerate */
        return;

      if (inRREP.hopCount exists)
      {
        if (inRREP.hopCount >= MAX_HOPCOUNT)
          return; /* don't regenerate */
        outRREP.hopCount := inRREP.hopCount + 1
      }

      /* Marshall parameters */
      /* Include the AckReq when:
         - previous unicast RREP seems not to enable data flow, OR
         - when RREQ is received from same OrigAddr after RREP
              was unicast to rte.nextHop
      */
      outRREP.ackReq := true or false whether to include
      if (rte.metricType != DEFAULT_METRIC_TYPE)
           outRREP.metricType := rte.metricType
      outRREP.origAddr := inRREP.origAddr
      outRREP.targAddr := rte.Address
      outRREP.targPrefixLen := rte.PrefixLength
                             (if not equal to address length)
      outRREP.targSeqNum := rte.SeqNum
      outRREP.targAddrMetric := rte.Metric
      outRREP.validityTime := (if included) the validity time
                             for route to TargAddr

      outRREP.nextHop := rte.nextHop

      if (outRREP.ackReq == TRUE)
      {
        /* include AckReq Message TLV */
      }

      if (outRREP.metricType != DEFAULT_METRIC_TYPE)
      { /* Build MetricType Message TLV */
        metricMsgTlv.value := outRREP.metricType
      }

      /* Build Address Block */
      AddrBlk := {outRREP.origAddr and outRREP.targAddr}
             using prefix length information from
             outRREP.targPrefixLen if necessary

      /* TargSeqNum Address Block TLV */
      targSeqNumAddrBlkTlv.value := outRREP.targSeqNum

      /* Build Metric Address Block TLV containing TargAddrMetric*/
      metricAddrBlkTlv.value := outRREP.targAddrMetric
      if (outRREP.validityTime is required)
      {
        /* Build VALIDITY_TIME Address Block TLV */
        VALIDITY_TIMEAddrBlkTlv.value := outRREP.validityTime
      }

      Build_RFC_5444_message_header (RREP, 4, IPv4 or IPv6, NN,
                outRREP.hopLimit, 0, tlvLength)
      /* unicast RFC 5444 message to rte[OrigAddr].NextHop */
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Regenerate_RREP" subsection -->

</section>  <!-- end of "RREP Algorithms" subsection -->

<section anchor="rerr-algorithms"
  title="Example Algorithms for AODVv2 RERR Operations">

  <t>RERR message parameters, where RERR can be inRERR or outRERR:
  <list style="empty">
  <t> RERR.hopLimit := the maximum number of hops this RERR can traverse </t>
  <t> RERR.pktSource := source IP of unforwardable packet (if present) </t>
  <t> RERR.metricType := metric type for routes to unreachable destinations </t>
  <t> RERR.unreachableAddressList[] := addresses of unreachable destinations</t>
  <t> RERR.prefixLengthList[] := prefix lengths of unreachable destinations </t>
  <t> RERR.seqNumList[] := sequence numbers for unreachable destinations </t>
  <t> RERR.intf := the interface on which the RERR was received </t>
  </list>
  </t>
<section anchor="Generate_RERR" title="Generate_RERR">

<t>
   There are two parts to this function, based on whether it was triggered
   by an undeliverable packet or a broken link to neighboring AODVv2 router.
<figure>
<artwork>
    Generate_RERR(error_type, triggerPkt, brokenLinkNbrIp)
       /* error_type is either undeliverable_packet or broken_link */
    {
      switch (error_type)
      {
        case (broken_link):
             /* a RERR will be required for each MetricType */
        foreach metric type in use
        {
          num-broken-addr := 0
          precursors[] := new empty precursor list
          outRERR.hopLimit := MAX_HOPCOUNT
          outRERR.metricType := the metric type for this loop
          /* find routes which are now Invalid */
          foreach (rte in route table)
          {
            if (brokenLinkNbrIp == rte.nextHop AND
                          rte.MetricType == outRERR.metricType AND
               (rte.State == Active OR
               (rte.State == Idle AND ENABLE_IDLE_IN_RERR)))
            {
               rte.State := Invalid;
               precursors += rte.Precursors (if any)
               outRERR.unreachableAddressList[num-broken-addr] :=
                                                  rte.Address
               outRERR.prefixLengthList[num-broken-addr] :=
                                                  rte.PrefixLength
               outRERR.seqNumList[num-broken-addr] := rte.SeqNum
               num-broken-addr := num-broken-addr + 1
            }
          }
          if (0 != num-broken-addr)
          { /* build and send RFC5444 message as below, then
               repeat loop for other MetricTypes */           }
        }
        case (undeliverable_packet):
          num-broken-addr=1
          outRERR.hopLimit := MAX_HOPCOUNT
          outRERR.pktSource := triggerPkt.srcIP or
                        triggerPkt.targAddr if packet was a RREP
          /* optional to include outRERR.metricType */
          outRERR.unreachableAddressList[0] := triggerPkt.destIP or
                        triggerPkt.origAddr if packet was a RREP
      }
      if (triggerPkt exists)
      { /* Build PktSource Message TLV */
        pktSourceMessageTlv.value := outRERR.pktSource
      }
      if (outRERR.metricType != DEFAULT_METRIC_TYPE)
      { /* Build MetricType Message TLV */
        metricMsgTlv.value := outRERR.metricType
      }

      /* The remaining steps add address, prefix length
         and sequence number information for each
         UnreachableAddress, while conforming to the allowed MTU.
         If the MTU is reached, a new message MUST be created. */
      /* Build Address Block */
      AddrBlk := outRERR.unreachableAddressList[]
               using prefix length information from
               outRERR.prefixLengthList[] if necessary

      /* Add SeqNum Address Block TLV including index values */
      seqNumAddrBlkTLV := outRERR.seqNumList[]

      Build_RFC_5444_message_header (RERR, 4, IPv4 or IPv6, NN,
                outRERR.hopLimit, 0, tlvLength)
      if (undeliverable_packet)
        /* unicast outRERR to rte[outRERR.pktSource].NextHop */
      else if (broken_link)
        /* unicast to precursors, or multicast to LL-MANET-Routers */
    }
</artwork>
</figure>

</t>

</section>  <!-- end of "Generate_RERR" subsection -->

<section anchor="Receive_RERR" title="Receive_RERR">

<t>
<figure>
<artwork>
    Receive_RERR (inRERR)
    {
      if (inRERR does not contain msg_hop_limit and at least
                                      one UnreachableAddress)
        return;

      if (inRERR.metricType is present but an unknown value)
        return;

      /* Extract inRERR values, copy relevant UnreachableAddresses,
         their prefix lengths, and sequence numbers to outRERR */
      num-broken-addr := 0;
      precursors[] := new empty list of type precursors/;

      foreach (unreachableAddress in inRERR.unreachableAddressList)
      {
        if (unreachableAddress is not valid routable
                                                and unicast address)
          continue;
        /* find a matching route table entry, assume
                   DEFAULT_METRIC_TYPE if no MetricType included */
        rte := Fetch_Route_Table_Entry (unreachableAddress,
                                           inRERR.metricType)
        if (rte does not exist)
          continue;
        if (rte.State == Invalid)/* ignore already invalid routes */
          continue;
        if (rte.NextHop != inRERR.nbrIP OR
                                rte.NextHopInterface != inRERR.intf)
          continue;
        if (unreachableAddress SeqNum (if known) &lt; rte.SeqNum)
          continue;

        /* keep a note of all precursors of newly Invalid routes */
        precursors += rte.Precursors (if any)

        /* assume prefix length is address length if not included*/
        if (rte.PrefixLength != unreachableAddress prefixLength)
        {
          /* create new route with unreachableAddress information */
          invalidRte := Create_Route_Table_Entry(unreachableAddress,
                unreachableAddress prefixLength,
                unreachableAddress seqNum, inRERR.metricType)
          invalidRte.State := Invalid

          if (rte.PrefixLength > unreachableAddress prefixLength)
            expunge_route(rte);
          rte := invalidRte;
        }
        else if (rte.PrefixLength == unreachableAddress prefixLength)
          rte.State := Invalid;

        outRERR.unreachableAddressList[num-broken-addr] :=rte.Address
        outRERR.prefixLengthList[num-broken-addr] := rte.PrefixLength
        outRERR.seqNumList[num-broken-addr] := rte.SeqNum
        num-broken-addr := num-broken-addr + 1
      }

      if (num-broken-addr)
        Regenerate_RERR(outRERR, inRERR, precursors)
    }
</artwork>
</figure>
<vspace blankLines="27"/>
</t>


</section>  <!-- end of "Receive_RERR" subsection -->

<section anchor="Regenerate_RERR" title="Regenerate_RERR">

<t>
<figure>
<artwork>
    Regenerate_RERR (outRERR, inRERR, precursors)
    {
      /* Marshal parameters */
      outRERR.hopLimit := inRERR.hopLimit - 1
      if (outRERR.hopLimit == 0) /* don't regenerate */
        return;

      outRERR.pktSource := inRERR.pktSource (if included)
      outRERR.metricType := inRERR.MetricType (if included)
                           or DEFAULT_METRIC_TYPE
      /* UnreachableAddressList[], SeqNumList[], and
         PrefixLengthList[] are already up-to-date */

      if (outRERR.pktSource exists)
      {
        /* Build PktSource Message TLV */
        pktSourceMessageTlv.value := outRERR.pktSource
      }
      if (outRERR.metricType != DEFAULT_METRIC_TYPE)
      {
        /* Build MetricType Message TLV */
        metricMsgTlv.value := outRERR.metricType
      }

      /* Build Address Block */
      <!-- num-addr := num-broken-addr;  -->
      AddrBlk := outRERR.unreachableAddressList[] using prefix length
            information from outRERR.prefixLengthList[] if necessary

      /* Add SeqNum AddressBlock TLV including index values */
      seqNumAddrTLV := outRERR.seqNumList[]

      Build_RFC_5444_message_header (RERR, 4, IPv4 or IPv6, NN,
                outRERR.hopLimit, 0, tlvLength)
      if (outRERR.pktSource exists) {
        /* unicast RFC 5444 message to outRERR.pktSource */
      } else if (number of precursors == 1) {
        /* unicast RFC 5444 message to precursors[0] */
      } else if (number of precursors > 1) {
        /* unicast RFC 5444 message to all precursors, or multicast
           RFC 5444 message to RERR_PRECURSORS if preferable */
      } else {
        /* multicast RFC 5444 message to LL-MANET-Routers */
      }
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Regenerate_RERR" subsection -->

</section>  <!-- end of "RERR Algorithms" subsection -->

<section anchor="rrep_ack-algorithms"
  title="Example Algorithms for AODVv2 RREP_Ack Operations">

<section anchor="Generate_RREP_Ack" title="Generate_RREP_Ack">

<t>
<figure>
<artwork>
    /* To be sent when RREP includes the AckReq data element */
    Generate_RREP_Ack(inRREP)
    {
      Build_RFC_5444_message_header (RREP_Ack, 4, IPv4 or IPv6, NN,
                1, 0, 0)
      /* unicast RFC 5444 message to inRREP.nbrIP */
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Generate_RREP_Ack" subsection -->

<section anchor="Receive_RREP_Ack" title="Receive_RREP_Ack">

<t>
<figure>
<artwork>

    Receive_RREP_Ack(inRREP_Ack)
    {
      /* cancel timeout event for the node sending RREP_Ack */
    }

</artwork>
</figure>
</t>
</section>  <!-- end of "Receive_RREP_Ack" subsection -->

<section anchor="Timeout_RREP_Ack" title="Timeout_RREP_Ack">

<t>
<figure>
<artwork>
    Timeout_RREP_Ack(outRREP)
    {
      /* insert unresponsive node into blacklist */
    }
</artwork>
</figure>
</t>
</section>  <!-- end of "Timeout_RREP_Ack" subsection -->

</section>  <!-- end of "RREP_Ack Algorithms" subsection -->

</section>  <!-- end of "Example Algorithms" major section -->

<!--  Sadly, this section is being deleted.  When re-using,
      search for <!CEP  ..... CEP> to "re-comment" the previous comments.
      Nested comments are not allowed...

<section anchor="rfc5444-formats"
      title="Example RFC 5444-compliant packet formats">
  <t>The following subsections show example RFC 5444-compliant
    packets for AODVv2 message types RREQ, RREP, RERR, and RREP_Ack.
    These
  proposed message formats are designed based on expected savings
  from IPv6 addressable MANET nodes, and a layout for the Address TLVs
  that may be viewed as natural, even if perhaps not the absolute
  most compact possible encoding.</t>

  <t>For RteMsgs, the msg-hdr fields are followed by
  at least one and optionally two Address Blocks.  The first AddrBlk
  contains OrigAddr and TargAddr.  For each AddrBlk,
  there must be AddrTLVs of type Metric and one of the SeqNum types
  (i.e, OrigSeqNum, TargSeqNum, or Seqnum).
  </t>

  <t>
  There is no MetricType Message TLV present, so the Metric
  AddrTLV measures HopCount.
  The Metric Address Block TLV also provides a way for the AODV router
  generating the RREQ or RREP to supply an initial nonzero cost for the route
  to its client node (OrigAddr or TargAddr, for RREQ or RREP respectively).</t>

  <t>In all cases, the length of an address (32 bits for IPv4 and
    128 bits for IPv6) inside an AODVv2 message is indicated
    by the msg-addr-length (MAL) in the msg-header, as specified
    in <xref target="RFC5444"/>.</t>

  <t>The RFC 5444 header preceding AODVv2 messages in this document
    has the format illustrated in <xref target="fig5444_header"/>.

  <figure anchor="fig5444_header" title="RFC 5444 Packet Header">
<artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+
    | PV=0 |  PF=0  |
    +-+-+-+-+-+-+-+-+
]]></artwork>
<CEP            <postamble></postamble>  CEP>
          </figure>
  <vspace blankLines="1"/>
  The fields in <xref target="fig5444_header"/> are to be interpreted
  as follows:

<?rfc compact="yes" ?>    <CEP conserve vertical whitespace CEP>
<?rfc subcompact="yes" ?>  <CEP don't keep a blank line between list items CEP>
  <list style="symbols">
    <t>PV=0 (Packet Header Version == 0)</t>

    <t>PF=0 (Packet Flags == 0)</t>
  </list>
</t>


<section anchor="RREQ-format" title="RREQ Message Format">
    <t><xref target="figRREQ"/> illustrates an example RREQ message format.

      <figure anchor="figRREQ"
     title="Example IPv4 RREQ, with OrigSeqNum and Metric Address Block TLVs">
<artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | msg-type=RREQ | MF=4  | MAL=3 |          msg-size=28          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | msg-hop-limit |      msg.tlvs-length=0        |   num-addr=2  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |1|0|0|0|0| Rsv | head-length=3 | Head (bytes for Orig & Target):
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :Head(Orig&Targ)|   Orig.Mid    |  Target.Mid   |addr.TLV.len=11:
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :addr.TLV.len=11|type=OrigSeqNum|0|1|0|1|0|0|Rsv| Index-start=0 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | tlv-length=2  |     Orig.Node Sequence #      |  type=Metric  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |0|1|0|1|0|0|Rsv| Index-start=0 | tlv-length=1  | OrigAddrHopCt |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
<!CEP            <postamble></postamble>   CEP>
          </figure>

<!CEP  <vspace blankLines="2" />  CEP>
  The fields in <xref target="figRREQ"/> are to be interpreted as follows:

<?rfc compact="yes" ?>    <!CEP conserve vertical whitespace CEP>
<?rfc subcompact="yes" ?>  <!CEP don't keep a blank line between list items CEP>
  <list style="symbols">
    <t>msg-type=RREQ (first [and only] message is of type RREQ)</t>
    <t>MF:=4 (Message Flags := 4 [only msg-hop-limit field is present])</t>
    <t>MAL:=3 (Message Address Length indicator [3 for IPv4, 15 for IPv6])</t>
    <t>msg-size=28 (octets, counting MsgHdr, MsgTLVs, and AddrBlks)</t>
    <t>msg-hop-limit (initially MAX_HOPCOUNT by default)</t>
    <t>msg.tlvs-length=0 (no Message TLVs)</t>
    <t>num-addr=2 (OrigAddr and TargAddr in RteMsg AddrBlock)</t>
    <t>AddrBlk flags:
    <list style="symbols">
    <t>bit 0 (ahashead): 1</t>
    <t>bit 1 (ahasfulltail): 0</t>
    <t>bit 2 (ahaszerotail): 0</t>
    <t>bit 3 (ahassingleprelen): 0</t>
    <t>bit 4 (ahasmultiprelen): 0</t>
    <t>bits 5-7:  RESERVED</t>
    </list></t>
    <t>head-length=3 (length of head part of each address is 3 octets)</t>
    <t>Head
         (3 initial bytes for both Originating &amp; Target addresses)</t>
    <t>Orig.Mid  (4th byte of Originating Address)</t>
    <t>Target.Mid  (4th byte of Target Address)</t>
    <t>addr.TLV.len := 11 (length in bytes for OrigSeqNum and Metric TLVs</t>
    <t>type=OrigSeqNum (type of first AddrBlk TLV, value 2 octets)</t>
    <t>AddrTLV flags for the OrigSeqNum TLV:
    <list style="symbols">
    <t>bit 0 (thastypeext): 0</t>
    <t>bit 1 (thassingleindex): 1</t>
    <t>bit 2 (thasmultiindex): 0</t>
    <t>bit 3 (thasvalue): 1</t>
    <t>bit 4 (thasextlen): 0</t>
    <t>bit 5 (tismultivalue): 0</t>
    <t>bits 6-7:  RESERVED</t>
    </list></t>
    <t>Index-start=0 (OrigSeqNum TLV value applies at index 0)</t>
    <t>tlv-length=2 (so there is only one TLV value, [1 = 2/2])</t>
    <t>Orig.Node Sequence # (TLV value for the OrigSeqNum TLV</t>
    <t>type=Metric (AddrTLV type of second AddrBlk TLV, values 1 octet)</t>
    <t>AddrTLV flags for Metric TLV:
    <list style="symbols">
    <t>bit 0 (thastypeext): 0</t>
    <t>bit 1 (thassingleindex): 1</t>
    <t>bit 2 (thasmultiindex): 0</t>
    <t>bit 3 (thasvalue): 1</t>
    <t>bit 4 (thasextlen): 0</t>
    <t>bit 5 (tismultivalue): 0</t>
    <t>bits 6-7:  RESERVED</t>
    </list></t>
    <t>Index-start=0 (Metric TLV values start at index 0)</t>
    <t>tlv-length=1 (so there is only one TLV value, [1 = 1/1])</t>
    <t>OrigAddrHopCt (first [and only] TLV value for the Metric TLV)</t>
  </list>
  </t>

</section>

<section anchor="RREP-format" title="RREP Message Format">
  <t><xref target="RREPstruct"/> illustrates a packet format for
    an example RREP message.

  <figure anchor="RREPstruct"
    title="Example IPv4 RREP, with TargSeqNum TLV and 1 Metric">
<artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | msg-type=RREP | MF=4  | MAL=3 |          msg-size=28          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | msg-hop-limit |      msg.tlvs-length=0        |   num-addr=2  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |1|0|0|0|0| Rsv | head-length=3 | Head (bytes for Orig & Target):
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :Head(Orig&Targ)|   Orig.Mid    |  Target.Mid   |addr.TLV.len=11:
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :addr.TLV.len=11|type=TargSeqNum|0|1|0|1|0|0|Rsv| Index-start=1 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | tlv-length=2  |     Targ.Node Sequence #      |  type=Metric  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |0|1|0|1|0|0|Rsv| Index-start=1 | tlv-length=1  | TargAddrHopCt |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
<!CEP            <postamble></postamble>   CEP>
          </figure>

  <vspace blankLines="4"/>
  The fields in <xref target="RREPstruct"/> are to be interpreted as follows:

  <list style="symbols">
    <t>msg-type=RREP (first [and only] message is of type RREP)</t>
    <t>MF:=4 (Message Flags = 4 [only msg-hop-limit field is present])</t>
    <t>MAL:=3 (Message Address Length indicator [3 for IPv4, 15 for IPv6])</t>
    <t>msg-size=28 (octets, counting MsgHdr, MsgTLVs, and AddrBlks)</t>
    <t>msg-hop-limit (initially MAX_HOPCOUNT by default)</t>
    <t>msg.tlvs-length=0 (no Message TLVs)</t>
    <t>num-addr=2 (OrigAddr and TargAddr in RteMsg AddrBlock)</t>
    <t>AddrBlk flags:
    <list style="symbols">
    <t>bit 0 (ahashead): 1</t>
    <t>bit 1 (ahasfulltail): 0</t>
    <t>bit 2 (ahaszerotail): 0</t>
    <t>bit 3 (ahassingleprelen): 0</t>
    <t>bit 4 (ahasmultiprelen): 0</t>
    <t>bits 5-7:  RESERVED</t>
    </list></t>
    <t>head-length=3 (length of head part of each address is 3 octets)</t>
    <t>Head
         (3 initial bytes for both Originating &amp; Target addresses)</t>
    <t>Orig.Mid  (4th byte of Originating Address)</t>
    <t>Target.Mid  (4th byte of Target Address)</t>
  <t>addr.TLV.len = 11
    (length in bytes for TargSeqNum TLV and Metric TLV</t>
    <t>type=TargSeqNum (type of first AddrBlk TLV, value 2 octets)</t>
    <t>AddrTLV flags for the TargSeqNum TLV:
    <list style="symbols">
    <t>bit 0 (thastypeext): 0</t>
    <t>bit 1 (thassingleindex): 1</t>
    <t>bit 2 (thasmultiindex): 0</t>
    <t>bit 3 (thasvalue): 1</t>
    <t>bit 4 (thasextlen): 0</t>
    <t>bit 5 (tismultivalue): 0</t>
    <t>bits 6-7:  RESERVED</t>
    </list></t>
  <t>Index-start=1
    (TargSeqNum TLV value applies to address at index 1)</t>
    <t>tlv-length=2 (there is one TLV value, 2 bytes in length)</t>
  <t>Targ.Node Sequence # (value for the TargSeqNum TLV)</t>
    <t>type=Metric (AddrTLV type of second AddrBlk TLV, value 1 octet)</t>
  <t>AddrTLV flags for the Metric TLV
    [01010000, same as for TargSeqNum TLV]</t>
    <t>Index-start=1 (Metric TLV values start at index 1)</t>
    <t>tlv-length=1 (there is one TLV value, 1 byte in length)</t>
    <t>TargAddrHopCt (first [and only] TLV value for Metric TLV)</t>
  </list>
  <vspace blankLines="23"/>
  </t>

</section>

<section anchor="RERR-format" title="RERR Message Format">
      <t><xref target="figRERR"/> illustrates an example RERR
        message format.
  <figure anchor="figRERR"
    title="Example IPv4 RERR with Two UnreachableAddresses">
<artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | msg-type=RERR | MF=4  | MAL=3 |          msg-size=24          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    | msg-hop-limit |      msg.tlvs-length=0        |   num-addr=2  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |1|0|0|0|0| Rsv | head-length=3 | Head (for both destinations)  :
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :Head (3rd byte)|  Mid (Dest_1) | Mid (Dest_2)  | addr.TLV.len=7:
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :addr.TLV.len=7 |  type=SeqNum  |0|0|1|1|0|1|Rsv| tlv-length=4  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |        Dest_1 Sequence #      |        Dest_2 Sequence #      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
<!CEP            <postamble>RERR </postamble>   CEP>
          </figure>

  The fields in <xref target="figRERR"/> are to be interpreted as follows:
  <list style="symbols">
    <t>msg-type=RERR (first [and only] message is of type RERR)</t>
    <t>MF:=4 (Message Flags = 4 [only msg-hop-limit field is present])</t>
    <t>MAL:=3 (Message Address Length indicator [3 for IPv4, 15 for IPv6])</t>
    <t>msg-size=24 (octets, counting MsgHdr, MsgTLVs, and AddrBlks)</t>
    <t>msg-hop-limit (initially MAX_HOPCOUNT by default)</t>
    <t>msg.tlvs-length=0 (no Message TLVs)</t>
    <t>num-addr=2 (OrigAddr and TargAddr in RteMsg AddrBlock)</t>
    <t>AddrBlk flags == 10000000
      [same as RREQ and RREP AddrBlk examples]</t>
    <t>head-length=3 (length of head part of each address is 3 octets)</t>
    <t>Head
     (3 initial bytes for both UnreachableAddresses, Dest_1 and Dest_2)</t>
    <t>Dest_1.Mid  (4th byte of Dest_1 IP address)</t>
    <t>Dest_2.Mid  (4th byte of Dest_2 IP address)</t>
    <t>addr.TLV.len = 7 (length in bytes for SeqNum TLV</t>
    <t>type=SeqNum (AddrTLV type of AddrBlk TLV, values 2 octets each)</t>
    <t>AddrTLV flags for SeqNum TLV:
    <list style="symbols">
    <t>bit 0 (thastypeext): 0</t>
    <t>bit 1 (thassingleindex): 0</t>
    <t>bit 2 (thasmultiindex): 1</t>
    <t>bit 3 (thasvalue): 1</t>
    <t>bit 4 (thasextlen): 0</t>
    <t>bit 5 (tismultivalue): 1</t>
    <t>bits 6-7:  RESERVED</t>
    </list></t>
    <t>tlv-length=4 (so there are two TLV values, [2 = 4/2])</t>
    <t>Dest_1 Sequence # (first of two TLV values for the SeqNum TLV)</t>
    <t>Dest_2 Sequence # (second of two TLV values for the SeqNum TLV)</t>

  </list>
  </t>

</section>

<!CEP Removed: issue #40 CEP>
<section anchor="RREP_Ack-format" title="RREP_Ack Message Format">
  <t>The figure below illustrates a packet format for an example
    RREP_Ack message.  </t>

  <t><figure anchor="figRREPAk" title="Example IPv4 RREP_Ack">
<artwork><![CDATA[
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |msgtype=RREPAck| MF=0  | MAL=3 |          msg-size=4           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
          </figure>
<!CEP|     Targ.Node Sequence #      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   CEP>
  <vspace blankLines="4"/>
  The fields in <xref target="RREPstruct"/> are to be interpreted as follows:

  <list style="symbols">
    <t>msg-type=RREPAck (first [and only] message is of type RREP_Ack)</t>
    <t>MF:=0 (Message Flags = 0 [no field is present])</t>
    <t>MAL:=3 (Message Address Length indicator [3 for IPv4, 15 for IPv6])</t>
    <t>msg-size=4</t>
<!CEP    <t>msg.tlvs-length=0 (no Message TLVs)</t>  CEP>
  </list>
  </t>

</section>
<!CEP End removed section: issue #40 CEP>

</section>
   End of deleting the example packet formats...  -->


<section anchor="changes-06" title="Changes since revision ...-06.txt">

<t> This section lists the changes since AODVv2 revision ...-06.txt
</t>

<t><list style="symbols">
  <t>
    Added Victoria Mercieca as co-author.
  </t>

  <t>
    Reorganized protocol message descriptions into
    major subsections for each protocol message.  For protocol
    messages, organized processing into Generation, Reception, and
    Regeneration subsections.
  </t>

  <t>
    Separated RREQ and RREP message processing description into separate major
    subsection which had previously been combined into RteMsg description.
  </t>

  <t>
    Enlarged RREQ Table function to include similar processing for optional
    flooded RREP messages.  The table name has been correspondingly been
    changed to be the Table for Multicast RteMsgs.
  </t>

  <t>
    Moved sections for Multiple Interfaces and AODVv2 Control Message
    Generation Limits to be major subsections of the AODVv2 Protocol
    Operations section.
  </t>

  <t>
    Reorganized the protocol message processing steps into the subsections
    as previously described, adopting a more step-by-step presentation.
  </t>

  <t>
    Coalesced the router states Broken and Expired into a new combined state
    named the Invalid state.  No changes in processing are required for this.
  </t>

  <t>
    Merged the sections describing Next-hop Router Adjacency Monitoring
    and Blacklists.
  </t>

  <t>
    Specified that routes created during Route Discovery are marked as Idle
    routes.  If they are used for carrying data they become Active routes.
  </t>

  <t>
    Added Route.LastSeqnum information to route table, so that route
    activity and sequence number validity can be tracked separately.
    An active route can still forward traffic even if the sequence
    number has not been refreshed within MAX_SEQNUM_LIFETIME.
  </t>

  <t>
    Mandated implementation of RREP_Ack as response to AckReq Message TLV
    in RREP messages.  Added field to RREP_Ack to ensure correspondence
    to the correct AckReq message.
  </t>

  <t>
    Added explanations for what happens if protocol constants are given
    different values on different AODVv2 routers.
  </t>

  <t>
    Specified that AODVv2 implementations are free to choose their own
    heuristics for reducing multicast overhead, including RFC 6621.
  </t>

  <t>
     Added appendix to identify AODVv2 requirements from OS
     implementation of IP and ICMP.
  </t>

  <t>
     Deleted appendix showing example RFC 5444 packet formats.
  </t>

  <t>
     Clarification on the use of RFC 5497 VALIDITY_TIME.
  </t>

  <t>
     In Terminology, deleted superfluous definitions, added missing definitions.
  </t>

  <t>
     Numerous editorial improvements and clarifications.
  </t>


  </list> </t>

</section> <!--section anchor="changes-05"
                       title="Changes since revision ...-05.txt" -->


<section anchor="changes-05" title="Changes between revisions 5 and 6">

<t> This section lists the changes between AODVv2 revisions ...-05.txt
    and ...-06.txt.
</t>

<t><list style="symbols">
  <t>
    Added Lotte Steenbrink as co-author.
  </t>

  <t>
    Reorganized section on Metrics to improve readability by putting
    specific topics into subsections.
  </t>

  <t>
    Introduced concept of data element, which is used to clarify the method
    of enabling RFC 5444 representation for AODVv2 data elements.  A list of
    Data Elements was introduced in section 3, which provides a better
    understanding of their role than was previously supplied by the
    table of notational devices.
  </t>

  <t>
    Replaced instances of OrigNode by OrigAddr whenever the more
    specific meaning is appropriate.  Similarly for instances of other
    node versus address terminology.
  </t>

  <t>
    Introduced concepts of PrefixLengthList and MetricList in order to
    avoid use of index-based terminology such as OrigNdx and TargNdx.
  </t>

  <t>
    Added section 5, "AODVv2 Message Transmission", describing the
    intended interface to RFC 5444.
  </t>

  <t>
    Included within the main body of the specification the
    mandatory setting of the TLV flag thassingleindex
    for TLVs OrigSeqNum and TargSeqNum.
  </t>

  <t>
    Removed the Route.Timed state.  Created a new flag for route table
    entries known as Route.Timed.  This flag can be set when the route
    is in the active state.  Previous description would require that the
    route table entry be in two states at the same time, which seems
    to be misleading.  The new flag is used to clarify other specification
    details for Timed routes.
  </t>

  <t>
    Created table 3 to show the correspondence between AODVv2 data elements
    and RFC 5444 message components.
  </t>

  <t>
    Replaced "invalid" terminology by the more specific terms
    "broken" or "expired" where appropriate.
  </t>

  <t>
    Eliminated the instance of duplicate specification for inclusion of
    OrigNode (now, OrigAddr) in the message.
  </t>

  <t>
    Corrected the terminology to be Mid instead of Tail for the trailing
    address bits of OrigAddr and TargAddr for the example message formats in
    the appendices.
  </t>

  <t>
    Repaired remaining instances of phraseology that could be construed
    as indicating that AODV only supports a single network interface.
  </t>

  <t>
     Numerous editorial improvements and clarifications.
  </t>


   </list>

</t>

</section>


<section anchor="changes-04" title="Changes from revision ...-04.txt">

<t> This section lists the changes between AODVv2 revisions ...-04.txt
    and ...-05.txt.
</t>

<t><list style="symbols">
  <t>
    Normative text moved out of definitions into the
    relevant section of the body of the specification.
  </t>

  <t>
    Editorial improvements and improvements to consistent terminology were
    made.  Replaced "retransmit" by the slightly more accurate term
    "regenerate".
  </t>

  <t>
    Issues were resolved as discussed on the mailing list.
  </t>

  <t>
    Changed definition of LoopFree as suggested by Kedar Namjoshi and
    Richard Trefler to avoid the failure condition that they have described.
    In order to make understanding easier, replaced abstract parameters
    R1 by RteMsg and R2 by Route to reduce the level of abstraction when
    the function LoopFree is discussed.
  </t>

  <t>
    Added text to clarify that different metrics may have
    different data types and different ranges of acceptable values.
  </t>

  <t>
    Added text to section "RteMsg Structure" to emphasize the
    proper use of RFC 5444.
  </t>

  <t>
    Included within the main body of the specification the
    mandatory setting of the TLV flag thassingleindex
    for TLVs OrigSeqNum and TargSeqNum.
  </t>

  <t>
    Made more extensive use of the AdvRte terminology, in order to better
    distinguish between the incoming RREQ or RREP message (i.e., RteMsg)
    versus the route advertised by the RteMsg (i.e., AdvRte).
  </t>

   </list>

</t>

</section>


<section anchor="changes-03" title="Changes from revision ...-03.txt">

<t> This section lists the changes between AODVv2 revisions ...-03.txt
    and ...-04.txt.
</t>

<t><list style="symbols">
  <t>
    An appendix was added to exhibit algorithmic code
    for implementation of AODVv2 functions.
  </t>

  <t>
    Numerous editorial improvements and improvements to
    consistent terminology were made.  Terminology related
    to prefix lengths was made consistent.  Some items listed
    in "Notational Conventions" were no longer used, and so
    deleted.
  </t>

  <t>
    Issues were resolved as discussed on the mailing list.
  </t>

  <t>
    Appropriate instances of "may" were changed to "MAY".
  </t>

  <t>
    Definition inserted for "upstream".
  </t>

  <t>
    Route.Precursors included as an *optional* route table field
  </t>

  <t>
    Reworded text to avoid use of "relevant".
  </t>

  <t>
    Deleted references to "DestOnly" flag.
  </t>

  <t>
    Refined statements about MetricType TLV to allow for
    omission when MetricType == HopCount.
  </t>

  <t>
    Bulletized list in section 8.1
  </t>

  <t>
    ENABLE_IDLE_UNREACHABLE renamed to be ENABLE_IDLE_IN_RERR
  </t>

  <t>
    Transmission and subscription to LL-MANET-Routers converted
    to MUST from SHOULD.
  </t>
  </list> </t>

</section> <!-- End "Changes from revision ...-03.txt"  -->

<section anchor="changes-02" title="Changes from revision ...-02.txt">

<t> This section lists the changes between AODVv2 revisions ...-02.txt
    and ...-03.txt.
</t>

<t><list style="symbols">
  <t>
    The "Added Node" feature was removed.  This feature was
    intended to enable additional routing information to be
    carried within a RREQ or a RREP message, thus increasing the
    amount of topological information available to nodes along
    a routing path.  However, enlarging the packet size to include
    information which might never be used can increase congestion
    of the wireless medium.  The feature can be included as an
    optional feature at a later date when better algorithms are
    understood for determining when the inclusion of additional
    routing information might be worthwhile.
  </t>

  <t>
    Numerous editorial improvements and improvements to
    consistent terminology were made.  Instances of OrigNodeNdx
    and TargNodeNdx were replaced by OrigNdx and TargNdx,
    to be consistent with the terminology shown in
    <xref target="conventions"/>.
  </t>

  <t>
    Example RREQ and RREP message formats shown in the Appendices
    were changed to use OrigSeqNum and TargSeqNum message TLVs
    instead of using the SeqNum message TLV.
  </t>

  <t>
    Inclusion of the OrigNode's SeqNum in the RREP message
    is not specified.  The processing rules for the OrigNode's
    SeqNum were incompletely specified in previous versions
    of the draft, and very little benefit is foreseen for
    including that information, since reverse path forwarding
    is used for the RREP.
  </t>

  <t>
    Additional acknowledgements were included, and contributors
    names were alphabetized.
  </t>

  <t>
    Definitions in the Terminology section capitalize the term to
    be defined.
  </t>

  <t>
    Uncited bibliographic entries deleted.
  </t>

  <t>
    Ancient "Changes" sections were deleted.
  </t>


   </list>

</t>


</section>

<!--
<section anchor="prop_changes"
      title="Proposed additional changes for LOADng conformance">
<t><list style="symbols">


   </list>

</t>
-->

<!-- Issue #28 -->
<section anchor="IPreqs" title="Features of IP needed by AODVv2">
  <t> AODVv2 needs the following:
      <list style="symbols">
        <t> information that IP routes are requested </t>
        <t> information that packets are flowing </t>
        <t> the ability to queue packets. </t>
      </list>
  </t>

  <t>
      A reactive protocol reacts when a route is needed.
      One might say that a route is requested when an application tries to
      send a packet. The fundamental concept of reactive routing is to avoid
      creating routes that are not needed, and the way that has been used to
      know whether a route is needed is when an application tries to send a
      packet.</t>

  <t>
      If an application tries to send a packet, and the route is not
      available, the packet has to wait until the route is available.
  </t>
</section>


<section anchor="multihome" title="Multi-homing Considerations">

  <t>This non-normative information is provided simply to document
     the results of previous efforts to enable multi-homing.
     The intention is to simplify the task of future specification if
     multihoming becomes needed for reactive protocol operation.
  </t>

  <t>Multi-homing is not supported by the AODVv2 specification.
  There has been previous work indicating that it can be supported by
  expanding the sequence number to include the AODVv2 router's IP
  address as a parsable field of the SeqNum.  Otherwise, comparing
     sequence numbers would not work to evaluate freshness.  Even when the
     IP address is included, there isn't a good way to compare sequence
     numbers from different IP addresses, but at least a handling node can
     determine whether the two given sequence numbers are comparable.  If the
     route table can store multiple routes for the same destination, then
     multi-homing can work with sequence numbers augmented by IP addresses.</t>

     <t>This non-normative information is provided simply to document
       the results of previous efforts to enable multi-homing.
       The intention is to simplify the task of future specification if
       multihoming becomes needed for reactive protocol operation.
     </t>
</section>


      <section anchor="change_address_location"
  title="Shifting Network Prefix Advertisement Between AODVv2 Routers">
      <t>Only one AODVv2 router within a MANET SHOULD be
      responsible for a particular address at any time. If two AODVv2
      routers dynamically shift the advertisement of a network prefix, correct
      AODVv2 routing behavior must be observed. The AODVv2 router adding
      the new network prefix must wait for any existing routing information
      about this network prefix to be purged from the network. Therefore, it
      must wait at least ROUTER_SEQNUM_AGE_MAX_TIMEOUT after the
      previous AODVv2 router for this address stopped
      advertising routing information on its behalf.</t>

    </section>
  </back>
</rfc>
<!-- ====================================================================== -->
<!--
  <msg-header> := <msg-type>
                       <msg-size:16>  /* up to 65,545 bytes */
                       <msg-orig-addr>?
                       <msg-hop-limit:8>?
                       <msg-hop-count:8>?
                       <msg-seq-num:16>?
                       <tlv-block>
                       (<addr-block><tlv-block>)*

       <address-block> := <num-addr:8>
                          <addr-flags:8>
                          (<head-length><head>?)?
                          (<tail-length><tail>?)?
                          <mid>*
                          <prefix-length>*

       <tlv-block> := <tlvs-length:16>  /* Aggregate length of <tlv>* */
                      <tlv>*

       <tlv> := <tlv-type:8>
                <tlv-flags:8>
                <tlv-type-ext>?
                (<index-start><index-stop>?)?
                (<length><value>?)?


  -->
